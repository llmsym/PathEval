{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 1.0);\n\tassert(result==false);\n\tresult = has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0);\n\tassert(result==true);\n\tresult = has_close_elements({1.0, ", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 1.0);\n\tassert(result==false);\n\tresult = has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0);\n\tassert(result==true);\n\tresult = has_close_elements({1.0, ", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 1.0);\n\tassert(result==true);\n\tresult = has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0t(result==1);\n\tresult = count_vowels(\"hello\");\n\tassert", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0}, 1.0);\n\tassert(result==false);\n\tresult = has_close_elements({1.0, 2.0, 3.0, 4.0}, 2.0);\n\tassert(result==true);\n\tresult = has_close_elements({1.0, 2.0, 3.0, ", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 1.0);\n\tassert(result==true);\n\tresult = has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0);\n\tassert(result==false);\n\tresult = has_close_elements({1.0, ", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 1.5}, 1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_different_subsequences(vector<int> numbers){\n    int i,j,k;\n    int count=0;\n    for (", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": true}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 2.0t(result==true);\n}#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_increasing(vector<int> sequence){\n    int i;\n    for", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": false}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0}, 1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(vector<int> numbers){\n    int i,sum_left,", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": false}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 1.5}, 1.0t(result==true);\n}#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_increasing(vector<int> sequence){\n    int i;\n    for (i=0;i<sequence.size()-1;i++)", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": false}
{"task_id": "CPP/0", "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\nint main(){\n\tauto result = has_close_elements(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0}, 2.0 1000000000000000000000000000000000000000000000000000000000000000000", "fn": "has_close_elements", "para": "(vector<float> numbers, float threshold)", "type": "bool", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()(())((())))\"t_node->next;\n    }\n    return head;\n}\nint main(){\n\tauto result = reverse_linked_list(new Node(1,new Node(2,new Node(3,new Node(4,new Node(5,new Node(6,new Node(7,new Node(8,new Node(9,new Node(10,new Node(11,new Node(12", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()(())((())))\";\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()(())((())))\"t_node->next;\n        }\n        return head;\n    }\n};/leetcode/206.cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()(())((())))\"t_node->next;\n    }\n    return result;\n}\nint main(){\n\tauto result = reverse_linked_list(new Node(1,new Node(2,new Node(3,new Node(4,new Node(5,new Node(6,new Node(7,new Node(8,new Node(9,new Node(10,new Node(11,new Node(12", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()(())((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()(())((())))\"t_node->next;\n        }\n        return head;\n    }\n};/leetcode/206.cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_profit(vector<int> stock_prices){\n    int max_profit=0;\n    int min_price=stock_prices[0", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())\"t_node->next;\n    }\n    return head;\n}\nint main(){\n\tauto result = reverse_linked_list(new_linked_list({1,2,3,4,5}));\n\tassert(issame(result,{5,4,3,2,1}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n\tresult = separate_paren_groups(\"((()))\");\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n\tresult = separate_paren_groups(\"((()))\");\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n\tresult =", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\"t_node->next;\n        }\n        return head;\n    }\n};\nint main(){\n\tListNode* head = new ListNode(1);\n\thead->next = new ListNode(2);\n\thead->next->next = new ListNode(3);\n\thead->next->next->next = new ListNode(4);\n\thead->next->next->next->next = new ListNode(5);\n\tSolution s;\n", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"((()))\",\"(((())))\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\"t_node->next;\n    }\n    return head;\n}\nint main(){\n\tauto result = reverse_linked_list(new Node(1,new Node(2,new Node(3,new Node(4,new Node(5,NULL))))));\n\tassert(issame(result,new Node(5,new Node(4,new Node(3,new Node(2,new Node(1,NULL))))", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())((()))()(())\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing_number(vector<int> numbers){\n    int i;\n    int sum=0;\n    int n=numbers.size", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())((()))()(())\"t_node->next;\n    }\n    return head;\n}\nint main(){\n    auto result = reverse_linked_list(create_linked_list({1,2,3,4,5}));\n    assert(issame(result,create_linked_list({5,4,3,2,1})));\n}/reverse_linked_list.cpp\n#include<stdio.h>\n", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())((()))()(())\"  }\n    }\n    return result;\n}\nint main(){\n\tauto result = find_all_anagrams(\"abbcabc\", \"abc\");\n\tassert(issame(result,{0,3,6}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())((()))()(())\"t_node->next;\n    }\n    return head;\n}\nint main(){\n\tauto result = reverse_linked_list(new Node(1,new Node(2,new Node(3,new Node(4,new Node(5,NULL))))));\n\tassert(issame(result,new Node(5,new Node(4,new Node(3,new Node(2,new Node(", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"(()())\",\"((()))\",\"()\",\"((())()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())((()))()(())\"t_node->next;\n        }\n        return head;\n    }\n};/leetcode/206.cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverse", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())\"t_node->next;\n        }\n        return head;\n    }\n};/leetcode/206.cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode*", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())\"t_node->next;\n        }\n        return head;\n    }\n};\n\nint main(){\n    Solution s;\n    ListNode* head = new ListNode(1);\n    head->next = new ListNode(2);\n    head->next->next = new ListNode(3);\n    head->next->next->next = new ListNode(4);\n    head->next->next->next->next = new ListNode(5);\n    head->next->next", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())\";\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"3", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(()())\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> result=s.countBits(5);\n\tassert(issame(result,{0,1,1,2,1,2}));\n}/leetcode/counting_bits.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/1", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\nint main(){\n\tauto result = separate_paren_groups(<FILL_ME>);\n\tassert(issame(result,{\"()\",\"(())\",\"(()())\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"(())()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "fn": "separate_paren_groups", "para": "(string paren_string)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tfor(int i=0;i<100;i++){\n\t\tresult*=2;\n\t}\n\tassert(", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.456)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tfor(int i=0;i<10;i++){\n\t\tresult*=2;\n\t}\n\tassert(result", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(abs(result-0.33)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "1.5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_number_of_digits(int number){\n    int count=0;\n    while(number!=0){\n        number/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\t", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": true}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "1.5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(int a,int b){\n\treturn a>b?a:b;\n}\nint main(){\n\tauto result = find_max(1,2);\n\tassert(", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": true}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "1.5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_count_of_digits(int number){\n\tint count=0;\n\twhile(number>0){\n\t\tnumber/=10;\n\t\tcount++;\n\t}\n\treturn count;\n}", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": true}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "1.5;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n\tint count=0;\n\tint max=0;\n\twhile(n){\n\t\tif(n&1){\n\t\t\tcount++;\n\t\t\t", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": false}
{"task_id": "CPP/2", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n    return number-int(number);\n}\nint main(){\n\tauto result = truncate_number(<FILL_ME>);\n\tassert(result==0.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "1.5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(int a,int b){\n\treturn a>b?a:b;\n}\nint main(){\n\tauto result = find_max(1,2);\n\tassert(", "fn": "truncate_number", "para": "(float number)", "type": "float", "pass": true}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_index(vector<int> numbers){\n    int max=0;\n    for (int", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_prime(int num){\n    if (num==1) return false;\n    if (num==2)", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_prime(int num){\n    if (num==1) return false;\n    for (int i=2", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_ones(vector<int> operations){\n    int num=0;\n    for (int i=0;", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5};\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_index(vector<int> numbers){\n    int max=0;\n    int index=0;\n    for (int i=0;", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000000;\n\tint n = 1000000000;\n\tint m = 1000000000;\n\tint k = 1000000000;\n\tint result = solution(n, m, k", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_even(int num){\n    return num%2==0;\n}\nint main(){\n\tauto", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_prime(int num){\n    if (num==1) return false;\n    for (int i=2", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_index(vector<int> numbers){\n    int max_index=0;\n    for", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": true}
{"task_id": "CPP/3", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\nint main(){\n\tauto result = below_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findNumbers(nums);\n\tassert(result==5);\n", "fn": "below_zero", "para": "(vector<int> operations)", "type": "bool", "pass": false}
{"task_id": "CPP/4", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float", "fn": "mean_absolute_deviation", "para": "(vector<float> numbers)", "type": "float", "pass": false}
{"task_id": "CPP/4", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_number(vector<int> numbers){\n    int i=0;\n    int sum", "fn": "mean_absolute_deviation", "para": "(vector<float> numbers)", "type": "float", "pass": false}
{"task_id": "CPP/4", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "mean_absolute_deviation", "para": "(vector<float> numbers)", "type": "float", "pass": false}
{"task_id": "CPP/4", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 0;\n\tassert(result ==#include<stdio.h>\n#", "fn": "mean_absolute_deviation", "para": "(vector<float> numbers)", "type": "float", "pass": false}
{"task_id": "CPP/4", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\nint main(){\n\tauto result = mean_absolute_deviation(<FILL_ME>);\n\tassert(result<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n    float sum=0;\n    float", "fn": "mean_absolute_deviation", "para": "(vector<float> numbers)", "type": "float", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{5,8,6,8,3,8,2},8t> out={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]%2==0) out.push_back(numbers[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = even_numbers({5,8,6,8,3,8,2});\n", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{5,8,6,8,3,8,2},8\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\tvector<int> find_all_factors(int n){\n\t\tvector<int> out={};\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (n%i==0)\n\t\t\t{\n\t\t\t\tout.push_back(i);\n\t\t\t", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{5,8,6,8,3,8,2},8t> out={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]%2==0) out.push_back(numbers[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = evens({5,8,6,8,3,8,2});\n\t", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{5,8,6,8,3,8,2},8\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\tvector<int> get_primes(int n){\n\t\tvector<int> out={};\n\t\tfor (int i=2;i<=n;i++)\n\t\t{\n\t\t\tif (is_prime(i)) out.push_back(i);\n\t\t}\n\t\treturn out;", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{5,8,6,8,3,8,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{5,8,6,8,3,8,2},8t> out;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]%2==0) out.push_back(numbers[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = even_numbers({1,2,3,4,5,6,7,8,", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{2,2,2,2,2},2t> out={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]%2==0) out.push_back(numbers[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_even_numbers({1,2,3,4,5,6});\n\tassert(iss", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{2,2,2,2,2},2\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start, int end){ \n    vector<int> out={};\n    for", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{2,2,2,2,2},2\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start, int end", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{2,2,2,2,2},2\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start, int end", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{2,2,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{2,2,2,2,2},2;\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start, int end){ \n    vector<int> out={};\n   ", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3}, 0);\n\tassert(issame(result,{1,0,2,0,3}));\n\tresult = intersperse({1,2,3}, 1);\n\tassert(issame(result,{1,1,2,1,3}));\n\tresult = intersperse({1,2,3}, 2);\n\tassert(issame(result,{1,2,1,2,1", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3}, 0);\n\tassert(issame(result,{1,0,2,0,3}));\n\tresult = intersperse({1,2,3}, 1);\n\tassert(issame(result,{1,1,2,1,3}));\n\tresult = intersperse({1,2,3}, 2);\n\tassert(issame(result,{1,2,1,2,1", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3}, 0);\n\tassert(issame(result,{1,0,2,0,3}));\n\tresult = intersperse({1,2,3}, 1);\n\tassert(issame(result,{1,1,2,1,3}));\n\tresult = intersperse({1,2,3}, 2);\n\tassert(issame(result,{1,2,1,2,1", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3}, 0);\n\tassert(issame(result,{1,0,2,0,3}));\n\tresult = intersperse({1,2,3}, 1);\n\tassert(issame(result,{1,1,2,1,3}));\n\tresult = intersperse({1,2,3}, 2);\n\tassert(issame(result,{1,2,1,2,1", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/5", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\nint main(){\n\tauto result = intersperse(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3}, 0);\n\tassert(issame(result,{1,0,2,0,3}));\n\tresult = intersperse({1,2,3}, 1);\n\tassert(issame(result,{1,1,2,1,3}));\n\tresult = intersperse({1,2,3}, 2);\n\tassert(issame(result,{1,2,1,2,1", "fn": "intersperse", "para": "(vector<int> numbers, int delimeter)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{2,3,1,3}));\n\tresult = parse_nested_parens(\"((()))((()))\");\n\tassert(issame(result,{2,3,1,3,2,3,1,3}));\n\tresult = parse_nested_parens(\"((()))((()))((()))\");\n\tassert(issame(result,{2,3,1,3,2,3", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{2,3,1}));\n\tresult = parse_nested_parens(\"((()))()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{2,3,1,3,2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\"\n\tassert(issame(result,{1,2,3,4,5,", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{2,3,1,3,2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\"  }\n    return result;\n}\nint main(){\n    auto result = find_all", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{2,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{2,3,1,3,2,3,1}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\"t_node->next;\n        }\n        return head;\n    }\n};/leetcode", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{1,2,3,4,5,6}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\");\n\tassert(issame(result,{1,2,3,4,5,6,7", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))((()))\");\n\tassert(issame(result,{1,2,3,4,1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))((()))((()))\");\n\tassert(issame(result,{1,2,3,4,1,2", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{1,2,1}));\n\tresult = parse_nested_parens(\"((()))((()))\");\n\tassert(issame(result,{1,2,1,2,1}));\n\tresult = parse_nested_parens(\"((()))((()))((()))\");\n\tassert(issame(result,{1,2,1,2,1,2,1}));\n\tresult = parse", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert(issame(result,{1,2,3,4}));\n\tresult = parse_nested_parens(\"((()))\");\n\tassert", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{3,3,3}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{3,3,3,2,2}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\");\n\tassert(issame(result,{3,3,3,2,2,1}));\n\tresult = parse", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{3,3,3}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{3,3,3,3,3}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\");\n\tassert(issame(result,{3,3,3,3,3,3}));\n\tresult = parse", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((()))\");\n\tassert(issame(result,{3,3,3}));\n\tresult = parse_nested_parens(\"((()))((())())\");\n\tassert(issame(result,{3,3,3,4,4}));\n\tresult = parse_nested_parens(\"((()))((())())((()))\");\n\tassert(issame(result,{3,3,3,4,4,4}));\n\tresult = parse", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((())())\");\n\tassert(issame(result,{3,2,1,1}));\n\tresult = parse_nested_parens(\"()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/6", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\nint main(){\n\tauto result = parse_nested_parens(<FILL_ME>);\n\tassert(issame(result,{4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "\"((())())\");\n\tassert(issame(result,{3,3,1}));\n\tresult = parse_nested_parens(\"((())())\");\n\tassert(issame(result,{3,3,1}));\n\tresult = parse_nested_parens(\"()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "fn": "parse_nested_parens", "para": "(string paren_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\" 1000000000000000000;\n\tcout << \"Hello World\" << endl;\n\tcout << \"Hello World\" << endl;\n\tcout << \"Hello World\" << endl;\n\tcout << \"Hello World\" << endl;\n\tcout << \"Hello World\" << endl;\n\tcout << \"Hello", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\"t_by_substring({\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\");\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\"t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\"t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"}, \"xx\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"grunt\",\"grutto\",\"prune\"}, \"gr\"\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> split_and_merge(vector<string> arr, char separator", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"grunt\",\"grrr\",\"prune\"}, \"gr\"t_by_substring({\"grunt\",\"grrr\",\"prune\"}, \"gr\");\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"grunt\",\"grrr\",\"prune\"}, \"gr\"\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> split_and_join(string first_name, string last_", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"grunt\",\"grutto\",\"prune\"}, \"gr\"t_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result =", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"grunt\",\"grrr\",\"prune\"}, \"gr\"t_by_substring(strings, substring);\n\tassert(issame(result,{\"grunt\",\"prune\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"t(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}/test/test_filter_by_substring.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}/filter_by_substring.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\";\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"t_by_substring({\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\");\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"b\");\n\tassert(issame(result,{\"b\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"c\");\n\tassert(issame(result,{\"c\"}));\n\tresult = filter_by", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"b\");\n\tassert(issame(result,{\"b\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"c\");\n\tassert(issame(result,{\"c\"}));\n\tresult = filter_by", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"b\");\n\tassert(issame(result,{\"b\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"c\");\n\tassert(issame(result,{\"c\"}));\n\tresult = filter_by", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/7", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_by_substring(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"b\");\n\tassert(issame(result,{\"b\"}));\n\tresult = filter_by_substring({\"a\",\"b\",\"c\",\"d\"}, \"c\");\n\tassert(issame(result,{\"c\"}));\n\tresult = filter_by", "fn": "filter_by_substring", "para": "(vector<string> strings, string substring)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{55,3628800})t(issame(result,{\"123456789\",\"987", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})t(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n\tassert", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})t(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n\tassert", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{100,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})t(issame(result,{\"111111111111111111111111111111", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})t(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n\tassert", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})\n\tassert(issame(result,{1,2,3}));\n\tresult = rotate_left({1,2,3,4,5});\n\tassert(iss", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,4,5});\n\tassert(issame(result,{15,0});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,4,5});\n\tassert(issame(result,{15,0})  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,4,5});\n\tassert(issame(result,{15,0})t(issame(result,{1,2,3,4,5}));\n\tresult = rotate_left({1,2,3,4,5},1", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,4,5});\n\tassert(issame(result,{15,0})\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120}));\n\tresult = sum_product({1,2,3,0,5});\n\tassert(issame(result,{11,0})t(issame(result,{1,2,3,4,5}));\n\tresult = reverse_list({1,2,3,4,5});\n\tassert", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3});\n\tassert(issame(result,{6,6}));\n\tresult = sum_product({1,2,3,4,5});\n\tassert(issame(result,{15,120})\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120})t(issame(result,{\"1234567890\",\"0123456789\"}));\n}/C++/12.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120})\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sort_array", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120})\n\tassert(issame(result,{1,2,3}));\n}/C++/12_reverse_array.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{15,120})\n\tassert(issame(result,{1,2,3,4,5}));\n}/C++/12.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{3,5,7}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{3,5,7}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{3,5,7}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> result;\n    for", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{3,5,7}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/8", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\nint main(){\n\tauto result = sum_product(<FILL_ME>);\n\tassert(issame(result,{3+5+7,3*5*7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n\n\n", "filling": "{3,5,7}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int", "fn": "sum_product", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{3,2,1,4,5,6,7,8,9,100,100}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{3,2,1,4,5,6,7,8,9,100,100};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{3,3,3,100,100}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{3,2,1,4,5,6,7,8,9,100,100}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({1,1,1,1,1}\t\t}\n\t\t}\n\t\treturn out;\n", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_min(vector<int> numbers){\n    vector<int> out;\n    int min=0;", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({4,4,4,4}t> result = find_all_factors(10);\n", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10}t(issame(", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({4,4,4,4}\n\tassert(issame(result,{1,2,3", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10});\n\tassert(", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10}t", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10}t", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = rolling_max({5,4,3,2,1});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = rolling_max({1,2,3,4,5,6,7,8,9,10}t", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4};\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_min(vector<int> numbers){\n    vector<int> out;\n    int min=numbers", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_min(vector<int> numbers){\n    vector<int> out;\n    int min=numbers[", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4}  }\n    return out;\n}\nint main(){\n\tauto result = rolling_min({1,2,3,4});\n\tassert(issame(result,{1,1,1,1}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4}  }\n    return out;\n}\nint main(){\n\tauto result = rolling_min({1,2,3,4});\n\tassert(issame(result,{1,1,1,1}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/9", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\nint main(){\n\tauto result = rolling_max(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4}\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> out=s.twoSum({2,7,11,15},9);\n\tassert(out[0]==0);\n\tassert(out[1]==1);\n}#include<vector>\n#include<unordered_map>\n", "fn": "rolling_max", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1111\",\"1111\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint string_to_int(string a){\n    int output=0;\n    for (int i=0;i<a.length();i++)\n    {\n        output", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1111\",\"0000\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1)\n       ", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1111\",\"0000\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint string_to_int(string a){\n    int output=0;\n    for (int i=0;i<a.length();i++)\n    {\n        output", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1111\",\"0000\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1111\",\"0000\");\n\tassert(result==\"0\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1111\",\"0000\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1111\",\"0000\");\n\tassert(result==\"0\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"101010\",\"010101\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"101010\",\"010101\");\n\tassert(result==\"010010\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1010\",\"0101\"  }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1010\",\"0101\");\n\tassert(result==\"010010\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1011\",\"1010\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1)\n       ", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"101010\",\"010101\" 1000000007;\n\tint n;\n\tcin>>n;\n\tint arr[n];\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tcin>>arr[i];\n\t}\n\tint ans=0;\n\tfor (int i=0;i<n;i++)\n", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"010010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"101010\",\"010101\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"101010\",\"010101\");\n\tassert(result==\"010010\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1011\",\"1010\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1011\",\"1010\");\n\tassert(result==\"0101\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1010\",\"0101\" 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint arr[n];\n\tfor (int i=0;i<n;i++)\n", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1101\",\"1010\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1)\n        {\n            count", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1010\",\"1011\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1010\",\"1011\");\n\tassert(result==\"0101\");\n}/string_xor.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/11", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_xor(string a,string b){\n    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(<FILL_ME>);\n\tassert(result==\"0101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1010\",\"1011\"  }\n    }\n    return output;\n}\nint main(){\n\tauto result = string_xor(\"1010\",\"1011\");\n\tassert(result==\"0101\");\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h", "fn": "string_xor", "para": "(string a,string b)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"b\", \"c\", \"d\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint sum(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"x\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();i", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"b\", \"c\", \"d\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\"}  }\n    return out;\n}\nint main(){\n\tauto result = longest({\"a\",\"ab\",\"abc\"});\n\tassert(result==\"zzzz\");\n}/longest.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();i++)\n   ", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"ab\", \"abc\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n       ", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/12", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring longest(vector<string> strings){\n    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = longest(<FILL_ME>);\n\tassert(result==\"zzzz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count(vector<int> numbers){\n    int out=0;\n    for (int i=0;i<numbers.size();i++)", "fn": "longest", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14,21\t\t}\n\t\t}\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tint a[n+", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14,21t(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    {\n        if (n%i==0) return ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14,21;\n\tassert(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    for (int i=2;i<=sqrt(n);i", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14,21\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDisappearedNumbers(nums);\n\tassert(result==vector<int>({1,2,3,4,5,6,", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14,21;\n\tassert(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    int i;\n    for (i=2;i<=sqrt(n);i++)\n        if (n%i==0) return 0;\n    return 1;", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,18\n\tassert(result==12);\n}/src/greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b)", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,18\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12, 18t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12, 18t(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    int i;\n    for (i=2;i<=sqrt(n);i++)\n        if (n%i==0) return 0;\n    return 1;\n}", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,18\n\tassert(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,15t(result==1);\n}/test/test_greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n       ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,15t(result==1);\n}/test/test_greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n       ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,15t(result==1);\n}/test/test_greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n       ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,15\n\tassert(result==1);\n}/test/test_greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,15t(result==1);\n}/test/test_greatest_common_divisor.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n       ", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": true}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5t(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint gcd(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5\t\t}\n\t\t}\n\t\tif (flag==0)\n\t\t{\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\treturn 0;\n}#include<stdio.h>\nint main(){\n\tint n,i,j,flag;\n\tscanf(\"%d\",&n);\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tflag=", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": false}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": true}
{"task_id": "CPP/13", "code": "#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint greatest_common_divisor(int a, int b){\n    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\nint main(){\n\tauto result = greatest_common_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5\n\tassert(result==1);\n}#include<stdio.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return 0", "fn": "greatest_common_divisor", "para": "(int a, int b)", "type": "int", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"WWW\"\n\tassert(issame(result,{\"1\",\"12\",\"123\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_combinations(string str){\n    vector<string> out;\n    string current=\"\";", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"WWW\"t_node(1);\n\troot->left=new_node(2);\n\troot->right=new_node(3);\n\troot->left->left=new_node(4);\n\troot->left->right=new_node(5);\n\troot->right->left=new_node(6);\n\troot->right->right=new_node(7);\n\troot->left->left", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"WWW\"t(result,{\"1\",\"11\",\"111\",\"1111\",\"11111\",\"111111\",\"1111111\",\"11111111\",\"111111111\",\"1111111111\"});\n}#include<stdio.h>\n#include<vector>\n#include<string>\n", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"WWW\"t(result,{\"1\",\"11\",\"111\",\"1111\",\"11111\",\"111111\",\"1111111\",\"11111111\",\"111111111\",\"1111111111\"});\n}#include<stdio.h>\n#include<vector>\n#include<string>\n", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"W\",\"WW\",\"WWW\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"WWW\"\n\tassert(issame(result,{\"1\",\"12\",\"123\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_combinations(string str){\n    vector<string> out;\n    string current=\"\";", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{\"\",}));\n\tresult = all_prefixes(\"a\");\n\tassert(issame(result,{\"a\",}));\n\tresult = all_prefixes(\"ab\");\n\tassert(issame(result,{\"a\",\"ab\",}));\n\tresult = all_prefixes(\"abc\");\n\tassert(issame(result,{\"a\",\"ab\",\"abc\",}));\n\tresult = all_prefixes(\"abcd\");\n", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{\"\",}));\n\tresult = all_prefixes(\"a\");\n\tassert(issame(result,{\"a\",}));\n\tresult = all_prefixes(\"ab\");\n\tassert(issame(result,{\"a\",\"ab\",}));\n\tresult = all_prefixes(\"abc\");\n\tassert(issame(result,{\"a\",\"ab\",\"abc\",}));\n\tresult = all_prefixes(\"abcd\");\n", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{\"\",}));\n\tresult = all_prefixes(\"a\");\n\tassert(issame(result,{\"a\",\"a\"}));\n\tresult = all_prefixes(\"ab\");\n\tassert(issame(result,{\"a\",\"a\",\"ab\",\"ab\"}));\n\tresult = all_prefixes(\"abc\");\n\tassert(issame(result,{\"a\",\"a\",\"ab\",\"ab\",\"abc\",\"abc\"}", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{\"\",}));\n\tresult = all_prefixes(\"a\");\n\tassert(issame(result,{\"a\",}));\n\tresult = all_prefixes(\"ab\");\n\tassert(issame(result,{\"a\",\"ab\",}));\n\tresult = all_prefixes(\"abc\");\n\tassert(issame(result,{\"a\",\"ab\",\"abc\",}));\n\tresult = all_prefixes(\"abcd\");\n", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{\"\",}));\n\tresult = all_prefixes(\"a\");\n\tassert(issame(result,{\"\", \"a\"}));\n\tresult = all_prefixes(\"ab\");\n\tassert(issame(result,{\"\", \"a\", \"ab\"}));\n\tresult = all_prefixes(\"abc\");\n\tassert(issame(result,{\"\", \"a\", \"ab\", \"abc\"}));\n\t", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"asdfgh\"t(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n   ", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"asdfgh\"t(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n   ", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"asdfgh\"t(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n   ", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"asdfgh\"t(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n   ", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/14", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\nint main(){\n\tauto result = all_prefixes(<FILL_ME>);\n\tassert(issame(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"asdfgh\"t(result,{\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> all_prefixes(string str){\n    vector<string> out;\n    string current=\"\";\n   ", "fn": "all_prefixes", "para": "(string str)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=0;\n    while(n>0){\n        out+=n%10;\n        n/=10;\n    }\n    return out;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"0123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=0;\n    while(n>0){\n        out+=n%10;\n        n/=10;\n    }\n    return out;\n}\nint", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_cubes(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++)\n    sum+=pow(i,3);\n    return sum;\n", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/15", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring string_sequence(int n){\n    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\nint main(){\n\tauto result = string_sequence(<FILL_ME>);\n\tassert(result==\"012345678910\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=", "fn": "string_sequence", "para": "(int n)", "type": "string", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello\"t_node(1);\n\troot->left=new_node(2);\n\troot->right=new_node(3);\n\troot->left->left=new_node(4);\n\troot->left->right=new_node(5);\n\troot->right->left=new_node(6);\n\troot->right->right=new_node(7);\n\troot->left->left->", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abacabad\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string str){ \n    int count=0;\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n   ", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\");\n\tassert(result==3);\n\tresult = count_distinct_characters(\"ABBA\");\n\tassert(result==2);\n\tresult = count_distinct_characters(\"1122\");\n\tassert(result==2);\n\tresult = count_distinct_characters(\"1222333\"t_sum(1,2,3);\n\tassert(result==6);\n\tresult", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\"t_sum_of_digits(1234567890);\n\tassert(result==45);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint get_sum_of_digits(int n){ \n   ", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aA11\"t_sum(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)\n        sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = get_sum(vector<int>{1,2,3});\n\tassert(result==6);\n}/get_sum.cpp\n#include<stdio.", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string str){ \n    int count=0;\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abacabad\"t_sum(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)\n        sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = array_sum(vector<int>{1,2,3,4,5});\n\tassert(result==15);\n}/array_sum.cpp\n", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\" 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_palindrome(\"madam\");\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_pal", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/16", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_distinct_characters(string str){ \n    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\nint main(){\n\tauto result = count_distinct_characters(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\" 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "count_distinct_characters", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o o o o\");\n\tassert(issame(result,{4,4,4,4}));\n\tresult = parse_music(\"o o o o o\");\n\tassert(issame(result,{4,4,4,4,4}));\n\tresult = parse_music(\"o o o o o o\");\n\tassert(issame(result,{4,4,4,4,4,4}));\n\tresult = parse_music(\"", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o o o o\");\n\tassert(issame(result,{4,4,4,4}));\n\tresult = parse_music(\"o o o o o\");\n\tassert(issame(result,{4,4,4,4,4}));\n\tresult = parse_music(\"o o o o o o\");\n\tassert(issame(result,{4,4,4,4,4,4}));\n\tresult = parse_music(\"", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o o o o\");\n\tassert(issame(result,{4,4,4,4}));\n\tresult = parse_music(\"o o o o o\");\n\tassert(issame(result,{4,4,4,4,4}));\n\tresult = parse_music(\"o o o o o o\");\n\tassert(issame(result,{4,4,4,4,4,4}));\n\tresult = parse_music(\"", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o o o o\");\n\tassert(issame(result,{4,4,4,4}));\n\tresult = parse_music(\"o o o o o\");\n\tassert(issame(result,{4,4,4,4,4}));\n\tresult = parse_music(\"o o o o o o\");\n\tassert(issame(result,{4,4,4,4,4,4}));\n\tresult = parse_music(\"", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,2,1,1,4,4,4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{1,1,1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/17", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> parse_music(string music_string){ \n    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\nint main(){\n\tauto result = parse_music(<FILL_ME>);\n\tassert(issame(result,{2,1,2,1,4,2,4,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o| o", "fn": "parse_music", "para": "(string music_string)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"\",\"a\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"a\");\n\tassert(result==1);\n\tresult = how_many_times(\"a\",\"aa\");\n\tassert(result==0);\n\tresult", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"\",\"a\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"a\");\n\tassert(result==1);\n\tresult = how_many_times(\"a\",\"aa\");\n\tassert(result==0);\n\tresult", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"\",\"a\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"a\");\n\tassert(result==1);\n\tresult = how_many_times(\"a\",\"aa\");\n\tassert(result==0);\n\tresult", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"\",\"a\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"a\");\n\tassert(result==1);\n\tresult = how_many_times(\"a\",\"aa\");\n\tassert(result==0);\n\tresult", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"\",\"a\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"\");\n\tassert(result==0);\n\tresult = how_many_times(\"a\",\"a\");\n\tassert(result==1);\n\tresult = how_many_times(\"a\",\"aa\");\n\tassert(result==0);\n\tresult", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"o\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abracadabra\",\"abra\"\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tauto result = Solution().findMedianSortedArrays(vector<int>{1,3},vector<int>{2});\n\tassert(result==2);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"o\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": false}
{"task_id": "CPP/18", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\nint main(){\n\tauto result = how_many_times(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello world\",\"world\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint how_many_times(string str,string substring){\n    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0", "fn": "how_many_times", "para": "(string str,string substring)", "type": "int", "pass": true}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"fourone ninethree\");\n\tassert(result==\"onefourthree nine\");\n\tresult = sort_numbers(\"onetwothreefourfivesix\");\n\tassert(result==\"onetwothreefourfivesix\");\n\tresult = sort_numbers(\"zeroonetwothreefourfivesix\"t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"fourone ninethree\");\n\tassert(result==\"onethreefournine\");\n\tresult = sort_numbers(\"onetwothreefourfivesix\");\n\tassert(result==\"onetwothreefourfivesix\");\n\tresult = sort_numbers(\"zeroonetwothreefourfivesix\"t(result==1);\n}/C++/1000000000000000000", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"fourone ninethree\");\n\tassert(result==\"onefourthree nine\");\n\tresult = sort_numbers(\"onetwothreefourfivesix\");\n\tassert(result==\"onetwothreefourfivesix\");\n\tresult = sort_numbers(\"zeroonetwothreefourfivesix\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"fourone ninethree\");\n\tassert(result==\"onethreefournine\");\n\tresult = sort_numbers(\"onetwothreefourfivesix\");\n\tassert(result==\"onetwothreefourfivesix\");\n\tresult = sort_numbers(\"zeroonetwothreefourfivesix\"t(result==1);\n}/codewars/7kyu/sum_of_digits_digital_root.cpp\n#", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zeroonetwothreefourfivesix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"fourone ninethree\");\n\tassert(result==\"onefourthree nine\");\n\tresult = sort_numbers(\"onetwothreefourfivesix\");\n\tassert(result==\"onetwothreefourfivesix\");\n\tresult = sort_numbers(\"zeroonetwothreefourfivesix\"t(result==1);\n\tresult = is_prime(10000000000000000", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"four six two three eight five seven one nine\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_letter(string chars){\n    map<char,int> toint={{'a',1},{'b',2", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"four six two three eight five seven one nine zero\" 0;\n}#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> a(n),b(m);\n    for (int i=0;i<n;i++)\n        cin>>a[i];\n    for (int i", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"four six two three eight five seven one nine zero\"t(result==1);\n}/C++/100000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"four six two three eight five seven one nine zero\"  }\n    return out;\n}\nint main(){\n\tauto result = find_outlier(vector<int>{2, 4, 6, 8, 10, 3});\n\tassert(result==3);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"zerofourfiveseveneightnine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"four six two three eight five seven one nine\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"threefivenine\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five five", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"zero nine five two\");\n\tassert(result==\"five two nine zero\");\n\tresult = sort_numbers(\"four six two three eight one nine\");\n\tassert(result==\"one two three four six eight nine\");\n\tresult = sort_numbers(\"nine five two\");\n\tassert(result==\"five two nine\");\n\tresult = sort_numbers(\"zero\");\n\tassert(result==\"zero\");\n\tresult = sort_numbers", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"zero nine five two\");\n\tassert(result==\"five two nine zero\");\n\tresult = sort_numbers(\"four six two three eight one nine\");\n\tassert(result==\"one two three four six eight nine\");\n\tresult = sort_numbers(\"nine five two\");\n\tassert(result==\"five two nine\");\n\tresult = sort_numbers(\"zero\");\n\tassert(result==\"zero\");\n\tresult = sort_numbers", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"zero nine five two\");\n\tassert(result==\"five two nine zero\");\n\tresult = sort_numbers(\"four six two three eight one nine\");\n\tassert(result==\"one two three four six eight nine\");\n\tresult = sort_numbers(\"nine five two\");\n\tassert(result==\"five two nine\");\n\tresult = sort_numbers(\"zero\");\n\tassert(result==\"zero\");\n\tresult = sort_numbers", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"zero nine five two\");\n\tassert(result==\"five two nine zero\");\n\tresult = sort_numbers(\"four six two three eight one nine\");\n\tassert(result==\"one two three four six eight nine\");\n\tresult = sort_numbers(\"nine five two\");\n\tassert(result==\"five two nine\");\n\tresult = sort_numbers(\"zero\");\n\tassert(result==\"zero\");\n\tresult = sort_numbers", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"zero nine five two\");\n\tassert(result==\"five two nine zero\");\n\tresult = sort_numbers(\"four six two three eight one nine\");\n\tassert(result==\"one two three four six eight nine\");\n\tresult = sort_numbers(\"nine five two\");\n\tassert(result==\"five two nine\");\n\tresult = sort_numbers(\"zero\");\n\tassert(result==\"zero\");\n\tresult = sort_numbers", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three four six five\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_letter(string chars){\n    int out=0;\n    for (int i=0;i<chars.length();i++)\n        if (", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three four six five\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three four six five\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_letter(string letters){\n    int out=0;\n    for (int i=0;i<letters.length();i++)\n        if (", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three four six five\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_letter(string chars){\n    int out=0;\n    for (int i=0;i<chars.length();i++)\n        if (", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/19", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = sort_numbers(<FILL_ME>);\n\tassert(result==\"three\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three three", "fn": "sort_numbers", "para": "(string numbers)", "type": "string", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.1, 1.9, -4.0, 10.7, 0.5, 1.4, 3.6});\n\tassert(issame(result,{1.4,1.6}));\n\tresult = find_closest_elements({-3.7, -5.5, -7.3, -9.1, -10.9});\n\tassert(issame", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.1, 1.9, -4.0, 10.7, 0.5, 1.4, 3.6});\n\tassert(issame(result,{1.4,1.6}));\n\tresult = find_closest_elements({3.1, 2.7, 3.3, 1.9, 1.1, 1.5});\n\tassert", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.1, 1.9, -4.0, 10.7, 0.5, 1.4, 3.6});\n\tassert(issame(result,{1.4,1.6}));\n\tresult = find_closest_elements({-3.7, -5.5, -7.3, -9.1, -10.9});\n\tassert(issame", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.1, 1.9, -4.0, 10.7, 0.5, 1.4, 3.6, -8.8});\n\tassert(issame(result,{1.4,1.6}));\n\tresult = find_closest_elements({-3.7, -5.5, -7.3, -9.1, -2.7, 4", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{3.9,4.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.1, 1.9, -4.0, 10.7, 0.5, 1.4, 3.6, -8.8});\n\tassert(issame(result,{1.4,1.6}));\n\tresult = find_closest_elements({-3.7, -5.5, -7.3, -9.1, -2.7, 4", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 3.3, 5.5, 7.7, 9.9});\n\tassert(issame(result,{3.3,5.5}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.1});\n\tassert(issame(result,{1.0,2.1}));\n\tresult = find_closest_elements({-", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 3.3, 5.5, 7.7, 9.9});\n\tassert(issame(result,{3.3,5.5}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.1});\n\tassert(issame(result,{1.0,2.1}));\n\tresult = find_closest_elements({-", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 3.3, 5.5, 7.7, 9.9});\n\tassert(issame(result,{3.3,5.5}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.1});\n\tassert(issame(result,{1.0,2.1}));\n\tresult = find_closest_elements({-", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 3.3, 5.5, 7.7, 9.9});\n\tassert(issame(result,{3.3,5.5}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.0, 4.0});\n\tassert(issame(result,{1.0,2.0}));\n\tresult = find_", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{5.0,5.9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 3.3, 5.5, 7.7, 9.9});\n\tassert(issame(result,{3.3,5.5}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.1});\n\tassert(issame(result,{1.0,2.1}));\n\tresult = find_closest_elements({-", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.2, -1.1, -0.5, -0.2, 0.2, 0.9, 1.1, 2.1});\n\tassert(issame(result,{0.2,0.9}));\n\tresult = find_closest_elements({-3.0, -2.0, -1.0, 1.0, 2.0, 10", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.2, -2.8, -1.1, -0.3, -2.9, 4.4, 1.4, 3.6, -4.5, -0.8, -0.1, -4.5, 4.9, 1.0, 2.2, 0.2, -4.4, 4.6, 3.4});", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.2, -2.8, -1.1, -0.5, -4.3, 3.9});\n\tassert(issame(result,{1.6,-1.1}));\n\tresult = find_closest_elements({-3.0, -1.9, 4.0, 1.0, -2.0, 3.9});\n\tassert(issame(result", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.2, -2.8, -4.0, -1.9, 0.2, 2.4, 2.9, 2.8, 3.3});\n\tassert(issame(result,{2.8,2.9}));\n\tresult = find_closest_elements({-3.7, -5.5, -7.3, -9.1, -3.", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.6, -2.2, -2.72, -4.0, 3.1, 0.0, 2.2, 2.0});\n\tassert(issame(result,{1.6,2.0}));\n\tresult = find_closest_elements({-3.0, -1.0, 1.0, 2.0, 5.0, 5.0, 5", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});\n\tassert(issame(result,{2.2,2.4}));\n\tresult = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});\n\tassert(issame(result,{1.1,2.2}));\n\tresult = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});\n\tassert(issame(result,{2.2,2.4}));\n\tresult = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});\n\tassert(issame(result,{2.2,2.4}));\n\tresult = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.0,2.2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9});\n\tassert(issame(result,{2.2,2.4}));\n\tresult = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9});\n\tassert(issame(result,{3.3,4.4}));\n\tresult = find_closest_elements({1.1, 2.2, 3.3, 4.4, 5.5, 6.6", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9}t> result = find_closest_elements({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9}, 3);\n\tassert(issame(result,{1.", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9});\n\tassert(issame(result,{2.2,3.3}));\n\tresult = find_closest_elements({1.1, 2.2, 3.3, 4.4, 5.5, 6.6", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9});\n\tassert(issame(result,{3.3,4.4}));\n\tresult = find_closest_elements({1.1, 2.2, 3.3, 4.4, 5.5, 6.6", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/20", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> find_closest_elements(vector<float> numbers){\n    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\nint main(){\n\tauto result = find_closest_elements(<FILL_ME>);\n\tassert(issame(result,{2.2,3.1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9});\n\tassert(issame(result,{3.3,4.4}));\n\tresult = find_closest_elements({1.1, 2.2, 3.3, 4.4, 5.5, 6.6", "fn": "find_closest_elements", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result,{1,2,3,4,5});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){ \n    for (int i=", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){ \n   ", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": true}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}  }\n    return 0;\n}/week1/1.cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> a(n);\n    for (int i=0;i<n;i++)\n        cin>>a[i", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){ \n   ", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": true}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,0.25,0.5,0.75,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result,{1,2,3,4,5});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){ \n    int temp;\n    for", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result,10);\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> shift_", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0};\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse(vector<int> numbers){ \n   ", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}  }\n    return result;\n}\nint main(){\n\tauto result = find_all_factors(10);\n\tassert(issame(result,{1,2,5,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.25,0.0,1.0,0.5,0.75}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_list(vector<int> numbers){ \n    sort(numbers.begin(),numbers.", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}  }\n    return 0;\n}/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    while(scanf(\"%d\",&n)!=EOF){\n        int a[100000];", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n\t", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": true}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}t> numbers){\n    float sum=0;\n    for (int i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    return sum/numbers.size();\n}\nint main(){\n\tauto result = mean({1.0,2.0});\n\tassert(result==1.5);\n}/mean.cpp\n#include<stdio.h>\n", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{0.0,1.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}t(result,10);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}t> numbers){\n    float sum=0;\n    for (int i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    return sum/numbers.size();\n}\nint main(){\n\tauto result = mean({1.0,2.0});\n\tassert(result==1.5);\n}#include<stdio.h>\n#include<math.", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){ \n   ", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tauto result = find_all_factors(10);\n\tassert(issame(result,{1,2,5,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0});\n\tassert(issame(result,{0.0,0.2,0.4,0.6,0.8}));\n\tresult = rescale_to_unit({-1.0,2.0,3.0,4.0,5.0});\n\tassert(issame(result,{0.0,0.2,0", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/21", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> rescale_to_unit(vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\nint main(){\n\tauto result = rescale_to_unit(<FILL_ME>);\n\tassert(issame(result,{1.0,0.0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0,2.0}  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b)!=EOF){", "fn": "rescale_to_unit", "para": "(vector<float> numbers)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,\"hello\",3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,\"hello\",3,4,5,6,7,8,9,10,11,12,13,14,15", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,\"4\",5,\"6\",7,8,9});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n\tresult = filter_integers({1,2,3,\"4\",5,\"6\",7,8,9,\"10\"}t_any> list_any;\nusing namespace std;\n#include<algorithm>\n#", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,\"three\",4,9,\"six\"});\n\tassert(issame(result,{1,2,4,9}));\n\tresult = filter_integers({1,2,\"three\",4,9,\"six\"}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/test/test_range.cpp\n#include<stdio.h>", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,\"4\",5,\"6\",7,8,\"9\"}t_any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{4,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,\"hello\",4,9});\n\tassert(issame(result,{1,2,3,4,9}));\n\tresult = filter_integers({1,2,3,\"hello\",4,9,\"world\"});\n\tassert(issame(result,{1,2,3,4,9}));\n\tresult = filter_integers({1,2,3,\"hello\",4,9,\"world\",10}", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,3,4,5,6,7,8,9,10,\"a\",\"b\",\"c\"});\n\tassert(issame(result,{1,2", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,3,4,5,6,7,8,9,10,\"a\",\"b\",\"c\"});\n\tassert(issame(result,{1,2", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,3,4,5,6,7,8,9,10,\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,3,4,5,6,7,8,9,10,\"a\",\"b\",\"c\"});\n\tassert(issame(result,{1,2", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,\"a\",\"b\",4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = filter_integers({1,2,3,\"a\",\"b\",4,5,6.0});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = filter_integers({1,2,3,\"a\",\"b\",4", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,\"three\",3,4,5,\"six\"}t_any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({\"a\",1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({\"a\",1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,\"three\",3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = filter_integers({1,2,\"three\",3,4,5,6,\"seven\",8,9});\n\tassert(issame(result,{1,2,3,4,5,6,8,9}));\n\tresult = filter_integers({1,2,\"", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/22", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> filter_integers(list_any values){\n    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\nint main(){\n\tauto result = filter_integers(<FILL_ME>);\n\tassert(issame(result,{3,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = filter_integers({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,", "fn": "filter_integers", "para": "(list_any values)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strncmp(string str1,string str2,int n){\n    int i=0;\n    for(;i<n;i++){\n        if", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint myAtoi(string str){\n    int result = 0;\n    int sign = 1;\n    int i = 0;\n    while(str[", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123456789", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123456789", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint myAtoi(string str){\n    int result=0;\n    int i=0;\n    int sign=1;\n    while(str[i]==' '){", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findMedianSortedArrays(nums,nums);\n\tassert(result==5.5);\n}#include<stdio.h>\n#include<math", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strcmp(string str1,string str2){\n    if(str1.length()!=str2.length())\n        return str1.length()-str2.length();\n    for(int i=0;", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"1234567890\");\n\tassert(result", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strncmp(string str1,string str2,int n){\n    int len1 = str1.length();\n    int len2 = str2.length();\n    int minlen = min(len1,", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"a\");\n\tassert(result==1);\n}#include<", "fn": "strlen", "para": "(string str)", "type": "int", "pass": true}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123\");\n\tassert(result==1);", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123\");\n\tassert(result==3);", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123\");\n\tasser\n\tassert(result==1", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123\");\n\tassert(result==3);", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/23", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint strlen(string str){\n    return str.length();\n}\nint main(){\n\tauto result = strlen(\"123\");\n\tassert(result==3);", "fn": "strlen", "para": "(string str)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\nint main(){\n\tauto result = count", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  false;", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "14t(result==1);\n}/test/test_largest_divisor.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  0;", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2;i*i<=n;i++)\n        if (", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  0;", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  0", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==1);\n}/test/test_largest_divisor.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  0;", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        n=n&(n-1);\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return 0;\n    return ", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\nint main(){\n\tauto result", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "50\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  0;\n   ", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "50\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return 0;\n   ", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "50\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2;i*i<=n;i++)\n        if (n", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/24", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_divisor(int n){\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\nint main(){\n\tauto result = largest_divisor(<FILL_ME>);\n\tassert(result==50);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "50;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\nint main(){\n\tauto result =", "fn": "largest_divisor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108);\n\tassert(issame(result,{2,2,3,3,17}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108);\n\tassert(issame(result,{2,2,3,3,17}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    for (", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108);\n\tassert(issame(result,{2,2,3,3,17}));\n\tresult = factorize(1000000000000000000;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108);\n\tassert(issame(result,{2,2,3,3,17}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6);\n\tassert(issame(result,{2,3}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(15);\n\tassert(issame(result,{3,5}));\n\tresult = factorize(100t(issame(result,{1,2,3}));\n\tresult = merge({1,2,3", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6);\n\tassert(issame(result,{2,3}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(15);\n\tassert(issame(result,{3,5}));\n\tresult = factorize(100\n\tassert(issame(result,{1,2,3,4,5,6,7,8", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6);\n\tassert(issame(result,{2,3}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(1000000000;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = range(10,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6);\n\tassert(issame(result,{2,3}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(1000000000t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6);\n\tassert(issame(result,{2,3}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(18);\n\tassert(issame(result,{2,3,3}));\n\tresult = factorize(24);\n\tassert(issame(result,{2,2,2,3}));\n\tresult = factorize(3", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "24);\n\tassert(issame(result,{2,2,2,3}));\n\tresult = factorize(100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "24);\n\tassert(issame(result,{2,2,2,3}));\n\tresult = factorize(100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000000000000;\n\tassert(issame(result,{1,2,3,4,5,6,7,8", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "24);\n\tassert(issame(result,{2,2,2,3}));\n\tresult = factorize(100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000000000000t(result,{1,2,3,4,5,6,7,8,9,10,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "198);\n\tassert(issame(result,{2,3,19}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "198);\n\tassert(issame(result,{2,3,19}));\n\tresult = factorize(1980);\n\tassert(issame(result,{2,3,5,19}));\n\tresult = factorize(19800);\n\tassert(issame(result,{2,3,5,20}));\n\tresult = factorize(198000);\n\tassert(iss", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "198);\n\tassert(issame(result,{2,3,19}));\n\tresult = factorize(1980);\n\tassert(issame(result,{2,3,5,19}));\n\tresult = factorize(19800);\n\tassert(issame(result,{2,3,5,23}));\n\tresult = factorize(198000);\n\tassert(iss", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "198);\n\tassert(issame(result,{2,3,3,19}));\n\tresult = factorize(12);\n\tassert(issame(result,{2,2,3}));\n\tresult = factorize(1000000000000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "198);\n\tassert(issame(result,{2,3,3,19}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000);\n\tassert(issame(result,{2,2,2,5,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,5,5,5", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100);\n\tassert(issame(result,{2,2,5,5}));\n\tresult = factorize(1000000000);\n\tassert(issame(result,{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "19*19*19;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int>", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "19*19*19t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "19*19*19\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "19*19*19t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "19*19*19t>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = factorize(19*19*19);\n\tassert(issame(result,{3,19,19,19}));\n}/factorize.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    for", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/25", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> factorize(int n){\n    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\nint main(){\n\tauto result = factorize(<FILL_ME>);\n\tassert(issame(result,{3,3,3,19,19,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "108  }\n    return 0;\n}/2019/10/10/10.cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>", "fn": "factorize", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,1,1,1,1", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5});\n\tassert(issame(result,{1,2", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5});\n\tassert(issame(result,{1,2", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,1,1,1,1,1,1});\n\tassert(issame(result,{1}));\n\tresult = remove_duplicates({1,2,3,4,5,6,7", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,1,1,1,1,1,1});\n\tassert(issame(result,{1}));\n\tresult = remove_duplicates({1,2,3,4,5});\n\tassert", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = remove_duplicates({1,1,1,1,1,1,1,1,1,1});\n\tassert(issame(result,{1}));\n\tresult = remove_duplicates({1,1,1,1,1,1,1", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,3,3,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13,13,14,14,14,15,15,15,16,", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5}\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n   ", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,4,3,2,1}t> out={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(out.begin(),out.end(),numbers[i])==out.end())\n            out.push_back(numbers[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = remove_duplicates({1,2", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/26", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> remove_duplicates(vector<int> numbers){\n    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\nint main(){\n\tauto result = remove_duplicates(<FILL_ME>);\n\tassert(issame(result,{1,2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,1,2,2,3,3,4,4,5,5}\n\tassert(issame(result,{1,2,3,4}));\n}/leetcode/remove_duplicates_from_sorted_array.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n", "fn": "remove_duplicates", "para": "(vector<int> numbers)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"TheSeViOlEnTDeLiGtShAvEViOlEnTEnDs\") ;\n\tprintf(\"%s\\n\",result.c_str()\n\tassert(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"TheSeViOlEnTDeLiGtShAvEViOlEnTEnDs\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"TheSeViOlEnTDeLiGtShAvEViOlEnTEnDs\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"TheSeViOlEnTDeLiGtShAvEViOlEnTEnDs\") ;\n\tprintf(\"%s\\n\",result.c_str();\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int num){\n   ", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"tHESEVIOLENTDELIGHTSHAVEVIOLENTENDS\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"TheSeViOlEnTDeLiGtShAvEViOlEnTEnDs\") ;\n\tprintf(\"%s\\n\",result.c_str()\n\tassert(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": true}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!\"  }\n    return out;\n}\nint main(){\n\tauto result = reverse_string(\"Hello!\");\n\tassert(result==\"!olleH\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring reverse_string(string str){\n    string out=\"\";\n    for (int", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": true}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"hELLO!\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": true}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"  }\n    return out;\n}\nint main(){\n\tauto result = reverse_string(\"hello\");\n\tassert(result==\"olleh\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring reverse_string(string str){\n    string out=\"\";\n    for (int i=str", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"t(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"  }\n    return out;\n}\nint main(){\n\tauto result = reverse_string(\"hello\");\n\tassert(result==\"olleh\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring reverse_string(string str){\n    string out=\"\";\n    for (int i=str", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n       ", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": false}
{"task_id": "CPP/27", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring filp_case(string str){\n    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = filp_case(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if", "fn": "filp_case", "para": "(string str)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"xyz\",\"wk\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1t(result==1);\n}#include<stdio.h>\n#include<", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"yz\",\"w\",\"k\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tassert(result==1);\n\tresult = 2;\n\tassert(", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"yz\",\"w\",\"k\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tint x = 1;\n\tint y = 2;\n\tint", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"yz\",\"w\",\"k\"}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count++;\n    }", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyzwk\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"xyz\",\"wk\"}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"y\",\"z\"}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"y\",\"z\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tassert(result==1);\n\tresult = 2;\n\tassert(result==", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"y\",\"z\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tfor (int i=0;i<1000;i++)\n\t\tresult", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"y\",\"z\"}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tassert(result==1);\n\tresult = 2;t(result", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"xyz\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"x\",\"y\",\"z\"}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1t.push_back(1);\n\tassert(result==1);\n}#include<", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<string>{\"\", \"\"});\n\tassert(result==\"\");\n\tresult = concatenate(vector<string>{\"a\", \"b\"});\n\tassert(result==\"ab\");\n\tresult = concatenate(vector<string>{\"a\", \"b\", \"c\"});\n\tassert(result==\"abc\");\n\tresult = concatenate(vector<string>{\"a\", \"b\", \"c\", \"d\"});\n\tassert(result==\"abcd\");\n\tresult =", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"\"}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int number){\n    int count=0;\n    while (number>0){\n        number/=10;\n        count++;\n    }\n    return count;\n}", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<string>{\"\", \"\"});\n\tassert(result==\"\");\n\tresult = concatenate(vector<string>{\"a\", \"b\"});\n\tassert(result==\"ab\");\n\tresult = concatenate(vector<string>{\"a\", \"b\", \"c\"});\n\tassert(result==\"abc\");\n\tresult = concatenate(vector<string>{\"a\", \"b\", \"c\", \"d\"});\n\tassert(result==\"abcd\");\n\tresult =", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": true}
{"task_id": "CPP/28", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring concatenate(vector<string> strings){\n    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\nint main(){\n\tauto result = concatenate(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"\"} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "concatenate", "para": "(vector<string> strings)", "type": "string", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"\n\tassert(issame(result,{\"123\",\"123456789\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_length(vector", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"t(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"t(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"xxx\",\"xxxAAA\",\"xxx\"}, \"xxx\"t(result,{\"xxx\",\"xxxAAA\",\"xxx\"}));\n}/test/test_filter_by_prefix.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_prefix({\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}, \"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = filter_by_prefix({\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"ab\",\"abc\",\"abcd\",\"abcde\",\"abcdef\",\"abcdefg\"}, \"abc\");\n\tassert(issame(result,{\"abc\",\"abcd\",\"abcde\",\"abcdef\",\"abcdefg\"}));\n\tresult = filter_by_prefix({\"a\",\"ab\",\"abc\",\"abcd\",\"abcde\",\"abcdef\",\"abcdefg\"}, \"ab\");\n\tassert(issame(result,{\"ab\",\"abcd\",\"abcde\",\"abcdef\",\"abcdefg\"}));\n\tresult = filter", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}, \"a\");\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/29", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\nint main(){\n\tauto result = filter_by_prefix(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}, \"a\");\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"", "fn": "filter_by_prefix", "para": "(vector<string> strings, string prefix)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,-4,-5,-6}t(result,10);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,-4,-5,-6};\n\tassert(issame(result,{1,2,3,4,5,6}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> get_positive(vector<int> l){\n    vector<int", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,-4,-5,-6} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> a(n);\n\tfor (int i=0;i<", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,-4,-5,-6}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> get_even(vector<int> l){\n   ", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{4,5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,-4,-5,-6}t(result,10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_sum(int a,int b){\n    return a+b;\n}\nint main(){", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,3,3,9,123,1});\n\tassert(issame(result,{5,3,3,9,123}));\n\tresult = get_positive({-5,3,2,3,3,9,123,1}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": true}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,3,3,9,123,1});\n\tassert(issame(result,{5,3,3,9,123}));\n\tresult = get_positive({-5,3,2,3,3,9,123,1});\n\tassert(issame(result,{3,3,9,123}));\n\tresult = get_positive({5,3,2,", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": true}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{5,3,2,3,3,9,123,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = get_positive({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{1,2,3,4,5", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = get_positive({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{}));\n\tresult = get_positive", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = get_positive({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{1,2,3,4,5", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = get_positive({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0}));\n\tresult = get_positive", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/30", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> get_positive(vector<float> l){\n    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\nint main(){\n\tauto result = get_positive(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = get_positive({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{1,2,3,4,5", "fn": "get_positive", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/31", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(long long n){\n    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = is_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_prime", "para": "(long long n)", "type": "bool", "pass": false}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,9,4,8,3,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,9,4,8,3,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,9,4,8,3,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,9,4,8,3,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,9,4,8,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,9,4,8,3,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})t> l={1,2,3,4,5,6,7,8,9};\n\tauto result = sort_third(l);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,2", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/sort_even_odd.cpp\n#include<stdio.h>\n#include<math.h>\n#include<", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,2", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5,1});\n\tassert(issame(result,{2,3,4,5,6,8,9,1})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5,1}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/sort_even_odd.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5,1}t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}/sort_even_odd.cpp\n#include<stdio.h>\n#include<math.", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5,1});\n\tassert(issame(result,{2,3,4,5,6,8,9,1}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,6,3,4,8,9,5,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,6,3,4,8,9,5,1};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_even_", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,4,7,2,5,8,3,6,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,4,7,2,5,8,3,6,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(issame(result,{1,4,7,10,13,16,19,2,5,8,11,14,17,3,6,9,", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,4,7,2,5,8,3,6,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,4,7,2,5,8,3,6,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,8,3,4,6,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,2", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,8,3,4,6,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,8,3,4,6,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,2", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,8,3,4,6,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9}));\n\tresult = sort_third({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/33", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\nint main(){\n\tauto result = sort_third(<FILL_ME>);\n\tassert(issame(result,{2,8,3,4,6,9,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,8,3,4,6,9,5});\n\tassert(issame(result,{2,3,4,5,6,8,9})  return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = sort_", "fn": "sort_third", "para": "(vector<int> l)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/34", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "fn": "unique", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/34", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "fn": "unique", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/34", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,5,9,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,1", "fn": "unique", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/34", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "fn": "unique", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/34", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique(vector<int> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique(<FILL_ME>);\n\tassert(issame(result,{0,2,3,5,9,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "fn": "unique", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-124)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3}\n\tassert(abs(result-3)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3}t(result-3)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3}\n\tassert(abs(result-3)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3}\n\tassert(abs(result-3)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=l[0];\n  for (int i=1;i", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/35", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\nint main(){\n\tauto result = max_element(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3}\n\tassert(abs(result-3)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (int i=0", "fn": "max_element", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n   ", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==639);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int reverse(long long int n){\n    long", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int reverse(long long int n){\n    long", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==8026);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    if (n%i==0) return 0;\n    return 1;", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==8026);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    if (n%i==0) return 0;\n    return 1;", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==6);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==6);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int find_max_num(long long int", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==192);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==192);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    if (n%i==0) return 0;\n    return 1;", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int reverse_integer(long long int n){", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==3);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n   ", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==2);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100  }\n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(100);\n\tassert(result==2);\n}/fizz_buzz.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int reverse(long long int x", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/36", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\nint main(){\n\tauto result = fizz_buzz(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%", "fn": "fizz_buzz", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-10,3,-5,2,-3,3,5,0,9,1,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t> out={};\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(l[i]);\n        if (i%2==1) out.push_back(l[i]*2);\n    }\n    return out;\n}\nint main(){", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}  }\n    return out;\n}\nint main(){\n\tauto result = sort_even({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,2,4,6,8,10}));\n}", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}/sort_even.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{-12,8,3,4,5,2,12,11,23,-10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t> l){\n    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = sort_list({1,2,3,", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,3,5,2,4,6}t> out={};\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(l[i]);\n        if (i%2==1) out.push_back(l[i+1]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even({", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,3,5,2,4,6}t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,4,6,8,10,1,3,5,7,9}));\n\tresult = sort_even({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,3,5,6,4,2});\n\tassert(issame(result,{1,3,5,4,6,2}));\n\tresult = sort_even({-2,4,-6,1,5,0,-3});\n\tassert(issame(result,{-6,-3,0,1,4,5}));\n\tresult = sort_even({1,2,3,4,5,6,7", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/37", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\nint main(){\n\tauto result = sort_even(<FILL_ME>);\n\tassert(issame(result,{1,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}  }\n    return out;\n}\nint main(){\n\tauto result = sort_even({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>", "fn": "sort_even", "para": "(vector<float> l)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n/2019/2019.10.14/B.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n\tauto result", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count+=1;\n    }\n    return count;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==233);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000007;\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0;i<n;i++) cin>>a[i];\n\tint m;\n\tcin>>m;\n\tint b[m];\n\tfor (int i=0;i<m;i++) cin>>b[i];\n\tint c[n+", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        int m=a", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count+=1;\n    }\n    return count;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;i*", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    while (scanf(\"%d\",&n)!=EOF)\n    {\n        int a[n];\n        for (int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n        sort(a", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}/problem_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_primes(int n){\n    int sum=0;\n    for (int i=2;i<n;i++)\n    {\n        bool isprime=true;\n       ", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_divisors(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (n%i==0)", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}/src/problem_001.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (i%3==0", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==433494437);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count+=1;\n    }\n    return count;\n}\nint main(){\n", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}/cpp/problem_16.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==514229);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}/ProjectEuler/ProjectEuler/p10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    long long sum=0;\n    for (int i=2;i<2000000;i++)\n    {\n        bool isprime=true;", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}/cpp/problem_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_primes(int n){\n    int sum=0;\n    for (int i=2;i<n;i++)\n    {\n        bool isprime=true", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int power(int a,int b){\n   ", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}/src/problem_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_primes(int n){\n    int sum=0;\n    for (int i=2;i<n;i++)\n    {\n        bool isprime=true;", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_div(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (n%i==0) sum+=i;\n   ", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==28657);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = ", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count+=1;\n    }\n    return count;\n}\nint main(){\n\tauto result =", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n   ", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000007;\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        if (", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return 0;\n    return 1;", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n/=2;\n    }\n    return count;\n}\nint main(){\n\tauto", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count+=1;\n    }\n    return count;\n}\nint main(){\n\t", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){\n", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}/cpp/problem_16.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_divisors(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (n%i==0) sum+=i", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}/cpp/problem_001.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (i%3==", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==1597);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result =#include<", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum;\n}\nint main(){", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/39", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint prime_fib(int n){\n    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\nint main(){\n\tauto result = prime_fib(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    while (scanf(\"%d\",&n)!=EOF)\n    {\n        int sum=0;\n        for (int i=1;i<=n;i", "fn": "prime_fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,-5};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1;i<=sqrt(n);i++)\n       ", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,-5}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1;i<=sqrt(n);i++)\n        if", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": true}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1;i", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1;i", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i=2", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_max_subarray_sum.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray_sum(vector<int", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/40", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool triples_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = triples_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i=2", "fn": "triples_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int arr[]){\n    sort(arr,arr+2);\n    return arr[0]+arr[1];\n}\nint main(){\n\tauto result = sum_", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int arr[]){\n    int min1 = 1000000000;\n    int min2 = 100000000", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    while(n>0){\n        int digit = n%10;\n        if(digit==7){\n            count++;\n        }\n        n/=10;", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int n1, int n2, int n3){\n    int arr[3] = {n1,n2,n3};\n    sort(arr,arr+", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int n1, int n2, int n3){\n    int arr[3] = {n1,n2,n3};\n    sort(arr,", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int n1,int n2,int n3){\n    int arr[3]={n1,n2,n3};\n    sort(arr,arr", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==100);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(10);\n\tassert(result==10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==100);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(10);\n\tassert(result==10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==100);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==100);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(10);\n\tassert(result==10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_two_lowest_positive_integers(int n1, int n2, int n3){\n    int arr[3] = {n1,n2,n3};\n    sort(arr,arr", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    while(n>0){\n        if(n%10==7){\n            count++;\n        }\n        n/=10;\n    }\n    return count;", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=10", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n   ", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_sheep(int n){\n    int count = 0;\n    for(int i=0;i<n;i++){\n        if(n%10!=0){\n            count++;\n        }\n        n/=1", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n   ", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/41", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint car_race_collision(int n){\n    return n*n;\n}\nint main(){\n\tauto result = car_race_collision(<FILL_ME>);\n\tassert(result==64);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "car_race_collision", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{6,3,6,3,4,4,10,1,124}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3});\n\tassert(issame(result,{2,3,4})\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3};\n\tassert(issame(result,{}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> square_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3});\n\tassert(issame(result,{2,3,4});\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n   ", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3});\n\tassert(issame(result,{2,3,4})\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3});\n\tassert(issame(result,{2,3,4})\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2,7,11,15},9);\n\tassert(issame(result,{0,1}));\n}#include<stdio.h>\n#", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3}t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_list(vector<int> l){\n    int sum=0;\n    for (int i=0;i<l.size();i++)\n        sum+=l[i", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3}\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n       ", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2,7,11,15},9);\n\tassert(issame(result,{0,1}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3}\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n       ", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/42", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\nint main(){\n\tauto result = incr_list(<FILL_ME>);\n\tassert(issame(result,{4,3,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3}\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> incr_list(vector<int> l){\n    for (int i=0;i<l.size();i++)\n       ", "fn": "incr_list", "para": "(vector<int> l)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t_sum(l);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_sum(vector<int> l){\n    int sum=0", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t_sum(l);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_sum(vector<int> l){\n    int sum=0", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_consecutive_ones(vector<int> l){\n    int max_count=0;\n   ", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_number(vector<int> l){\n    int sum=0;\n    for (int", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_pairs(vector<int> l){\n    int count=0;\n    for (int i=0;", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_pairs(vector<int> l){\n    int count=0;\n    for (int i=", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": true}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_pairs(vector<int> l){\n    int count=0;\n    for (int i=0;", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_pairs(vector<int> l){\n    int count=0;\n    for (int i", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": false}
{"task_id": "CPP/43", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool pairs_sum_to_zero(vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\nint main(){\n\tauto result = pairs_sum_to_zero(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_pairs(vector<int> l){\n    int count=0;\n    for (int i=", "fn": "pairs_sum_to_zero", "para": "(vector<int> l)", "type": "bool", "pass": true}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "22,10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "22,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": true}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "22,10\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int out=0;\n    for (int i = 0; i < nums", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": true}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<unordered_set>\n#include<unordered_map>\n#include<set>\n#include<map>\n#include<", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"22\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(10,2);\n\tassert(result==\"1010\");\n}/src/change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10000,2\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10000,2;\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10000,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1t(result==1);\n}#include<stdio.h>\n#include<math.h>", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10000,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(10000,2);\n\tassert(result==\"10000\");\n}/src/change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"10000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10000,2\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(10,2);\n\tassert(result==\"111\");\n}/src/change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tasser\n\tassert(result==1);\n}/test/test", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1000000000000000000000000000000", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(10,2);\n\tassert(result==\"111\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000,2\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tassert(result==1);\n}/test/", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000,2\n\tassert(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1000;\n\tassert(result==1);\n", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000,2\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> in={1,2,3,4,5,6,7,8,9};\n\tauto out=s.spiralOrder(in);\n\tfor(auto i:out){\n\t\tcout<<i<<\" \";\n\t}\n\tcout<<endl;\n}", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tfor(int i=1;i<=100;i++){\n\t\tresult*=i;\n\t}", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"1000\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000,2t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = __builtin_popcount(1);\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> in={1,2,3,4,5,6,7,8,9};\n\tauto out=s.spiralOrder(in);\n\tfor(auto i:out){\n\t\tcout<<i<<endl;\n\t}\n}#include<iostream>", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(100,2);\n\tassert(result==\"1100100\");\n}/test/test_change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(100,2);\n\tassert(result==\"100\");\n}/test/test_change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}/test/test_", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}/1001.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint n;\n\twhile(cin", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tint a = 1;\n\tint b = 2;\n\tint c = 3;\n\tint d = ", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2  }\n    return out;\n}\nint main(){\n\tauto result = change_base(10,2);\n\tassert(result==\"1010\");\n}/src/change_base.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,2 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/44", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring change_base(int x,int base){\n    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\nint main(){\n\tauto result = change_base(<FILL_ME>);\n\tassert(result==\"11101010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n", "fn": "change_base", "para": "(int x,int base)", "type": "string", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4\n\tassert(abs(result-1.5)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(s-a)*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2\n\tassert(abs(result-1.5)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(s-a)*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4\n\tassert(abs(result-1.5)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(s-a)*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2\n\tassert(abs(result-1.5)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(s-a)*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-7.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4\n\tassert(abs(result-1.5)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(s-a)*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3.0,2.0\n\tassert(abs(result-2.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3.0,4.0\n\tassert(abs(result-2.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3.0,4.0\n\tassert(abs(result-2.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3.0,4.0\n\tassert(abs(result-2.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-2.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3.0,2.0\n\tassert(abs(result-2.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt(s*(", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10.0,20.0\n\tassert(abs(result-10.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10.0,20.0\n\tassert(abs(result-10.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10.0,20.0\n\tassert(abs(result-10.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\nfloat s = (a+b+c)*0.5;\nreturn sqrt", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10.0,10.0\n\tassert(abs(result-1.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat square_area(float a){\nreturn a*a;\n\n}\nint main(){\n\tauto result = square_area(10.", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/45", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float h){\nreturn (a*h)*0.5;\n\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-40.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10.0,20.0\n\tassert(abs(result-10.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat square_area(float a){\nreturn a*a;\n\n}\nint main(){\n\tauto result = square_area(10", "fn": "triangle_area", "para": "(float a,float h)", "type": "float", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==104);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=1;\n    for (int i=2;i<=n;i++)\n    {\n        f[i]=", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==104);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==104);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==104);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i++)\n    {\n        f[i", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};/leetcode/1004.cpp\nclass Solution {\npublic:\n\tint longestOnes(vector<int>& A, int K) {\n\t\tint result = 0;\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tint count = 0;\n\t\twhile (right < A.size()) {\n\t\t\tif (", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=1;\n    for (int i=2;i<=n;i++)\n    {\n        f[i]=", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return result;\n}\nint main(){\n\tauto result = fib2(10);\n\tassert(result==55);\n}/fib2.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int result=0;\n    if (n==0)\n   ", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib10(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        if (a>", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i++)", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i++)\n   ", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=1;\n    for (int i=2;i<=n;i++)\n    {\n        f[i]=", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=1;\n    for (int i=2;i<=n;i++)\n    {\n        f[i]=f[i", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==386);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=1;\n    for (int i=3;i<=n;i++)\n   ", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i++)\n    {\n        f[i", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    for (int i=3;i<=n;i++)\n   ", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib2(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=1;\n    for (int i=2;i<=n;i++)\n    {\n        f[i]=f", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/46", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib4(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\nint main(){\n\tauto result = fib4(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib3(int n){\n    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=1;\n    for (int i=3;i<=n;i++)\n   ", "fn": "fib4", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}\n/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint result = 0;\n\twhile(n){\n\t", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}/1001-1050/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\t", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5.5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(abs(result-3)<1e-4);\n\tresult = median({1,2,3,4,5,6});\n\tassert(abs(result-3.5)<1e-4);\n\tresult = median({1,2,3,4,5,6,7};\n\tassert(result==1);\n\tresult = count_bits", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tfor (int i=0;i<1", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint count=0;\n\twhile(n){\n\t\t", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint result=0;\n\twhile(n){\n\t\t", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-3)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(abs(result-3)<1e-4);\n\tresult = median({1,2,3,4,5,6});\n\tassert(abs(result-3.5)<1e-4);\n\tresult = median({1,2,3,4,5,6,7}\n\tassert(result==1);\n\tresult = count_bits(", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": true}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tfor (int i=0;i<100;i++) result*=", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1\n\tassert(result==1);\n}#include<stdio.", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint count=0;\n\twhile(n){\n\t\tcount+=n&1;\n\t", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7};\n\tassert(s.median(v)==4);\n}#include<stdio.h>\n#include<math.h>\n#include<", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-7)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7}t(result-1000000000000000000)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = ", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8}t(result-10.0)<1e-4);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat mean(vector<float> l){\n    float sum=0;\n    for (int i=0", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint count=0;\n\twhile(n){\n\t\tcount+=n&1", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> a(n);\n\tfor (int i=", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1,2,3,4,5,6,7,8}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-8.0)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n\tint result = 0;\n\twhile(n){\n\t\tresult += n&1;\n\t\tn>>", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.threeSumClosest({-1,2,1,-4},1)==2);\n}/leetcode/16.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> l){\n    int max_ending_here = 0;\n    int max_so_far = 0;", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.threeSumClosest({-1,2,1,-4},1)==2);\n}#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\nclass Solution {\npublic:\n\tint threeSum", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/47", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nfloat median(vector<float> l){\n    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\nint main(){\n\tauto result = median(<FILL_ME>);\n\tassert(abs(result-5)<1e-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> l){\n    int max_ending_here = 0;\n    int max_so_far = 0;", "fn": "median", "para": "(vector<float> l)", "type": "float", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abba\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9};\n\tvector<int> result = s.spiralOrder(v);\n\tfor(auto", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abba\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9};\n\tauto result = s.spiralOrder(v);\n\tfor(auto i:result", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abbc\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.find_missing(v);\n\tassert(result", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n\tint max_count = ", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n\tint max_count = ", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": false}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;\n}\n", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": true}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;\n}\n", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": true}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"madam\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n&=(n-1);\n    }\n    return count;\n}\nint main", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": true}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;\n}\n", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": true}
{"task_id": "CPP/48", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_palindrome(string text){\n    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\nint main(){\n\tauto result = is_palindrome(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcba\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;\n}\n", "fn": "is_palindrome", "para": "(string text)", "type": "bool", "pass": true}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000007\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000007t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000007 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d %d\",&a,&b);", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000007 1000000007;\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000007t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3t(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n   ", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;\n    else\n        return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3;\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;\n    else\n        return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2;\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;\n    else\n        return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    if (n==2) return true;\n    if (n%2==0)", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;\n    else\n        return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\",a+b);\n\treturn/100", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;\n    else\n        return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2;\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2\n\tassert(result==1);\n}/test/test_modp.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/49", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main(){\n\tauto result = modp(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint modp(int n,int p){\n    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\nint main", "fn": "modp", "para": "(int n,int p)", "type": "int", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBcdE\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBcdE\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBce\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"cB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"cB\"  return 0;\n}/C++/C++ Primer Plus/Chapter 10/10.10/10.10.cpp\n#include<iostream>\n#include<string>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<new>\n#include<fstream>\n#include<iomanip>\n#include<cmath>", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0){\n        sum+=n%10;\n        n/=10;\n    }\n    return", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"fdcb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"\n\tassert(result==1);\n}/cpp/count_vowels.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"ybcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length();i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i<text.length", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"a\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiou\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOU\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOUaeiou\");\n\tassert(result==\"\");\n\tresult =", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"a\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiou\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOU\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOUaeiouAEIOU\");\n\tassert(result==\"\");\n", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"a\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiou\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOU\");\n\tassert(result==\"\");\n\tresult = remove_vowels(\"aeiouAEIOUaeiouAEIOU\");\n\tassert(result==\"\");\n", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOUbcdfghjklm\"t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeioubcdfghjklm\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOUbcdfghjklm\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeioubcdfghjklm\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    string vowels=\"AEIOUaeiou\";\n    int count=0;\n    for (int i=0;i", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/51", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_vowels(string text){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\nint main(){\n\tauto result = remove_vowels(<FILL_ME>);\n\tassert(result==\"bcdf\\nghjklm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    string vowels=\"AEIOUaeiou\";\n    for", "fn": "remove_vowels", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3}, 4\n\tassert(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": true}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 10\n\tassert(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    if (n==2) return true;\n    if (n%", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": true}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 10t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(vector<int>l){\n    int sum=0;\n    for (int i=0;i<l.size();i++)", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 10t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum = 0;\n    while (n>0){\n        sum += n%10;\n        n /=", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 10t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum = 0;\n    while (n>0){\n        sum += n%10;\n        n /=", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3}, 1\n\tassert(result == 1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count = 0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": true}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}, 5t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3}, 1\n\tassert(result == 1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count = 0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": true}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3}, 4\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_divisors(int n){\n    int count=0;\n    for (int i=1;i<=sqrt(n);i++)\n        if (n", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/52", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool below_threshold(vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\nint main(){\n\tauto result = below_threshold(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{1,2,3}, 4t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum = 0;\n    while (n>0){\n        sum += n%10;\n        n /= 1", "fn": "below_threshold", "para": "(vector<int>l, int t)", "type": "bool", "pass": false}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\n\t}\n\treturn 0;\n}/1001.cpp\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint sum = 0;\n\t\tfor(int i=1;i", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,9\n\t}\n\treturn 0;\n}#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<queue>\n#include<stack>\n#include<assert.h>\nusing namespace std;\n\nint main(){\n", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,9\n\tassert(result==12);\n}/test/test_add.cpp\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(3,9);/test/test", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\n\tassert(result==12);\n}#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(10,2);\n\tassert(result==12);\n", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint a = 10;\n\tint b = 20;\n\tint c = 30;\n\tint d = 40;\n\tint e = 50;\n", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,0\n\t}\n\treturn 0;\n}/1001.cpp\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint sum = 0;\n\t\tfor(int i=1;i<=", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,0\n\t}\n\treturn 0;\n}/1001.cpp\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint sum = 0;\n\t\tfor(int i=1;i<=", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,0\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint a = 1;\n\tint b = 2;\n\tint c = 3;\n\tint d = 4;\n\tint e = 5;\n\tint f = 6", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,0\n\tassert(result==1);\n}#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(1,0);\n\tassert(result==1);\n\tresult = add(1,", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\t}\n\treturn 0;\n}/C++Primer/13/13.34.cpp\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nclass HasPtr{\npublic:\n\tHasPtr(const string &s = string()):ps(new string(s)),i(0){}\n\tHasPtr(const HasPtr &hp):ps", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\treturn 0;\n}#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<queue>\n#include<stack>\n#include<assert.h>\n#include<functional>\n#include<limits.h>", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0x3f3f3", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/53", "code": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint add(int x,int y){\n    return x+y;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "2,3\n\treturn 0;\n}#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\nint main(){\n\tint a[100000];\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin", "fn": "add", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"abx\"t(result==1);\n\tresult = count_bits(1234);\n\tassert(result==10);\n}/count_bits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": false}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ab\",\"ba\");\n\tassert(result==true);\n\tresult = same_chars(\"ab\",\"ac\");\n\tassert(result==false);\n\tresult = same_chars(\"ab\",\"\");\n\tassert(result==false);\n\tresult = same_chars(\"\",\"ab\";\n\tassert(result==1);\n\tresult = count_vowels(\"aeiou\");\n\tassert(result==5);\n\tresult =", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": false}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"def\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"ab\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abcc\"\n\tassert(result==1);\n\tresult = count_ones(100000000000000", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"def\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"ab\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abcc\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abcc\";\n\tassert(result==1);\n", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"def\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"ab\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abcc\");\n\tassert(result==false);\n\tresult = same_chars(\"abc\",\"abcc\"t(result==1);\n\tresult =", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"abx\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ab\",\"ba\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;\n", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": false}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"abx\";\n\tassert(result==1);\n\tresult = find_max_index({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==9);\n}#include<stdio.h>\n#include<math.h>\n#include<string", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = same_chars(\"abc\",\"abx\";\n\tassert(result==1);\n\tresult = count_vowels(\"abc\");\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": true}
{"task_id": "CPP/54", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool same_chars(string s0,string s1){\n    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\nint main(){\n\tauto result = same_chars(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ab\",\"ba\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\nint main", "fn": "same_chars", "para": "(string s0,string s1)", "type": "bool", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "21\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "21\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "21\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "21\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "21t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "89\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "89;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1)", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "89\n\tassert(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tassert(result==10);\n}/test/test_11.cpp\n#", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==89);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "89;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1)", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);#include", "fn": "fib", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);\n", "fn": "fib", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);\n", "fn": "fib", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);\n", "fn": "fib", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "55\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "55\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;/test/test_2.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(1,1);\n", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==55);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "55t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser/test/test_2.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10;/test/test_11.cpp\n#include<stdio.h>\n#include<math.h", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(10,15);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}/test/test_2.cpp\n#include<stdio.h", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\tscanf(\"%d\",&a[i]);\n\tint max=0", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/55", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\nint main(){\n\tauto result = fib(<FILL_ME>);\n\tassert(result==144);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18);", "fn": "fib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\";\n\tassert(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_beautiful_string(string input_string){\n    int count[26]={0};\n    for (int i=0;i<input_string.length();i++)\n   ", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\";\n\tassert(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i=2;i<=sqrt(n);i++)\n    {\n        if (n%i", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\"t_sum(vector<int> a){\n    int sum=0;\n    for (int i=0;i<a.size();i++)\n    {\n        sum+=a[i];\n    }\n    return sum;\n}\nint main(){\n\tauto result = array_sum(vector<int>{1, 2, 3});\n\tassert(result == 6);\n}/array_sum.cpp\n", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<(><)>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": true}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\"t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1000000000;\n\tasser\n\tassert(result);\n}#include<stdio.h>\n#include", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<(><)>\");\n\tassert(result;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_inversions(vector<int> a, vector<int> b, int left, int right){\n    int mid=(left+right)/2;", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_inversions(vector<int> a, vector<int> b, int left, int right){\n    int mid=(left+right)/2;\n    int i=left;", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<(><)>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result);\n\tresult = correct_bracketing(\"<<>>\");\n\tassert(result", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\" 1;\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/56", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"<<>>\"t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_inversions(vector<int> a, vector<int> b, int left, int right){\n    int mid=(left+right)/2;\n    int i=left;\n    int j=mid", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3});\n\tassert(result==true);\n\tresult = monotonic({6,5,4,4});\n\tassert(result==true);\n\tresult = monotonic({1,1,1,1});\n\tassert(result==true);\n\tresult = monotonic({1,3,2});\n\tassert(result==false);\n\tresult = monotonic({1,2,4,5});\n", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3});\n\tassert(result==true);\n\tresult = monotonic({6,5,4,4});\n\tassert(result==true);\n\tresult = monotonic({1,1,1,1});\n\tassert(result==true);\n\tresult = monotonic({1,3,2});\n\tassert(result==false);\n\tresult = monotonic({1,2,4,5});\n", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3});\n\tassert(result==true);\n\tresult = monotonic({6,5,4,4});\n\tassert(result==true);\n\tresult = monotonic({1,1,1,1});\n\tassert(result==true);\n\tresult = monotonic({1,3,2});\n\tassert(result==false);\n\tresult = monotonic({1,2,4,5});\n", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++) sum", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": true}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++) sum+=arr", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_two_smallest_numbers(vector<int> numbers) {\n    sort(numbers.begin(),numbers.end());\n    return numbers[0]+numbers[1];", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tvector<int> result=s.runningSum(v);\n\tfor (int i=0;i<result.size();i++)\n\t", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": false}
{"task_id": "CPP/57", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool monotonic(vector<float> l){\n    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\nint main(){\n\tauto result = monotonic(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3});\n\tassert(result==true);\n\tresult = monotonic({6,5,4,4});\n\tassert(result==true);\n\tresult = monotonic({1,1,1,1});\n\tassert(result==true);\n\tresult = monotonic({1,3,2});\n\tassert(result==false);\n\tresult = monotonic({1,2,4,5});\n", "fn": "monotonic", "para": "(vector<float> l)", "type": "bool", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4,5},{1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4,5},{1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4,5},{1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4,5},{1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = common({1,2,3,4,5},{6,7,8,9,10});\n\tassert(issame(result,{}));\n\tresult = common({1,2,3,4,5},{1,2,3,", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{2,3,4});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5,6});\n\tassert(issame(result,{2,3}));\n\tresult = common({", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{2,3,4});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5,6});\n\tassert(issame(result,{2,3}));\n\tresult = common({", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{2,3,4});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5,6});\n\tassert(issame(result,{2,3}));\n\tresult = common({", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{2,3,4});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5,6});\n\tassert(issame(result,{2,3}));\n\tresult = common({", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{2,3,4});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5});\n\tassert(issame(result,{2,3}));\n\tresult = common({1,2,3},{2,3,4,5,6});\n\tassert(issame(result,{2,3}));\n\tresult = common({", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_10.cpp\n#include<stdio.h>\n#include<", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}t(result,{1,2,3,4,5,6,7,8,9,10});\n}/test/test_common.cpp\n#include<stdio.h>\n#include<math.h>\n#", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}t(result,{1,2,3,4,5,6,7,8,9,10});\n}/test/test_common.cpp\n#include<stdio.h>\n#include<math.h>\n#", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{1,5,653}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/58", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> common(vector<int> l1,vector<int> l2){\n    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = common(<FILL_ME>);\n\tassert(issame(result,{2,3,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5,6});\n\tassert(issame(result,{2,3,4}));\n\tresult = common({1,2,3,4,5},{2,3,4,5", "fn": "common", "para": "(vector<int> l1,vector<int> l2)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143t(result==233168);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n        if (i%", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==23);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n    if (i%3==", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i*", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==23);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n\tint sum=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (i", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==23);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n\tint sum=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (i", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143;\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143 1000000; i++) {\n        if (is_palindrome(i) and is_palindrome(i*i)) {\n            cout << i << endl;\n            break;\n        }\n    }\n}/004.cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_pal", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tauto result = sum_of_primes(2000000);\n\tassert(result==142913828922);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143 100000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143t(result==233168);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n    if (i%", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i*", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i*", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i*", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143;\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n\tint sum=0;\n\tfor (int i=1;i<=n;i++) sum", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==232792560);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "6;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n=n/10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result =", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "6t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n=n/10;\n    }\n    return sum;\n}\nint main(){\n", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "6\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0){\n        sum+=n%10;\n        n=n/10;\n    }\n    return sum;\n}\nint main", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "6t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_palindrome(int n){\n    int rev=0;\n    int temp=n;\n    while(temp>0){\n        rev=rev*10+temp%10;\n        temp=temp/10;\n    }\n   ", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "6t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) return 0;\n    return 1;\n}\nint main(){\n\tauto result", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143;\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143t(result==23);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1;i<n;i++)\n    if (i%3==0 or", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143;\n\tassert(result==23);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n\tint sum=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143\n\tassert(result==104743);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_squares(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++) sum+=i*", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/59", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_prime_factor(int n){\n    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\nint main(){\n\tauto result = largest_prime_factor(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "600851475143 100000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "largest_prime_factor", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "50t(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}/src/10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_multiples(int n){\n\tint sum = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(i", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==5050);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count = 0;\n    while(n){\n        count++;\n        n = n&(n-1);\n    }\n    return count;\n}\nint main(){\n\tauto result = count", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5 1000000007;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n);\n\tint ans = 0;\n\tfor(int i=0;i<n;i++){\n\t\tans = (ans+a[i]*(n-i))%mod;\n\t}\n\tcout", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n    }", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==21);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "5\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}/test/test_2.cpp\n#include<stdio.h>", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n<2) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n   ", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n   ", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main(){\n\t", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==66);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;\n   ", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    for(int i=2;i<=sqrt(n);i++){\n        if(n%i==0) return 0;", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}/test/test_sum_to_n.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findMedianSortedArrays(v,v);\n\tassert(result==5.5);\n}#include<vector>\n#include<stdio", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i=1;i<=n;i++){\n        sum+=i;\n    }\n    return sum;\n}\nint main", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==465);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100t(result==10);\n}/test/test_sum_to_n.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(1);\n\tassert(result==1);", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t main(){\n\tauto result = sum_to_n(1);\n\tassert(result==1);\n}/test/test_sum_to_n.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(1);\n\tassert(result==1);", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(1);\n\tassert(result==1);", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/60", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_to_n(int n){\n    return n*(n+1)/2;\n}\nint main(){\n\tauto result = sum_to_n(1);t main(){\n\tauto result =", "fn": "sum_to_n", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((()t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_digit(int n){\n    int max=0;\n    while (n>0)\n    {\n        if (n%10>max) max=n%10;\n        n/=10;", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((()\n\tassert(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1000000000;#include<stdio.h>\n#include<math.h>\n#include<string>\n", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((()\t\t}\n\t\t}\n\t\tif (result==-1)\n\t\t{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<result<<endl;\n\t\t}\n\t}\n\treturn 0;\n}/Codeforces/1000/1000A.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((()t_sum(a,b,c);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint largest_number(int a,int b,int c){\n    int max=a;\n    if (b>max) max=b;", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(result);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((() 1;\n\t}\n\treturn 0;\n}\n/week1/task1/task1.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((5+3)*2+1)\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++) scanf(\"%", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"((5+6) * (7+8)/(4+3))\"t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\n", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"(()t(result);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a, int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(18,35", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"(()(())())\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result =", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/61", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool correct_bracketing(string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\nint main(){\n\tauto result = correct_bracketing(<FILL_ME>);\n\tassert(not(result));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"(()(())())\"  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d%", "fn": "correct_bracketing", "para": "(string brackets)", "type": "bool", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> out={", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4} 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}/test/test_map.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> map(vector<float> xs,float (*f)(float)){", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{1,4,12,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5}t> xs){\n    vector<float> out={};\n    for (int i=0;i<xs.size();i++)\n        out.push_back(xs[i]*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = square({1,2,3,4,5});\n\tassert(issame(result,{1,4,9,1", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5};\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> map(vector<float> xs,float (*f)(float)){\n    vector<float", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6}\n\tassert(issame(result,{1,2,3,4,5,6}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> map(vector<float> xs,float (*f)(float)){\n    vector<float>", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5}\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> map(vector<float> xs,float (*f)(float)){\n    vector<float>", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6});\n\tassert(issame(result,{0,2,6,12,20,30}));\n\tresult = derivative({1,2,3,4,5,6,7});\n\tassert(issame", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6});\n\tassert(issame(result,{0,2,6,12,20,30}));\n\tresult = derivative({1,2,3,4,5,6,7});\n\tassert(issame", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}t(issame(result,{}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6});\n\tassert(issame(result,{0,2,6,12,20,30}));\n\tresult = derivative({1,2,3,4,5,6,7});\n\tassert(issame", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}t> xs){\n    vector<float> out={};\n    for (int i=0;i<xs.size();i++)\n        out.push_back(xs[i", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6});\n\tassert(issame(result,{0,2,6,12,20,30}));\n\tresult = derivative({1,2,3,4,5,6,7});\n\tassert(issame", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}t> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(xs[i", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,2,6,12,20}));\n\tresult = derivative({1,2,3,4,5,6,7,8,9,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> out={", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> out={", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> out={", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/62", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> derivative(vector<float> xs){\n    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\nint main(){\n\tauto result = derivative(<FILL_ME>);\n\tassert(issame(result,{2,2,0,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<float> map(vector<float> xs,float (*f)(float)){\n    vector<float> out={};\n   ", "fn": "derivative", "para": "(vector<float> xs)", "type": "vector<float>", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++)\n        sum+=i;\n    return sum;\n\n}\nint main(){\n\tauto result = sum(", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n}\nint", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n!=0){\n        n=n/10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==274);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\tassert(result==1);\n}/test/test_2.cpp\n#include<stdio.h>\n#", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n\t", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_fibfib.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=1;\n    for (int i=2;i<=n;i++)\n        ff[i]=ff[i-", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findMedianSortedArrays(v,v);\n\tassert(result==5.5);\n}/leetcode/4.median-of-two-sorted", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while(n){\n        if(n%2==1)\n            count++;\n        n/=2;\n    }\n    return count;\n}\nint main(){\n\tauto", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n}\nint", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n!=0){\n        n=n/10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n){\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\nint main(){\n\tauto result = count_", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==81);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}/test/test_2.cpp\n#include<stdio.h>\n", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;/test/test_2.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n}\nint", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1)\n        return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==0)\n            return 0;\n   ", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1)\n        return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==0)\n            return 0;\n   ", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==927);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    int a[n];\n    for (int i=0;i<n;i++)\n        cin>>a[i];\n    int b[m];\n    for (int i=", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n=n/10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_digits(", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=1;\n    for (int i=2;i<=n;i++)\n        ff[i]=ff[i-", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n}\nint main(){\n", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findMedianSortedArrays(v,v);\n\tassert(result==5.5);\n}#include<vector>\n#include<stdio.h>", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n}\nint", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while(n){\n        if(n&1)\n            count++;\n        n=n>>1;\n    }\n    return count;\n}\nint main(){\n\t", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tvector<int> result = s.findDisappearedNumbers(nums);\n\tfor (int i=0;i<result.size();i++)\n\t\tcout<<result[", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/63", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fibfib(int n){\n    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\nint main(){\n\tauto result = fibfib(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        if(n%2==1)\n            count++;\n        n=n/2;\n    }\n    return count;\n\n}\nint", "fn": "fibfib", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0){\n        sum+=n%10;\n        n/=10;", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"y\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0){\n        sum+=n%10;\n        n/=10;\n   ", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"y\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"y\"t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<assert.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/64", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint vowels_count(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\nint main(){\n\tauto result = vowels_count(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiouAEIOU\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string s){\n    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<", "fn": "vowels_count", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2;\n\tassert(result==2);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x>0){\n        count+=x&1;\n        x>>=1;\n    }\n   ", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x>0){\n        count+=x&1;\n        x>>=1;\n    }\n    return count;", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2  }\n    return 0;\n}/leetcode/1021.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int x){\n    if (x<2)\n    {\n        return 0;\n    }\n    for (int i = 2; i <= sqrt(x", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"21\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums={1,2,3,4,5,6,7};\n\tvector<int> result=s.findDisappearedNumbers(nums);\n\tfor (int i = 0; i < result.size(); ++i)\n\t{\n\t\tcout", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,2;\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,2t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x){\n        count++;\n        x=x&(x-1);\n    }\n    return count;\n}\nint main(){", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int x){\n    if (x==1)\n    {\n        return 0;\n    }\n    for (int i = 2; i <= sqrt(x); i++)", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": true}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while (x>0)\n    {\n        count+=x%2;\n        x/=2;\n    }\n    return count", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "11,1;\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int result=0;\n    for (int i = 0; i < nums", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int x){\n    int count=0;\n    int max_count=0;\n    while (x>0)\n    {\n        if (", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,2  }\n    return 0;\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,2t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x){\n        count++;\n        x=x&(x-1);\n    }\n    return count;\n}\nint main", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while (x)\n    {\n        count+=x&1;\n        x>>=1;\n    }\n    return count;", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x>0){\n        count+=x&1;\n        x>>=1;\n    }\n    return count;", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x>0){\n        count+=x&1;\n        x>>=1;\n    }\n    return", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x){\n        count++;\n        x=x&(x-1);\n    }\n    return count;", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x>0){\n        count++;\n        x=x&(x-1);\n    }\n    return", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while (x>0)\n    {\n        count+=x&1;\n        x>>=1;\n    }\n    return", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"12\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,2 1000000007;\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i];\n\t}\n\tint ans=0;\n\tfor (int i = 0; i < n; ++i)\n\t", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "79,1\t\t}\n\t\t}\n\t\tif (i==0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn i;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.lengthOfLastWord(\"Hello World\")==5);\n\tassert(s.lengthOfLastWord(\"Hello World  \")==5);\n\tassert(s.lengthOfLastWord(\"Hello World ", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789,3t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while (x!=0)\n    {\n        x=x&(x-1);\n        count++;\n   ", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789,3  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++)\n    {\n        int a,", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789,3  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int a[n];\n    for (int i = 0; i < n; i++)", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/65", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring circular_shift(int x,int shift){\n    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\nint main(){\n\tauto result = circular_shift(<FILL_ME>);\n\tassert(result==\"79\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789,3;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int x){\n    int count=0;\n    while(x){\n        count++;\n        x=x&(x-1);\n    }", "fn": "circular_shift", "para": "(int x,int shift)", "type": "string", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1000;\n\tasser/test/test_1001.cpp\n#include", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_10000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==131);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 1000000007;\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n;", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_1000_1099/test_1007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0)\n        return a;", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count(string s){\n    int count=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]=='a')\n            count++;\n    return count;", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1)\n        return 0;\n    for (int i=2;i<=sqrt(n);i++)", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1)\n        return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==0)", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 0;\n}/Codeforces/1100/1100A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    int a[n],b[m];\n    for (int i=0;i<n;i++)\n        cin>>a[i];\n    for (int i", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_1000_1099/test_1004.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint numUniqueEmails(string emails){\n    int n=emails.length();\n    int count=", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==151);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}/CodeForces/118A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tstring s;\n\tcin>>s;\n\tfor (int i=0;i<s.length();", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tvector<int> result = s.findDisappearedNumbers(nums);\n\tfor (int i=0;i<result.size();i++)\n\t\tcout<<", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_gcd(int a,int b){\n    if (b==0)\n        return a;\n    return find_gcd(b,a%b);\n}\nint main(){\n", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findSmallestInt(vector<int> args) {\n    int min=args[0];\n    for (int i=0;i<args.size();i++)\n        if (args", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1)\n        return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==0)", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==153);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 1000000007;\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tint b[m];\n\tfor (int i=0;i<m;i++)\n\t\tcin>>b[i];\n\tint c[n+", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findSmallestInt(vector<int> args){\n    int min=args[0];\n    for (int i=0;i<args.size();i++)\n        if (args[", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/cpp/1000-1099/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint addDigits(int num){\n    if (num==0)\n        return 0;\n    else\n       ", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint addDigits(int num){\n    if (num<10)\n        return num;\n    int sum=0;\n    while (num>0){", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}/test/test_1000_1099/test_1003.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==69);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDuplicates(v);\n\tassert(result.size()==2);\n\tassert(result[0]==2);\n\tassert(result[1]==", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/leetcode/1013.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint canThreePartsEqualSum(vector<int>& A) {\n    int sum=0;\n    for (int i=0;i<A.", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\" 1000000000;\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result =\n\tassert(result==1000", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==67);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDisappearedNumbers(v);\n\tfor (auto i:result)\n\t\tcout<<i<<\" \";\n\tcout<<endl;\n}", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count(int n){\n    int count=0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findNb(int m) {\n    int n=1;\n    while (m>0){\n        m-=n*n*n;\n        n++;\n    }\n    return m==0?n", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"\n\tassert(result==1);\n}/CodeForces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\t", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\";\n\tassert(result==1);\n}/cpp/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1\tassert(result==1);\n}/cpp/", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/66", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digitSum(string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\nint main(){\n\tauto result = digitSum(<FILL_ME>);\n\tassert(result==327);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ABC\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint countBits(int n){\n    int count=0;\n    while (n>0){\n        count+=n%2;\n        n/=2;\n    }\n    return count;\n}\nint main(){", "fn": "digitSum", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tauto result = Solution().findMedianSortedArrays(vector<int>{1,2},vector<int>{3,4});\n\tassert(result==2.5);\n}/leetcode/4.cpp\n#include<stdio.h>\n#include<math.h", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_sum(int a[],int n){\n    int max_sum=0;\n    for", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==95);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"100 200 200 100 100 300 200 100 200\",9\t\tif (i==0)\n\t\t\t{\n\t\t\t\tif (s[i]>=48 and s[i]<=57)\n\t\t\t\t{\n\t\t\t\t\tnum1=num1+s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/C++/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10000", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10\n\tassert(result==1);\n}/C++/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 100000", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"100 200 200 100\",4t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_sum(int arr[],int n){\n    int max_sum=0;\n    for", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10\t\tif (i==0)\n\t\t\t{\n\t\t\t\tif (s[i]!='0')\n\t\t\t\t{\n\t\t\t\t\tif (s[i]!='1')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[i]!='2')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (s[i]!='3')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (s[i]!='4')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1000/10", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789\", 10\n\tassert(result==1);\n}/code/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 100000", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tauto result = Solution().findMedianSortedArrays({1,3}, {2});\n\tassert(result==2);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_sum(int arr[],int n){\n    int max_sum=0;", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10;\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_sum(int arr[],int n){\n    int max_sum=0;", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\", 10;\n\tassert(result==1);\n}/C++/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/67", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint fruit_distribution(string s,int n){\n    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\nint main(){\n\tauto result = fruit_distribution(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\",10t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_sum_subarray(int arr[],int n){\n    int max_sum=0", "fn": "fruit_distribution", "para": "(string s,int n)", "type": "int", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2, 4, 6, 8, 10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1, 2, 3, 4, 5});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({1, 3, 5, 7});\n\tassert(issame(result,{1,0}));\n\tresult = pluck", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6});\n\tassert(issame(result,{6,5}));\n\tresult = pluck({1,2,3,4,5,6,7});\n\tassert(issame(result,{6,5}));\n\tresult = pluck({1,2,3,4,5,7,6});\n\tassert(issame(result,{6,6}));\n\tresult = pluck", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2, 4, 6, 8, 10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1, 2, 3, 4, 5});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({1, 3, 5, 7, 9});\n\tassert(issame(result,{1,0}));\n\tresult", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2, 4, 6, 8, 10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1, 2, 3, 4, 5});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({1, 3, 5, 7, 9});\n\tassert(issame(result,{1,0}));\n\tresult", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{4,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{4,3}));\n\tresult = pluck({1,2,3,4,5,6});\n\tassert(issame(result,{6,5}));\n\tresult = pluck({1,3,5,7});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({2,4,6,8});\n", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = pluck({1});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2,1});\n\tassert(issame(result", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = pluck({1});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2,1});\n\tassert(issame(result", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = pluck({2});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({2,4});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({2,4,6});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({2,4,6,8});", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5});\n\tassert(issame(result,{2,1}));\n\tresult = pluck({1,3,5,7,9});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9});", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = pluck({1});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2,1});\n\tassert(issame(result", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{0,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{0,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,3,5,7,9,11,13,15,17,19});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2,4,6,8,10,12", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,2,3,4,5,6,7,", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,0}));\n\tresult = pluck({1,3,5,7,9,11,13,15,17,19});\n\tassert(issame(result,{1,0}));\n\tresult = pluck({2,4,6,8,10,12", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/68", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> pluck(vector<int> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\nint main(){\n\tauto result = pluck(<FILL_ME>);\n\tassert(issame(result,{2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,6,8,10}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int", "fn": "pluck", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,1,1,1,1,1,1,1,1,1});\n\tassert(result==1);\n\tresult = search({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==10);\n", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,1,1,1,1,1,1,1,1,1});\n\tassert(result==1);\n\tresult = search({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==10);\n", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": true}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4,5,5,5,5,5});\n\tassert(result==5);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,8,8,8,8,8,8,8,8,8,8,8,8,8", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,1,1,1,1,1,1,1,1,1});\n\tassert(result==1);\n\tresult = search({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==10);\n", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,1,1,1,1,1,1,1,1,1});\n\tassert(result==1);\n\tresult = search({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==10);\n", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/69", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint search(vector<int> lst){\n    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = search(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,2,3,3,3,4,4,4,4});\n\tassert(result==3);\n\tresult = search({1,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "fn": "search", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,5,2,4,3}t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}/leetcode/1-20/1-10/10.cpp\n#include<stdio.h>\n#include", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,5,2,4,3}t(result,{1,2,3,4,5,6,7,8,9,10});\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> odd_even", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,2,4,3,1});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = strange_sort_list({1,5,2,4,3});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = strange_sort_list({1,5,2,4,3}t(result,{1,2,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,5,2,4,3}t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=1;\n        n/=10;\n   ", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,5,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,5,2,4,3});\n\tassert(issame(result,{1,2,3,4,5})t(result,{1,2,3,4,5}));\n}/test/test_strange_sort_list.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{8,3,7,6,5,4,2,1}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{8,3,7,6,5,4,2,1}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_string(string str){\n    vector", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,8,2,7,3,6,4,5});\n\tassert(issame(result,{1,2,3,4,5,6,7,8}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8});\n\tassert(issame(result,{1,2,3,4,5,6,7,8}));\n\tresult = strange_sort", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,8,2,7,3,6,4,5});\n\tassert(issame(result,{1,2,3,4,5,6,7,8}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8});\n\tassert(issame(result,{1,2,3,4,5,6,7,8}));\n\tresult = strange_sort", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,8,2,7,3,6,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{8,3,7,6,5,4,2,1}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,2,0,-5,5,-5,5});\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n\tresult = strange_sort_list({-5,5,-5,5,0,2,2,2});\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n\tresult =", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,2,0,-5,5,-5}t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_list(vector<int", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,2,0,-5,5,-5,5}t(result,{-1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,2,0,-5,5,-5,5});\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n\tresult = strange_sort_list({-5,5,-5,5,0,2,2,2});\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n\tresult =", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{-5,5,-5,5,0,2,2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,2,0,-5,5,-5}t(result,{-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9}));\n\tresult = strange_sort_list({1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9}));\n\tresult = strange_sort_list({1,9,5,8,6,7}", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9}));\n\tresult = strange_sort_list({1,9,5,8,6,7,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,3,5,7,9,2,4,6,8}));\n\tresult = strange_sort_list({9", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,9,5,8,6,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,9,5,8,6,7});\n\tassert(issame(result,{1,5,6,7,8,9}));\n\tresult = strange_sort_list({1,9,5,8,6,7,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,4,2,3}t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> odd_even_sort(vector<int> lst){\n    vector<", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,4,2,3}t(result,{1,2,3,4,5,6,7,8,9,10});\n}/leetcode/1-100/0001-0100/0001-0010/0009.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,4,2,3}t(result,1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=n%2;\n        n/=2;\n    }\n   ", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,4,2,3});\n\tassert(issame(result,{1,2,3,4})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{1,4,2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,4,2,3}t(result,1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=n%2;\n        n/=2;\n    }\n   ", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,9,6,8,7});\n\tassert(issame(result,{5,6,7,8,9})t(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-100/1-10/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,9,6,8,7});\n\tassert(issame(result,{5,6,7,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,9,6,8,7});\n\tassert(issame(result,{5,6,7,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,9,6,8,7});\n\tassert(issame(result,{5,6,7,8,9});\n\tassert(issame(result,{1,2,3,4,5}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,9,6,8,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,9,6,8,7});\n\tassert(issame(result,{5,6,7,8,9})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,5,5,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5,5});\n\tassert(issame(result,{5,5,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,5,5,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5,5});\n\tassert(issame(result,{5,5,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,5,5,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5,5});\n\tassert(issame(result,{5,5,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,5,5,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5,5});\n\tassert(issame(result,{5,5,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{5,5,5,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,5,5,5});\n\tassert(issame(result,{5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5});\n\tassert(issame(result,{5,5,5,5,5}));\n\tresult = strange_sort_list({5,5,5,5,5,5});\n\tassert(issame(result,{5,5,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,3,5,7,9,10,8,6,4,2}));\n\tresult = strange_sort_list({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/70", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> strange_sort_list(vector<int> lst){\n    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\nint main(){\n\tauto result = strange_sort_list(<FILL_ME>);\n\tassert(issame(result,{111111}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "strange_sort_list", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-16.25)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result-1000000000000000000)<0.01);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long int sum_of_digits(long long int n){\n    long long int sum=0;\n    while(", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-0.43)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result-0.43)<0.01);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n   ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 0;\n}/C++/1001.cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tint sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsum+=i;\n\t}\n\tcout<<sum<<endl;\n\treturn\t\t}\n\t\t}", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-6.00)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result-1.73)<0.01);\n}/test/test_triangle_area.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<=1) return 0;\n    for (int i=2;i<=sqrt(n);i++){", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-1.73)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result-1.73)<0.01);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n   ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2,3);\n\tassert(abs(result-1.98431)<0.01);\n\tresult = triangle_area(1,1,1);\n\tassert(abs(result-0.866025)<0.01);\n\tresult = triangle_area(3,4,5);\n\tassert(abs(result-6)<0.01);\n\tresult = triangle_area(", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2,3);\n\tassert(abs(result-1.98431)<0.01);\n\tresult = triangle_area(1,1,1);\n\tassert(abs(result-0.866025)<0.01);\n\tresult = triangle_area(3,4,5);\n\tassert(abs(result-6)<0.01);\n\tresult = triangle_area(", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2,3);\n\tassert(abs(result-1.98431)<0.01);\n\tresult = triangle_area(1,1,1);\n\tassert(abs(result-0.866025)<0.01);\n\tresult = triangle_area(3,4,5);\n\tassert(abs(result-6)<0.01);\n\tresult = triangle_area(", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2,3);\n\tassert(abs(result-1.98431)<0.01);\n\tresult = triangle_area(1,1,1);\n\tassert(abs(result-0.866025)<0.01);\n\tresult = triangle_area(3,4,5);\n\tassert(abs(result-6)<0.01);\n\tresult = triangle_area(", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result+1)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2,3);\n\tassert(abs(result-1.98431)<0.01);\n\tresult = triangle_area(1,1,1);\n\tassert(abs(result-0.86603)<0.01);\n\tresult = triangle_area(3,4,5);\n\tassert(abs(result-6)<0.01);\n\tresult = triangle_area(1", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": true}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return ", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 0;\n}/1001.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[100000];\n\tfor (int i=0;i<n;i++){", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/71", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat triangle_area(float a,float b,float c){\n    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\nint main(){\n\tauto result = triangle_area(<FILL_ME>);\n\tassert(abs(result-8.18)<0.01);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result-1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "triangle_area", "para": "(float a,float b,float c)", "type": "float", "pass": false}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": true}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5,6,7,8,9,10},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5,6,7,8", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": true}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": true}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": true}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": true}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": false}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},100t.push_back(i);\n        }\n    }\n    return result;\n}\nint main(){\n\tauto result = find_all_factors(10);\n\tassert(result==vector<int>{1,2,5,10});\n}/find_all_factors.cpp\n#include<stdio.", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": false}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},15);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},16);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": false}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},15);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},16);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": false}
{"task_id": "CPP/72", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool will_it_fly(vector<int> q,int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\nint main(){\n\tauto result = will_it_fly(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},10);\n\tassert(result==true);\n\tresult = will_it_fly({1,2,3,4,5},11);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,4,5},12);\n\tassert(result==false);\n\tresult = will_it_fly({1,2,3,", "fn": "will_it_fly", "para": "(vector<int> q,int w)", "type": "bool", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/73", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint smallest_change(vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\nint main(){\n\tauto result = smallest_change(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "smallest_change", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"admin\"}, {\"hi\",\"admin\"}\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"admin\"}, {\"hi\",\"admin\"}  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while(scanf(\"%d%d", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"admin\"}, {\"hi\",\"admin\"}t(result,{\"hi\",\"admin\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"admin\"}, {\"hi\",\"admin\"};\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"admin\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"admin\"}, {\"hi\",\"admin\"}t(result,{\"hi\",\"admin\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\"},{\"hi\",\"hi\"};\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\"},{\"hi\",\"hi\"}t(result,{\"hi\",\"hi\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\"}, {\"hi\",\"hi\"}t(result,{\"hi\",\"hi\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\"}, {\"hi\",\"hi\"}t(result,{\"hi\",\"hi\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\"},{\"hi\",\"hi\"};\n\tassert(issame(result,{\"hi\",\"hi\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hI\",\"Hi\"}, {\"Hello\",\"heLlo\"} 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"d\",\"e\"});\n\tassert(issame(result,{\"d\",\"e\"}));\n\tresult = total_match({\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"});\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = total_match({\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\",\"g\"});\n\tassert(issame(result,{\"a\",\"b\",\"c", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"d\",\"e\"});\n\tassert(issame(result,{\"d\",\"e\"}));\n\tresult = total_match({\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"});\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = total_match({\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\",\"g\"});\n\tassert(issame(result,{\"d\",\"e\",\"f", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}t(result,{\"a\",\"b\",\"c\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n   ", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"Hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"};\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"};\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\",\"hi\"},{\"hi\",\"hi\",\"hi\"}  }\n    return 0;\n}/1001-1050/1009.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n,i", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"hi\",\"hi\",\"hi\"},{\"hi\",\"hi\",\"hi\"}t(result,{\"1\",\"2\",\"3\"});\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split(string str,string pattern){", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}t(result,{\"a\",\"b\",\"c\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string>", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"hI\",\"hi\",\"hi\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}t(result,{\"a\",\"b\",\"c\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string>", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}t(result,{\"a\",\"b\",\"c\"});\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n,i,j,k,l,m,t,a[100000", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"a\",\"b\",\"c\"}  }\n    return 0;\n}\n/1001-1050/1002/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"}t(result,{\"a\",\"b\",\"c\"});\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\"},{\"a\",\"b\",\"c\",\"d\"}t(result,{\"a\",\"b\",\"c\",\"d\"});\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\"},{\"1\",\"2\",\"3\"}  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while(scanf", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\"},{\"1\",\"2\",\"3\"}t(result,{\"1\",\"2\",\"3\"});\n}/test/test_total_match.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\"},{\"1\",\"2\",\"3\"}t(result,{\"1\",\"2\",\"3\"});\n\tassert(issame(result,{\"1\",\"2\",\"3\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\"}, {\"4\"}t(result,{\"1\",\"2\",\"3\"});\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/74", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\nint main(){\n\tauto result = total_match(<FILL_ME>);\n\tassert(issame(result,{\"4\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\"},{\"1\",\"2\",\"3\"}  }\n    return 0;\n}/1001-1050/1010/1010.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){", "fn": "total_match", "para": "(vector<string> lst1,vector<string> lst2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (i == 1 && j == 1) {\n                dp[i][j] = 1;\n            } else if (i == 1) {\n                dp[i][j] = dp[i][j - 1];\n            } else if (j == 1) {\n                dp[i][", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12 1;\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\twhile (scanf(\"%d%d\",&a,&b)!=EOF)\n\t{\n\t\t", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/75", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_multiply_prime(int a){\n    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\nint main(){\n\tauto result = is_multiply_prime(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_multiply_prime", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000);\n\tassert(result==true);\n\tresult = is_simple_power(1000000000,1000000000000000000\t\t}\n\t\t}\n\t\tif (count==0)\n\t\t{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000);\n\tassert(result==true);\n\tresult = is_simple_power(1000000000,1000000000000000000);\n\tassert(result==false);\n\tresult = is_simple_power(1000000000,", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000);\n\tassert(result==true);\n\tresult = is_simple_power(1000000000,1000000000000000000;\n\tassert(result==1);\n\tresult = count_of_digit(10000000", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000);\n\tassert(result==true);\n\tresult = is_simple_power(1000000000,1000000000000000000);\n\tassert(result==false);\n\tresult = is_simple_power(1000000000,", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": true}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000 1000000000, 1000000000);\n\tassert(result == 1000000000);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": false}
{"task_id": "CPP/76", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_simple_power(int x,int n){\n    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_simple_power(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1", "fn": "is_simple_power", "para": "(int x,int n)", "type": "bool", "pass": true}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125 1;\n\t}\n\treturn 0;\n}/1000/1000.cpp\n#include<stdio.h>\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d %d\",&a,&b)!=EOF){\n\t\tprintf(\"%d\\n\",a+b);\n\t\treturn/1001/1001.cpp\n#include", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125\t\t}\n\t\t}\n\t\tif (flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}/Codeforces/1000~1999/1005/1005A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint t;\n", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18);", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18);", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,16);", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result =", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125t(result==1);\n}/test/test_isprime.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool isprime(int a){\n    if (a==1) return false;\n    for (int i=2;i<=sqrt(a);i++)\n        if (a%i==", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18);\n\t", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,18);", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": true}
{"task_id": "CPP/77", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool iscuber(int a){\n    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\nint main(){\n\tauto result = iscuber(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "125 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tif (a+b>c&&a+c>b&&b+c>a) printf(\"YES", "fn": "iscuber", "para": "(int a)", "type": "bool", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_out(string num){\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (num[i]=='", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"  }\n    return 0;\n}/CodeWars/7kyu/Find the odd int.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_it(int *seq, int len) {\n    for (int i=0;i<", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_out(string num){\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (num[i]=='1", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/cpp/1000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int arr[], int n){\n    int sum=0;\n    for (int", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int arr[], int n){\n    int out=0;\n    for (int", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 0;\n\tassert(result==0);\n\treturn\n\tassert(result==0);\n\treturn 0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tauto result = Solution().findLHS(vector<int>{1,3,2,2,5,2,3,7});\n\tassert(result==5);\n}/leetcode/leetcode-594.cpp\n#include<stdio.h>\n#include<math", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_100.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int *values, int length) {\n    int sum=0;\n    for (int i=", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_out(string num){\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (num[i]=='1", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_hex_key.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_out(string num){\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tauto result = Solution().findLHS(vector<int>{1,3,2,2,5,2,3,7});\n\tassert(result==5);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_outlier(int arr[], int len){\n    int out=0;\n    int odd=0;\n    int even=0;\n    for (int i=0;i<", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_it(int arr[], int len){\n    int out=0;\n    for (int i=0;i<len;i", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/cpp/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1000000007;", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": true}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int* values, int length){\n    int out=0;\n    for (int i=0;i<length;i++)\n    if (", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_divisors(int n) {\n    int out=0;\n    for (int i=1;i", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": true}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\" 1;\n\t}\n\treturn 0;\n}\n/CodeForces/118A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tstring s;\n\tcin>>s;\n\tfor (int i=", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int arr[], int n){\n    int sum=0;\n    for (int i=0;i", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int *values, int length) {\n    int sum=0;\n    for (int i=0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/cpp/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1000000007;", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int *values, int length) {\n    int sum=0;\n    for (int i=0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"t(result==1);\n}/test/test_10000000000000000000000000000000000000000000000000000000000000000000000", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even(int num){\n    int out=0;\n    while (num>0){\n        if (num%2==0) out+=1;\n        num/=", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_it(int arr[], int len){\n    int out=0;\n    for (int i=0;i<len;i++)\n    {\n        int count=", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_it(int arr[], int n){\n    int out=0;\n    for (int i=0;i<n;i++)\n    {\n        int count=0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\" 1;\n\t}\n\treturn 0;\n}/CodeForces/118A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tstring str;\n\tcin>>str;\n\tfor (int i=0", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/78", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint hex_key(string num){\n    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\nint main(){\n\tauto result = hex_key(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2357BD\"\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}/Codeforces/1000~1999/1005/1005.cpp\n#include<iostream>\n#include<", "fn": "hex_key", "para": "(string num)", "type": "int", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100000t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n    return", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100000\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100000t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max=0;\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100000t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_bit(int n){\n    int max_bit=0;\n    while (n>0)\n    {\n        max_bit=max(max_bit,n%1", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db100000db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100000t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n    return", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "117\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int out=0;\n    for (int i=0;i<numsSize;i++)", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "117;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(int *values, int length){\n    int sum=0;\n    for (int i = 0; i < length; i++)\n    {\n        sum+=values", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "127;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(const vector<int> &arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)\n    {\n        sum", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "117t(result==1);\n}/test/test_is_power_of_two.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_power_of_two(int n){\n    if (n==0) return false;\n    while (n%2==", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1100111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "127t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_bit(int num, int i){\n    return (num>>i)&1;\n}\nint main(){\n\tauto result = get_bit(1024, 10);", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "15t(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "15t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_even_index(int *values, int length){\n    int sum=0;\n    for (int i = 0; i < length; i++)\n    {\n        sum+=values[i];\n   ", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "15\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDisappearedNumbers(v);\n\tfor (auto i:result) cout<<i<<\" \";\n\tcout<<endl;\n}#include", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "15t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n    return count;\n}", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db1111db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "15t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n    return count;\n}", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "0\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_first_set_bit(int n){\n    int i=0;\n    while (n>0)\n    {\n        if (n%2==1) return i;\n        n=n/", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": true}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "0;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max=0;\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1)", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "0\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> in={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.spiralOrder(in);\n\tassert(result==vector<int>({1,2,3,6,9,8,7,4,5,", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "0t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n   ", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/79", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring decimal_to_binary(int decimal){\n    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\nint main(){\n\tauto result = decimal_to_binary(<FILL_ME>);\n\tassert(result==\"db0db\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "0t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n   ", "fn": "decimal_to_binary", "para": "(int decimal)", "type": "string", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_length(string s){\n    int max_length = 0;\n    for (int i=0;i<s.length", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_length(string s){\n    int max_length=0;\n    for (int i=0;i<s.length();i", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": true}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"t(result==1);\n}/test/test_100.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint num_of_1(int n){\n    int result=0;\n    while (n){\n        result++;", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return count", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_length(string s){\n    int max_length=0;\n    for (int i=0;i<s.length();", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max_consecutive_ones = 0;\n    int current_consecutive_ones", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max_consecutive_ones=0;\n    int current_consecutive_ones=", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint numJewelsInStones(string J, string S) {\n    int result=0;\n    for (int i=0;i<S", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/80", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_happy(string s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\nint main(){\n\tauto result = is_happy(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567890\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max_consecutive_ones=0;\n    int current_consecutive_ones=", "fn": "is_happy", "para": "(string s)", "type": "bool", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001, 0.7001, 1.0001, 1.3001, 1.7001, 2.0001, 2.3001, 2.7001, 3.0001, 3.3001, 3.7001, 3.9999});\n\tassert(", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001, 1.0001, 1.3001, 1.7001, 2.0001, 2.3001, 2.7001, 3.0001, 3.3001, 3.7001, 3.9999});\n\tassert(issame(result,{\"E\",", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0});\n\tassert(issame(result,{\"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"E\"}));\n\tresult = numerical_letter_grade", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.999", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,0.7001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,0.7001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,0.7001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,0.7001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,0.7001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9});\n\tassert(issame(result,{\"E\",\"D-\",\"C-\",\"C\",\"C+\",\"B-\",\"B\",\"B+\",\"A-\",\"A\",\"A+\"}));\n\tresult = numerical", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0,0.7,1.3,1.7,2.0,2.3,2.7,3.0,3.3,3.7,3.9});\n\tassert(issame(result,{\"E\",\"D-\",\"C-\",\"C\",\"C+\",\"B-\",\"B\",\"B+\",\"A-\",\"A\",\"A+\"}));\n\tresult = numerical_letter_grade({0.0,0", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0,0.7,1.3,1.7,2.0,2.3,2.7,3.0,3.3,3.7,3.9});\n\tassert(issame(result,{\"E\",\"D-\",\"C-\",\"C\",\"C+\",\"B-\",\"B\",\"B+\",\"A-\",\"A\",\"A+\"}));\n\tresult = numerical_letter_grade({0.0,0", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0,0.7,1.3,1.7,2.0,2.3,2.7,3.0,3.3,3.7,3.9});\n\tassert(issame(result,{\"E\",\"D-\",\"C-\",\"C\",\"C+\",\"B-\",\"B\",\"B+\",\"A\",\"A+\",\"A+\"}));\n\tresult = numerical_letter_grade({0.0,0", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\",\"D-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0,0.7,1.3,1.7,2.0,2.3,2.7,3.0,3.3,3.7,3.9});\n\tassert(issame(result,{\"E\",\"D-\",\"C-\",\"C\",\"C+\",\"B-\",\"B\",\"B+\",\"A-\",\"A\",\"A+\"}));\n\tresult = numerical_letter_grade({0.0,0", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3.9,3.7,3.3,3.0,2.7,2.3,2.0,1.7,1.3,1.0,0.7,0.0}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999)", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3.9,3.7,3.3,3.0,2.7,2.3,2.0,1.7,1.3,1.0,0.7,0.0};\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"}));\n}#include<stdio.h>\n#include<math", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3.9999,3.7001,3.3001,3.0001,2.7001,2.3001,2.0001,1.7001,1.3001,1.0001,0.7001,0.0001}t> out={};\n    for (int i=0", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3.9,3.7,3.3,3.0,2.7,2.3,2.0,1.7,1.3,1.0,0.7,0.0}  }\n    return out;\n}\nint main(){\n\tauto result = find_all_factors(10);\n\tassert(issame(result,{1,2,5,10}));\n}/", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"A+\",\"B\",\"C-\",\"C\",\"A-\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3.9,3.7,3.3,3.0,2.7,2.3,2.0,1.7,1.3,1.0,0.7,0.0}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999)", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9} 0;\n}/1000/1000.cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint a,b;\n\t", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"D\",\"D-\",\"C-\",\"B\",\"B+\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0, 0.7, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3, 3.7, 3.9}t> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"D\",\"D+\",\"C-", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001,1.0001,1.3001,1.7001,2.0001,2.3001,2.7001,3.0001,3.3001,3.7001,3.9999});\n\tassert(issame(result,{\"E\",\"D-\",\"D\",\"D+\",\"C-", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001, 0.7001, 1.0001, 1.3001, 1.7001, 2.0001, 2.3001, 2.7001, 3.0001, 3.3001, 3.7001, 3.9999});\n\tassert(", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001, 0.7001, 1.0001, 1.3001, 1.7001, 2.0001, 2.3001, 2.7001, 3.0001, 3.3001, 3.7001, 3.9999});\n\tassert(", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/81", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\nint main(){\n\tauto result = numerical_letter_grade(<FILL_ME>);\n\tassert(issame(result,{\"E\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0.0001});\n\tassert(issame(result,{\"E\"}));\n\tresult = numerical_letter_grade({0.0001,0.0001});\n\tassert(issame(result,{\"E\",\"E\"}));\n\tresult = numerical_letter_grade({0.0001,0.0001,0.0001});\n\tassert(issame(result,", "fn": "numerical_letter_grade", "para": "(vector<float> grades)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567891011\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0){\n        count++;\n        n/=10;", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": true}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567891011\"\n\tassert(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": true}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567891011\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567891011\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.spiralOrder(v);\n\tfor (auto i:result)\n\t\tcout<<i<<\"", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/82", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool prime_length(string str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\nint main(){\n\tauto result = prime_length(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234567891011\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0){\n        count++;\n        n/=10;", "fn": "prime_length", "para": "(string str)", "type": "bool", "pass": true}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": true}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;i", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;i", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;i", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint out=0;\n\tfor (int i=0;i<n;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tout+=a", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t}\n\treturn 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b)!=EOF){\n\t\tif (a", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==1800);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;i<=", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_one(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=0;\n    while (n>0){\n        if (n%10==1)", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iostream>\n#include", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b)!=EOF){\n\t\tprintf(\"%d\\n", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_power_of_two(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=1;\n    while (out<n){\n        out=out*2", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n/leetcode/1011.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint shipWithinDays(int* weights, int weightsSize, int D) {\n\tint max_weight = 0;\n\tint sum = 0;\n", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==18000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}/cpp/10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_one(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=0;\n    while (n>0){\n        if (n%10==1)", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    if (n==2) return 1;\n    if (n%2==0) return 0;\n    for (int i=3;", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint out=0;\n\tfor (int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif (x", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/83", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint starts_one_ends(int n){\n    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\nint main(){\n\tauto result = starts_one_ends(<FILL_ME>);\n\tassert(result==180);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}/test/test_is_one_bit_character.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_one_bit_character(int* bits, int bitsSize){\n    int i=0;\n    while(i<bitsSize){\n        if (bits[i]==", "fn": "starts_one_ends", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/CodeForces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,k,i,j,a[100000];\n    scanf(\"%d", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,k,i,j,a[100000];\n    scanf(\"%d%", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,a[100000];\n    cin>>n>>k;\n    for (int i=0;i<n;i++)\n        cin>>a[i];\n    for (int i=0", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/Codeforces/1100/1100A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    int a[n],b[m];\n    for (int i=0;i<n;i++)\n        cin>>a[i];\n    for", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"110\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,m,k,i,j,a[100000],b[1", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1  }\n    return 0;\n}/Codeforces/1101/A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,a,b,c,d;\n    cin>>n>>a>>b>>c>>d;\n    if (a+b==c+d){\n        cout<<\"YES\";\n    }\n    else{\n        cout<<\"NO\";\n  /Code", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,a[100000],i,j,count=0;\n    cin>>n>>k;\n    for (i=0;i<n;i++)\n        cin>>a[i];\n   ", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1 1;\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,i,j,k,l,m,a[100000],b[100000],c[10", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1;\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int i,sum=0;\n    for (int i=0;i<numsSize;i", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/CodeForces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solve(int N,int M,int K){\n    int i,j,sum=0;\n    for", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,k,i,j,a[100000];\n    scanf(\"%d%", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/leetcode/121.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint maxProfit(vector<int>& prices) {\n    int min=prices[0],max=0;\n    for (int i=0;i<", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"10010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/leetcode/1221.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint balancedStringSplit(string s){\n    int count=0,result=0;\n    for (int i=0;i<s.length", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\t\t}\n\t\t}\n\t\tif (flag)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}/Codeforces/Codeforces Round #559 (Div. 2)/A.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int i,sum=0;\n    for (i=0;i<numsSize;i++)", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int i,sum=0;\n    for (i=0;i<numsSize;", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int i,sum=0;\n    for (i=0;i<numsSize;i++)", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "13\n\tassert(result==1);\n}/leetcode/1221.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint balancedStringSplit(string s){\n    int count=0,result=0;\n    for (int i=0;i<s.length();", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "13  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,k,i,j,a[100000];\n    scanf(\"%d%", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "17\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int i,sum=0;\n    for (i=0;i<numsSize;i", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "17  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n,m,a,b;\n    scanf(\"%d%d\",&n,&m);\n    for (", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/84", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"1001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "13  }\n    return 0;\n}/CodeForces/118A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    string str;\n    getline(cin,str);\n    for (int i=0;i<str.length();i++)\n   ", "fn": "solve", "para": "(int N)", "type": "string", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{1,2,3,4,5,6,7,8,9,10} 1;\n\t}\n\treturn 0;\n}\n/1001-1050/1006.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==122);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}/1000/1000.cpp\n#include<stdio.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d %d\",&a,&b);\n\tprintf(\"%d\",a+b);\n\treturn;\n\t}\n\treturn 0;", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.add(v);\n\tassert(result==12);\n", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\t}\n\t\t}\n\t}\n\treturn 0;\n}/1001.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int>", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000007;\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tint ans = 0;\n\tfor (int i = 0;", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n   ", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==0);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==0);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t main(){\n\tauto result = add({1,2,3,4,5,6,7,8,9,10});\n\tassert(result==0);\n}/test/test.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/85", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\nint main(){\n\tauto result = add(<FILL_ME>);\n\tassert(result==88);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add(vector<int> lst){\n    int sum=0", "fn": "add", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiMyaemnisMeirst.RbootHowaer?ouy\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out++;\n        n=n", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiMyaemnisMeirst.RbootHowaer?ouy\";\n\tassert(result==1);\n}/test/test_count_ones.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiMyaemnisMeirst.RbootHowaer?ouy\"t.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiMyaemnisMeirst.RbootHowaer?ouy\"t.push_back(i);\n        }\n    }\n    return out;\n}\nint main(){\n\tauto result = find_all_factors(10);\n\tassert(result.size()==4);\n\tassert(result[0]==1);\n\tassert(result[1]==2);\n\tassert(result[2]==5);\n\tassert(", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\".HiMyaemnisMeirst.RbootHowaer?ouy\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiMyaemnisMeirst.RbootHowaer?ouy\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hi\"  }\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(\"Hi\");\n\tassert(result==\"Hi\");\n}/anti_shuffle.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hi\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}\n", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hi\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n/2;\n    }\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hi\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count++;\n        n=n&(n-1);\n    }\n    return count;", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hi\"  }\n    return out;\n}\nint main(){\n\tauto result = reverse_words(\"Hi there!\");\n\tassert(result==\"!ereht iH\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring reverse_words(string s){\n    string out=\"\";\n    string", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"dcba\"\n\tassert(result==1);\n}/100/100.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 100;/10000000000000", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"dcba\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count++;\n        n=n&(n-1);\n    }\n    return count", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abdc\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out=out+n%2;\n        n=n/2;\n    }\n    return", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"dcba\"t(result==1);\n}/test/test_100.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1)", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"abcd\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abdc\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count++;\n        n=n&(n-1);\n    }\n    return count;\n}", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tauto result = Solution().findMedianSortedArrays(vector<int>{1,3},vector<int>{2});\n\tassert(result==2);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count++;\n        n=n&(n-1);\n    }\n    return count;", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    if (n%i==0)", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count=count+n%2;\n        n=n/2;\n    }\n    return count", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"ehllo\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n/2;", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!!!Wdlor\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out=out+n%2;\n        n=n/2;\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!!!Wdlor\"  }\n    return out;\n}\nint main(){\n\tauto result = remove_duplicates(\"Hello World\");\n\tassert(result==\"Helo Wrd\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring remove_duplicates(string s){\n    string out", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!!!Wdlor\"  }\n    return out;\n}\nint main(){\n\tauto result = reverse_words(\"Hello World\");\n\tassert(result==\"World Hello\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring reverse_words(string s){\n    string out=\"\";\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!!!Wdlor\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"Hello!!!Wdlor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello!!!Wdlor\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = anti_shuffle(\"a\");\n\tassert(result==\"a\");\n\tresult = anti_shuffle(\"ab\");\n\tassert(result==\"ba\");\n\tresult = anti_shuffle(\"abc\");\n\tassert(result==\"cba\");\n\tresult = anti_shuffle(\"abcd\");\n\tassert(result==\"dcba\");\n\tresult = anti_shuffle(\"abcde\");\n\tassert(result==\"ed", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = anti_shuffle(\"a\");\n\tassert(result==\"a\");\n\tresult = anti_shuffle(\"ab\");\n\tassert(result==\"ba\");\n\tresult = anti_shuffle(\"abc\");\n\tassert(result==\"cba\");\n\tresult = anti_shuffle(\"abcd\");\n\tassert(result==\"dcba\");\n\tresult = anti_shuffle(\"abcde\");\n\tassert(result==\"ed", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = anti_shuffle(\"a\");\n\tassert(result==\"a\");\n\tresult = anti_shuffle(\"ab\");\n\tassert(result==\"ba\");\n\tresult = anti_shuffle(\"abc\");\n\tassert(result==\"cba\");\n\tresult = anti_shuffle(\"abcd\");\n\tassert(result==\"dcba\");\n\tresult = anti_shuffle(\"abcde\");\n\tassert(result==\"ed", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = anti_shuffle(\"a\");\n\tassert(result==\"a\");\n\tresult = anti_shuffle(\"ab\");\n\tassert(result==\"ab\");\n\tresult = anti_shuffle(\"abc\");\n\tassert(result==\"cba\");\n\tresult = anti_shuffle(\"abcd\");\n\tassert(result==\"dcba\");\n\tresult = anti_shuffle(\"abcde\");\n\tassert(result==\"ed", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = anti_shuffle(\"a\");\n\tassert(result==\"a\");\n\tresult = anti_shuffle(\"ab\");\n\tassert(result==\"ba\");\n\tresult = anti_shuffle(\"abc\");\n\tassert(result==\"cba\");\n\tresult = anti_shuffle(\"abcd\");\n\tassert(result==\"dcba\");\n\tresult = anti_shuffle(\"abcde\");\n\tassert(result==\"ed", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"bemnru\"  }\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(\"bemnru\");\n\tassert(result==\"bemnru\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"bemnru\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n/2;\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"bemnru\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out=out+(n%2);\n        n=n/2;", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"bemnru\"t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<assert.h>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/86", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring anti_shuffle(string s){\n    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\nint main(){\n\tauto result = anti_shuffle(<FILL_ME>);\n\tassert(result==\"bemnru\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"bemnru\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n/2;\n   ", "fn": "anti_shuffle", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(result.size()==2);\n\tassert(result[0][0]==1);\n\tassert(result[0][1]==1);\n\tassert(result[1][0]==1);\n\tassert(result[1][1]==2);\n\tauto result2 = get_row(vector<vector<int>>{}, 5);", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(result.size()==1);\n\tassert(result[0][0]==1);\n\tassert(result[0][1]==1);\n\tauto result2 = get_row( {{1,2,3},{4,5,6},{7,8,9}}, 10);\n\tassert(result2.size()==0);", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(result.size()==1);\n\tassert(result[0][0]==1);\n\tassert(result[0][1]==1);\n\tauto result2 = get_row( {{1,2,3},{4,5,6},{7,8,9}}, 10);\n\tassert(result2.size()==0", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(result.size()==2);\n\tassert(result[0][0]==1);\n\tassert(result[0][1]==1);\n\tassert(result[1][0]==1);\n\tassert(result[1][1]==2);\n\tauto result2 = get_row( {{1,2,3},{4,5", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassertresult;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(result.size()==1);\n\tassert(result[0][0]==1);\n\tassert(result[0][1]==1);\n\tauto result2 = get_row({{1,2,3},{4,5,6},{7,8,9}}, 10);\n\tassert(result2.size()==0", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{{0,0}}));\n\tresult = get_row( {{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(issame(result,{{1,1},{1,2}}));\n\tresult = get_row( {{1,2,3", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{{0,0}}));\n\tresult = get_row({{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(issame(result,{{1,1},{1,2}}));\n\tresult = get_row({{1,2,3},{4", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9);\n\tassert(issame(result,{{2,2}}));\n\tresult = get_row({{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{{1,2,3},{4,5,6},{7,8,9}});\n\tresult = get_row({{", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{{0,0}}));\n\tresult = get_row( {{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(issame(result,{{1,1},{1,2}}));\n\tresult = get_row( {{1,2,3", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{{0,0}}));\n\tresult = get_row( {{1,2,3},{4,5,6},{7,8,9}}, 5);\n\tassert(issame(result,{{1,1},{1,2}}));\n\tresult = get_row( {{1,2,3", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9t(result, 1);\n}/cpp/100000000000000000000000000000000000000000000000000000000000000", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9t(result,{{1,2,3},{4,5,6},{7,8,9}});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9t(result,{{1,2,3},{4,5,6},{7,8,9}});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9t(result, 1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_count(vector<int> lst){\n    int out=0;\n    for (int i=0;", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/87", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\nint main(){\n\tauto result = get_row(<FILL_ME>);\n\tassert(issame(result,{{2,2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 9t(result, 10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_sum(int n){\n    int out=0;\n    for (int i=1;i<=", "fn": "get_row", "para": "(vector<vector<int>> lst, int x)", "type": "vector<vector<int>>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{23,21,14,11});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({11,14,21,23});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({23,21,14,11});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{23,21,14,11});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({11,14,21,23});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({23,21,14,11});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,23,14,21} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{23,21,14,11});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({11,14,21,23});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({23,21,14,11}t(", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{23,21,14,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{23,21,14,11});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({11,21,14,23});\n\tassert(issame(result,{11,14,21,23}));\n\tresult = sort_array({23,21,14,11});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7};\n\tassert(issame(result,{1,2,3,4,5,6,7}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6,5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5,6}));\n\tresult = sort_array({1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5,6}));\n\tresult = sort_array({1,3,5,7});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7});\n\tassert(issame(result,{0,1,2,3,4,5,6,7}));\n\tresult = sort_array({1,3,5,7,2,4,6,0});\n\tassert(issame(result,{0,1,2,3,4,5,6,7}));\n\tresult = sort_array({1,2", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6,5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5,6}));\n\tresult = sort_array({1,2,3,4,5,6,7});\n\tassert(issame(result,{1,2,3,4,5,6,7}));\n\tresult = sort_array({0,1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{6,5,4,3,2,1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6,5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5,6}));\n\tresult = sort_array({1,2,3,4,5,6});\n\tassert(issame(result,{1,2,3,4,5,6}));\n\tresult = sort_array({1,3,5,7});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,0,32,42,87,15}t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int num){\n    int count=0;\n    while (num!=0)\n    {\n        num/=10", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,0,32,42,87,15} 100000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,0,32,42,87,15}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,0,32,42,87,15} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tcout<<solve(a,n);\n}/Codeforces/100", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,11,15,32,42,87}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{11,0,32,42,87,15}t(result,100);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0)\n    {\n        n/=1", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1});\n\tassert(issame(result,{1}));\n\tresult = sort_array({1,2});\n\tassert(issame(result,{1,2}));\n\tresult = sort_array({1,2,3});\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array({1,2,", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1});\n\tassert(issame(result,{1}));\n\tresult = sort_array({1,2});\n\tassert(issame(result,{1,2}));\n\tresult = sort_array({2,1});\n\tassert(issame(result,{1,2}));\n\tresult = sort_array({1,2,3});\n\t", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(issame(result,{1,2,3,4", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = sort_array({5,4,3,2,1});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = sort_array({1,3,5", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,8,1,4}t(result,1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count+=", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,8,1,4}t(result,1);\n}/cpp/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0)\n    {\n       ", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,8,1,4} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> a(n);\n\tfor (int i=0;i<", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,8,1,4} 1; i < n; i++) {\n        if (nums[i] > nums[i - 1]) {\n            count++;\n        } else {\n            count = 1;\n        }\n        max = max > count? max : count;\n    }\n    return max;\n}\nint main() {\n    vector<int> nums = {1, 3, 5, 4,", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,3,2,8,1,4} 1; i < n; i++) {\n        if (nums[i] > nums[i - 1]) {\n            count++;\n        } else {\n            count = 1;\n        }\n        max = max > count? max : count;\n    }\n    return max;\n}\nint main() {\n    vector<int> nums = {1, 3, 5, 4,", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{5,4,3,2,1,0}t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5});\n\tassert(issame(result,{5,4,3,2,1,0}));\n\tresult = sort_array({5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5}));\n\tresult = sort_array({0,1,2,3,4,5});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5});\n\tassert(issame(result,{5,4,3,2,1,0}));\n\tresult = sort_array({5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5}));\n\tresult = sort_array({0,1,2,3,4,5});\n\tassert(iss", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5});\n\tassert(issame(result,{5,4,3,2,1,0}));\n\tresult = sort_array({5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5}));\n\tresult = sort_array({1,2,3,4,5});\n\tassert(issame(", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/88", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> array){\n    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,3,4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5});\n\tassert(issame(result,{5,4,3,2,1,0}));\n\tresult = sort_array({5,4,3,2,1,0});\n\tassert(issame(result,{0,1,2,3,4,5}));\n\tresult = sort_array({1,2,3,4,5});\n\tassert(issame(", "fn": "sort_array", "para": "(vector<int> array)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\";\n\tassert(result==10);\n}/leetcode/121.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint maxProfit(vector<int>& prices) {\n    int i,j,k;\n    int max=0;\n    for", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"t(result==10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tasser/test/test_11.cpp\n#include", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}/cpp/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=1;i<=n;i++)\n    {\n        if (i*i==n)\n        {\n            return", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=1;i<=n;i++)\n    {\n        if (i*i==n)\n        {\n           ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"lippsqcjvmirh\");\n}/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=1;i<=sqrt(n);i++)\n    {\n        if (n%i==0)\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lippsqcjvmirh\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findComplement(int num) {\n    int i;\n    int out=0;\n    for (i=0;i<32;i++)\n    {\n        if ((num&(1<<", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=2;i<=sqrt(n);i++)\n    {\n        if (n%i==0)\n        {\n            return 0;\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abc\");\n\tassert(result==\"ix\");\n}/cpp/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int i;\n    int out=0;\n    for (i=0;i<nums", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}/test/", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"ewhjklnop\");\n}/cpp/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_consecutive_ones(int n){\n    int max=0;\n    int count=0;\n    while(n>0){\n        if(n%2==1", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"ewhjklnop\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int a[],int n,int x){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (a[i]==x)\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(int* nums, int numsSize){\n    int i,max=0,count=0;\n    for (i=0;i<numsSize;i", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;\n        }\n   ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"\n\tassert(result==1);\n}/leetcode/1013.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint numPairsDivisibleBy60(vector<int>& time) {\n    int i,j,count=0;\n    for (i=0", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": true}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"e\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1) return 0;\n    int i;\n    for (i=2;i<=sqrt(n);i++)\n    {\n        if (n%", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"jeiajeaijeiak\");\n}/cpp/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int i;\n    int out=0;\n    for (i=0;", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abcdefghijklmnopqrstuvwxyz\");\n\tassert(result==\"jeiajeaijeiak\");\n}/C++/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        count++;\n        n/=10;\n    }\n    return count;\n}\nint", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"jeiajeaijeiak\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcdefghijklmnopqrstuvwxyz\"t(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=2;i<=sqrt(n);i++)\n    {\n        if (n%i==0)\n        {\n            return ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    int count=0;\n    for (i=1;i<=n;i++)\n    {\n        if (n%i==0)\n        {", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"  }\n    return out;\n}\nint main(){\n\tauto result = encrypt(\"abc\");\n\tassert(result==\"lm\");\n}/encrypt.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(int* nums, int numsSize){\n    int i;\n    int max=0;\n    int count=0;\n    for (i=0;i<nums", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"lm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ab\");\n\tassert(result==\"ef\");\n\tresult = encrypt(\"lm\"t(result==1);\n}/test/test_1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1000;\n\t", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(int* nums, int numsSize){\n    int i,max=0,count=0;\n    for (i=0;i<numsSize;i", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=0;i<n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=1;i<=n;i++)\n    {\n        if (i*i==n)\n        {\n            return 1;\n       ", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(int* nums, int numsSize){\n    int i,max=0,count=0;\n    for (i=0;i<numsSize;i", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/89", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring encrypt(string s){\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encrypt(<FILL_ME>);\n\tassert(result==\"kj\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find(int n){\n    int i;\n    for (i=1;i<=n;i++)\n    {\n        if (i*i>n)\n        {\n            return i-1", "fn": "encrypt", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0){\n        count+=n", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0){\n        count+=n", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==-35);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/90", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint next_smallest(vector<int> lst){\n    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\nint main(){\n\tauto result = next_smallest(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "next_smallest", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\" 1;\n\t}\n\treturn 0;\n}\n/CodeForces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\"t(result==1);\n}/test/test_is_bored.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored\" 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&a", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored\" 1;\n\t}\n\treturn 0;\n}\n/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d%", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\" 1;\n\t}\n\treturn 0;\n}\n/CodeForces/1101/A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    {\n        if (", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am very bored.\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string S){\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored yet. I am not bored yet. I am not bored yet.\" 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    int a[n];\n    for (int i=0;i<n;i++) cin", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\"  }\n    return sum;\n}\nint main(){\n\tauto result = sum_of_cubes(4);\n\tassert(result==225);\n}/sum_of_cubes.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/91", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_bored(string S){\n    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\nint main(){\n\tauto result = is_bored(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"I am not bored.\" 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>", "fn": "is_bored", "para": "(string S)", "type": "int", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0);\n\tassert(result==true);\n\tresult = any_int(1.0,1.0,2.0);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,2.0);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,3.0);\n\tassert(", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": true}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,2.0,3.0);\n\tassert(result==true);\n\tresult = any_int(1.0,2.0,4.0);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,3.0);\n\tassert(result==true);\n\tresult = any_int(1.0,2.0,3.0);\n\tassert(", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0);\n\tassert(result==true);\n\tresult = any_int(1.0,1.0,2.0);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,1.0);\n\tassert(result==false);\n\tresult = any_int(2.0,1.0,1.0\n\t", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": true}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,2.0,3.0);\n\tassert(result==true);\n\tresult = any_int(1.0,2.0,3.1);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,3.0000000000000000000000000000000000", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,2.0,3.0);\n\tassert(result==true);\n\tresult = any_int(1.0,2.0,3.1);\n\tassert(result==false);\n\tresult = any_int(1.0,2.0,3.0000000000000000000000000000000000", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/92", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool any_int(float a,float b,float c){\n    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\nint main(){\n\tauto result = any_int(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1.0,1.0,1.0\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n!=0){\n        count+=n&1;\n        n>>=1;\n    }\n    return count;", "fn": "any_int", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ThiS is String\"t(result==10);\n}/cpp/10000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Codewars\" 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ThiS is String\" 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"This is a test!\"t(result==10);\n}/cpp/100000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tHKSKSCMGSSCGG\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ThiS is a test\" 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_cubes(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++)\n    {\n        sum=sum+pow(i,", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_cubes(int n){\n    int sum=0;\n    for (int i=1;i<=n;i++)\n    {\n        sum=sum+pow(", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"t(result==10);\n}/cpp/10000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"t(result==10);\n}/cpp/10000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"kdQnTkNqWwHcTTqwRkTg\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Hello World\"t(result==10);\n}/cpp/100-199/100-109/108.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr[],int n){\n    int sum=0;", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"test\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int sum1=0,sum2=0;\n    for (int i=0;i<n;i++)", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"test\" 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long int", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"test\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int sum1=0,sum2=0;\n    for (int i=0;i<n;i++)\n    {", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"test\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int sum1=0,sum2=0;\n    for (int i=0;i<n;i++)\n    {", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"tgst\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"test\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int i=0;\n    int j=0;\n    while (i<n and j<n){\n        if", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"codewars\"t(result==10);\n}/cpp/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0)", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Codewars\"\n\tassert(result==1);\n}/cpp/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Codewars\"\n\tassert(result==1);\n}/cpp/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Codewars\"t(result==10);\n}/cpp/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0){", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"mWDCSKR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"codewars\"t(result==10);\n}/cpp/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0)", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"code\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int sum1=0,sum2=0;\n    for (int i=0;i<n;i++)\n    {", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Ygs\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr1[], int arr2[], int n){\n    int i=0;\n    while (i<n){\n        if (arr1[i]!=arr2", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ygs\" 1000000000;\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_next_square(int sq) {\n    int sqr=sqrt(sq);", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"ygs\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_outlier(int arr[]){\n    int odd=0;\n    int even=0;\n    for (int i=0;i<3;i++)\n    {\n        if (arr[", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/93", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring encode(string message){\n    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\nint main(){\n\tauto result = encode(<FILL_ME>);\n\tassert(result==\"ygs\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_outlier(int arr[]){\n    int odd=0;\n    int even=0;\n    for (int i=0;i<3;i++)\n    {\n        if (arr[i", "fn": "encode", "para": "(string message)", "type": "string", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/cpp/2019/02/2019-02-01-1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/2018/2018-03-18/2018-03-18-1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(int n){\n    int sum=0;\n    for (", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==11);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/2019/01/01.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjk", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\tassert(result==1);\n}/2016/2016-06-01/2016-06-01-1.cpp\n#", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}t(result==1);\n}/2018/02/2018-02-06-2018-02-12/2018-", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20} 1000000000000000000;\n\tassert(result==100000000000000000", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20} 1000000000000000000;\n\tassert(result==100000000000000000", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==19);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\tassert(result==10);\n}/2019/01/01.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}/skjkasdkd.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==10);\n}/skjkasdkd.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}/2019/10/20191010/20191010_2.cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> lst(n);", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==10);\n}/skjkasdkd.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(int n){\n    int sum=0;\n    string s;\n    s", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/2018/01/01.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sk", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/cpp/10001stPrime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkas", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/cpp/2017/01/11.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/2019/01/01.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sk", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/94", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n\tauto result = skjkasdkd(<FILL_ME>);\n\tassert(result==13);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "skjkasdkd", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}/C++/1001.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> v;\n    for (int i=0;i<n;i++){\n        int x;\n        cin>>x;\n        v.push_back", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t_case(dict);\n\tassert(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,is", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t_case(dict);\n\tassert(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,is", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1;\n\t}\n\treturn 0;\n}\n/C++/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i=0;\n", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t_case(dict);\n\tassert(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,is", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/95", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool check_dict_case(map<string,string> dict){\n    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\nint main(){\n\tauto result = check_dict_case(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d", "fn": "check_dict_case", "para": "(map<string,string> dict)", "type": "bool", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/cpp/count_up_to.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,10);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int>", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=0;i<n;i++)\n       ", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=0;i<n;", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,10);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n   ", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (i=0;i<n;i++) scanf(\"%d\",&a[i", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}/2020/2020-03-03/2020-03-03.cpp\n#include<stdio.h", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\tvector<int> a(n);\n\tfor (i=0;i<n;i++) scanf(\"%d", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100 0;\n}/100/100.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint i,j;\n\tint sum=0;\n\tfor (i=1;i<1000;i++)\n\t\t", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/2019/2019-09-19/2019-09-19-1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start, int end){\n    vector<int> out={", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "20t(result,{1,2,3,4,5,6,7,8,9,10});\n}/cpp/1000000000000000000000000000000000000000000000000000000000000000", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "20\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "20t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int start,int end){\n    vector<int> out={};\n    int i;\n    for", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "20t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}/count_up_to.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "20\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=0;\n    while (n>0) {\n        out+=n%10;\n        n/=10;\n    }\n    return out", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "43t(result,10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=0;\n    while (n>0) {\n        out+=n%10;\n        n", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "43 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tint a[n];\n\tfor (i=0;i<n;i++) scanf(\"%d\",&", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3}));\n}/cpp/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3}));\n}/test/test_reverse_list.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> reverse_list(vector<int> list){\n    vector<int> out={};\n    int i", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> range(int n){\n    vector<int> out={};\n    int i;\n    for (i=0;i<n;i++)\n        out", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/96", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> count_up_to(int n){\n    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\nint main(){\n\tauto result = count_up_to(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,", "fn": "count_up_to", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,42\n\tassert(result==12);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint divide(int a,int b){\n    return (abs(a)/abs(b));\n}\nint main(){\n\tauto result = divide(12,4);\n\tassert(", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,42\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(int n) {\n    int count = 0;\n    while(n){\n        count++;\n        n = n&(n-1);\n    }\n    return count;\n}\nint main(){", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n>0)&&(n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(1", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,42\n\tassert(result==12);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint addDigits(int num) {\n    int sum = 0;\n    while(num){\n        sum += num%10;\n        num /= 10;\n    }\n    if(sum>=10)", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==42);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tvector<int> result = s.productExceptSelf(nums);\n\tfor(auto i:result){\n\t\tcout<<i<<\" \";\n\t}", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,20;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return n>0 &&!(n&(n-1));\n}\nint main(){\n\tauto result = isPowerOfTwo(16)\t", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);\n\tassert(result==", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": true}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,20\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDuplicates(nums);\n\tfor(auto i:result){\n\t\tcout<<i<<endl;\n\t}\n}#", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);\n\tasser", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint divide(int dividend,int divisor){\n    if(dividend==0) return 0;\n    if(divisor==0) return 0;\n    if(dividend==INT_MIN&&div", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": true}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v = {1,2,3,4,5,6,7,8,9};\n\tauto result = s.spiralOrder(v);\n\tfor(auto i:result){\n\t\tcout<<i<<\" \";\n\t}\n\tcout<<endl;", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,16\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int result = 0;\n    for(int i=0;i<numsSize;i++){\n        result", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,16\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);t(result", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return n>0 && (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,16;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);\n", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,23\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result = isPowerOfTwo(16);\n\tassert", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,23\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return (n>0)&&!(n&(n-1));\n}\nint main(){\n\tauto result = isPowerOfTwo(16);", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,23\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tvector<int> result = s.findDisappearedNumbers(nums);\n\tfor(auto i:result){\n\t\tcout<<i<<\" \";\n\t}", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,23;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint divide(int a,int b){\n    if(a<b) return 0;\n    int count = 1;\n    int temp = b;\n    while(temp+temp<=a){\n        temp+=", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==72);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,23\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9};\n\tvector<int> result = s.productExceptSelf(nums);\n\tfor(auto i:result){\n\t\tcout<<i<<\" \";\n\t}\n\tcout<<endl", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,20;\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint divide(int a,int b){\n    return (abs(a)/abs(b));\n}\nint main(){\n\tauto result = divide(10,2)\n\tassert", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,20\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return n>0 &&!(n&(n-1));\n}\nint main(){\n\tauto result = isPowerOfTwo(16);\n\tassert(result", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,20\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while(n){\n        count++;\n        n = n&(n-1);\n    }\n    return count;\n}", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,20\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while(n){\n        count++;\n        n = n&(n-1);\n    }\n    return count;\n}", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12,20\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int result = 0;\n    for(int i=0;i<numsSize;i++){\n        result", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n) {\n    if(n==0) return 0;\n    return (n&(n-1))==0;\n}\nint main(){\n\tauto result =", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "9,9\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while(n){\n        count++;\n        n &= (n-1);\n    }\n    return count;\n}\nint main", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while(n){\n        count++;\n        n = n&(n-1);\n    }\n    return count;", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,456\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return n>0 &&!(n&(n-1));\n}\nint main(){\n\tauto result = isPowerOfTwo(16);", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/97", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint multiply(int a,int b){\n    return (abs(a)%10)*(abs(b)%10);\n}\nint main(){\n\tauto result = multiply(<FILL_ME>);\n\tassert(result==49);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "-99,-99t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    return n>0 &&!(n&(n-1));\n}\nint main(){\n\tauto result = isPowerOfTwo(1);\n\tasser;", "fn": "multiply", "para": "(int a,int b)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"t(result==1);\n}/test/test_count_upper.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\");\n\tassert(result==0);\n\tresult = count_upper(\"aA\");\n\tassert(result==1);\n\tresult = count_upper(\"aAe\");\n\tassert(result==2);\n\tresult = count_upper(\"aAeI\");\n\tassert(result==3);\n\tresult = count_upper(\"aAeIo\");\n\tassert(result==4);\n\tresult = count_upper(\"aAeIo", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aeiou\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\");\n\tassert(result==1);\n\tresult = count_upper(\"AB\");\n\tassert(result==1);\n\tresult = count_upper(\"ABCD\");\n\tassert(result==1);\n\tresult = count_upper(\"ABCDAEIOU\");\n\tassert(result==5);\n\tresult = count_upper(\"ABCDAEIOUABCDAEIOU\"t(result==1);\n\t", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\");\n\tassert(result==0);\n\tresult = count_upper(\"AUE\");\n\tassert(result==1);\n\tresult = count_upper(\"AUEO\");\n\tassert(result==2);\n\tresult = count_upper(\"AUEOUI\");\n\tassert(result==3);\n\tresult = count_upper(\"AUEOUIO\");\n\tassert(result==4);\n\tresult = count_upper", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\");\n\tassert(result==0);\n\tresult = count_upper(\"AUE\");\n\tassert(result==2);\n\tresult = count_upper(\"AUEO\");\n\tassert(result==3);\n\tresult = count_upper(\"AUEOUI\"\n\tassert(result==1);\n\tresult = count_upper(\"AUEOUI\");\n\tassert(result==1);\n}#include", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\");\n\tassert(result==0);\n\tresult = count_upper(\"AUE\");\n\tassert(result==1);\n\tresult = count_upper(\"AUEO\");\n\tassert(result==2);\n\tresult = count_upper(\"AUEOUI\");\n\tassert(result==3);\n\tresult = count_upper(\"AUEOUIA\"\n\tassert(result==1);\n\tresult =", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": true}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aAeEiIoOuU\" 1;\n\t}\n\treturn 0;\n}\n/CodeForces/1000/1000A.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n,k;\n\tscanf(\"%", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Amazing\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abracadabra\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Amazing\" 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Amazing\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/98", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\nint main(){\n\tauto result = count_upper(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Amazing\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_upper(string s){\n    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if", "fn": "count_upper", "para": "(string s)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"-16.4\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int number, int digit){\n    int count=0;\n    while(number!=0){\n        if(number%10==digit){\n            count++;\n        }", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": true}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"-16.2\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_vowels(string str){\n    int count=0;\n    for(int i=0;i<str.length();i++){\n        if(str[i]=='", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": true}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"-16.1\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while(n){\n        if(n&1)\n            count++;\n        n=n>>1;\n    }\n   ", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": true}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"-16.4\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int number, int digit){\n    int count=0;\n    while(number!=0){\n        if(number%10==digit){\n            count++;\n        }", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": true}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==-16);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"-16.1\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result=s.findMedianSortedArrays(v,v);\n\tassert(result==5.5);\n}#include<vector>\n#include", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"15.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"15.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"15.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"15.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==15);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"15.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"10.5\"\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\t", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"10.5\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    if(n==2) return 1;\n    if(n%2==0) return ", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"10.5\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1) return 0;\n    if(n==2) return 1;\n    if(n%2==0)", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"10.5\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int value){\n    if(value==1) return 0;\n    for(int i=2;i<=sqrt(value);i++){\n        if(value", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/99", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\tauto result = closest_integer(<FILL_ME>);\n\tassert(result==10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"10.5\"\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint closest_integer(string value){\n    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\nint main(){\n\t", "fn": "closest_integer", "para": "(string value)", "type": "int", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t> out;\n    for (int i=0;i<n;i++){\n        out.push_back(i);\n    }\n    return out;\n}\nint main(){\n    auto result = make_a_list(3);\n    assert(issame(result,{0,1,2}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{3,5,7}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t.push_back(i);\n        }\n    }\n    return out;\n}\nint main(){\n    auto result = find_all_factors(10);\n    assert(issame(result,{1,2,5,10}));\n}/find_all_factors.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6\t\t}\n\t\t}\n\t\tif(i==0)\n\t\t\tbreak;\n\t}\n\treturn out;\n}\nint main(){\n\tauto result = find_all_factors(100);\n\tassert(issame(result,{1,2,4,5,10,20,25,50,100}));\n}/find_all_factors.cpp\n#include<stdio", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_list(int n){\n    vector<int> out;\n    for", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{6,8,10,12,14,16}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "6\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/2019/02/2019-02-19-1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{8,10,12,14,16,18,20,22}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "22t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=0;\n    while(n>0){\n        out+=n%10;\n        n/=10;\n    }\n    return out;\n", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{5,7,9,11,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,10);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while(n>0){\n        out++;\n        n/=10;\n    }\n    return", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/100", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\nint main(){\n\tauto result = make_a_pile(<FILL_ME>);\n\tassert(issame(result,{4,6,8,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> make_a_pile(int n){\n    vector<int> out", "fn": "make_a_pile", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"One, two, three, four, five, six\"t(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}/src/words_string.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"One, two, three, four, five, six\"  }\n    return out;\n}\nint main(){\n\tauto result = get_primes(100);\n\tassert(issame(result,{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"One, two, three, four, five, six\"t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"});\n}/test/test_words_string.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"One, two, three, four, five, six\"t_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' '){\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"One, two, three, four, five, six\"t>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = sum_of_digits(123);\n\tassert(result==6);\n}/sum_of_digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is \"t(result,{\"Hi\",\"my\",\"name\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is \"\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is \"\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}/C++/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is \"t>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = sum_of_digits(123);\n\tassert(result==6);\n}/sum_of_digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is \"  }\n    return out;\n}\nint main(){\n\tauto result = words_string(\"Hi, my name is \");\n\tassert(issame(result,{\"Hi\",\"my\",\"name\"}));\n}/C++/1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = words_string(\"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = words_string(\"a,b\");\n\tassert(issame(result,{\"a\",\"b\"}));\n\tresult = words_string(\"a,b,c\");\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = words_string(\"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = words_string(\"a,b\");\n\tassert(issame(result,{\"a\",\"b\"}));\n\tresult = words_string(\"a,b,c\");\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = words_string(\"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = words_string(\"a,b\");\n\tassert(issame(result,{\"a\",\"b\"}));\n\tresult = words_string(\"a,b,c\");\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = words_string(\"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = words_string(\"a,b\");\n\tassert(issame(result,{\"a\",\"b\"}));\n\tresult = words_string(\"a,b,c\");\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = words_string(\"a\");\n\tassert(issame(result,{\"a\"}));\n\tresult = words_string(\"a,b\");\n\tassert(issame(result,{\"a\",\"b\"}));\n\tresult = words_string(\"a,b,c\");\n\tassert(issame(result,{\"a\",\"b\",\"c\"}));\n\tresult = words_", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"ahmed, gamal\"t(result,{\"ahmed\",\"gamal\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"ahmed, gamal\";\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n   ", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"ahmed, gamal\";\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"ahmed, gamal\"t(result,{\"ahmed\",\"gamal\"});\n}/C++/string_split.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string>", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"ahmed\",\"gamal\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"ahmed, gamal\"t(result,{\"ahmed\",\"gamal\"});\n}/C++/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is John\"t>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = sum_of_digits(123);\n\tassert(result==6);\n}/sum_of_digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is John\"t(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is John\"\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is John\"t(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/101", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string s){\n    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\nint main(){\n\tauto result = words_string(<FILL_ME>);\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hi, my name is John\"\n\tassert(issame(result,{\"Hi\",\"my\",\"name\",\"is\",\"John\"}));\n}/C++/words_string.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> words_string(string", "fn": "words_string", "para": "(string s)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,14;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==-1);\n\tresult = choose_num(1,3);\n\tassert(result==2);\n\tresult = choose_num(2,3);\n\tassert(result==3);\n\tresult = choose_num(3,3);\n\tassert(result==3);\n\tresult = choose_", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,12354 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\",a+b);\n\t", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,12354 1000000007;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (sum % 2 == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tsum /= 2;", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123,12354 1;\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\t", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,12354 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&a[i", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==12354);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345,12354;\n\tassert(result==12345);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1)", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==2);\n\tresult = choose_num(2,3);\n\tassert(result==3);\n\tresult = choose_num(2,4);\n\tassert(result==4);\n\tresult = choose_num", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==-1);\n\tresult = choose_num(1,3);\n\tassert(result==2);\n\tresult = choose_num(1,4);\n\tassert(result==3);\n\tresult = choose_num(1,5);\n\tassert(result==4);\n\tresult = choose_", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,28 0;\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n\tint ans=0", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==28);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==-1);\n\tresult = choose_num(1,3);\n\tassert(result==2);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==3);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}/Codeforces/1000~1999/1000/A.cpp\n#include<iostream>\n#include<string>\n#include", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max_num(int x,int y){\n    if (x>y) return x;\n    return y;\n}\nint main(){\n\tauto result = find_max_num(1", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\t\t}\n\t\t}\n\t}\n\treturn 0;\n}/1001-1050/1009.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iostream>\n#", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==546);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\t\t}\n\t\t}\n\t\tif (flag==0) break;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}/20190810/1.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(2,4);\n\tassert(result==3);\n\tresult = choose_", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/102", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint choose_num(int x,int y){\n    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\nint main(){\n\tauto result = choose_num(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==-1);\n\tresult = choose_num(1,2);\n\tassert(result==1);\n\tresult = choose_num(2,2);\n\tassert(result==-1);\n\tresult = choose_num(2,3);\n\tassert(result==2);\n\tresult = choose_num(3,3);\n\tassert(result==-1);\n\tresult = choose", "fn": "choose_num", "para": "(int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(1,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(1,5);\n\tassert(result==\"1010\");\n\tresult = rounded_avg(1,6);\n\tassert(result==\"1010", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"110\");\n\tresult = rounded_avg(2,5);\n\tassert(result==\"1101\");\n", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"111\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(1,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(1,5);\n\tassert(result==\"1010\");\n\tresult = rounded_avg(1,6);\n\tassert(result==\"1010", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(1,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(1,5);\n\tassert(result==\"1010\");\n\tresult = rounded_avg(1,6);\n\tassert(result==\"1010", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"11111111111111111111111111111111111111111111111111111111111111111111111", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,11\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len) {\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n   ", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"11111111111111111111111111111111111111111111111111111111111111111111111", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"101101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,11\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100  }\n    return out;\n}\nint main(){\n\tauto result = find_even_index(new int[]{1,2,3,4,3,2,1});\n\tassert(result==3);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len) {\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n    {", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111100100\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len) {\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n   ", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"1111\",\"1111\");\n\tassert(result==\"11110\");\n}/binary_addition.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n       ", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"1111\",\"1111\");\n\tassert(result==\"11110\");\n}/binary_addition.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int n,int *arr){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1011000001\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n=n/10;", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1, 127t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        count+=n%2;\n        n=n/2;\n    }\n    return", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,127;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=arr[", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing_number(int arr[],int n){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=arr[", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,127\n\tassert(result==1);\n}/codewars/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11010111\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len){\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n    {\n       ", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"110\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"110\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"110\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"110\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"11\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(1,3);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"110\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int arr[],int n){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=arr[i", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": true}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10  }\n    return out;\n}\nint main(){\n\tauto result = sum_of_digits(10);\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int out=", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": true}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n=n/10", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": true}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10t(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10  }\n    return out;\n}\nint main(){\n\tauto result = find_missing_letter(new char[]{'a','b','c','d','f'});\n\tassert(result=='e');\n}/find_missing_letter.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len) {\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n    {\n       ", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_outlier(int arr[], int len) {\n    int odd=0,even=0;\n    for (int i = 0; i < len; i++)\n    {\n        if", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"110101101\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.runningSum(v);\n\tfor (auto i:result)\n\t{\n\t\tcout<<i<<\" \";\n\t}\n\tcout<<", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=arr", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int arr[],int n){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=arr[", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"11111111111111111111111111111111111111111111111111111111111111111111111", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100  }\n    return out;\n}\nint main(){\n\tauto result = find_missing_letter(new string[]{\"a\",\"b\",\"c\",\"d\",\"f\"});\n\tassert(result==\"e\");\n}/find_missing_letter.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1111001010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(int n,int a[]){\n    int sum=0;\n    for (int i = 0; i < n; i++)\n    {\n        sum+=a[i];", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100 1000000000000000000;\n\tassert(result==1000000000000000000);\n}/CodeWars/C++/7kyu/1000000000000000000.cpp\n#include<stdio.h>\n", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n/2;", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n=n", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"1001110010\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,100  }\n    return out;\n}\nint main(){\n\tauto result = binary_addition(\"1111111111111111111111111111111111111111111111111111111111111111111111", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==\"0\");\n\tresult = rounded_avg(1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(2,2);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult =", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==\"0\");\n\tresult = rounded_avg(1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(2,5);\n\tassert(result==\"1011\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==\"0\");\n\tresult = rounded_avg(1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(2,2);\n\tassert(result==\"10\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(2,4);\n\tassert(result==\"101\");\n\tresult =", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==\"0\");\n\tresult = rounded_avg(1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(4,5);\n\tassert(result==\"1011\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/103", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring rounded_avg(int n,int m){\n    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\nint main(){\n\tauto result = rounded_avg(<FILL_ME>);\n\tassert(result==\"-1\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,1);\n\tassert(result==\"0\");\n\tresult = rounded_avg(1,2);\n\tassert(result==\"1\");\n\tresult = rounded_avg(2,3);\n\tassert(result==\"11\");\n\tresult = rounded_avg(3,4);\n\tassert(result==\"101\");\n\tresult = rounded_avg(4,5);\n\tassert(result==\"1011\");\n\t", "fn": "rounded_avg", "para": "(int n,int m)", "type": "string", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{10,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{101,4,200,1,0,3,2,5,6});\n\tassert(issame(result,{1,2,3,5,6}));\n\tresult = unique_digits({11,111,12345,67890}  }\n    return out;\n}\nint main(){\n\tauto result = unique_digits({101,4,2", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{31,135}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{1,15,33}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{111,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{111,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{111,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{111,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{111,151}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{111,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19}));\n\tresult = unique_digits({1,2,3,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19}));\n\tresult = unique_digits({1,2,3,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19}));\n\tresult = unique_digits({1,2,3,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/104", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> unique_digits(vector<int> x){\n    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = unique_digits(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "unique_digits", "para": "(vector<int> x)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,2,3,4,5,5,8,8,8}t> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i+=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(arr[i]);\n    return out;\n}\nint main(){\n\tauto result = by_length", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,2,3,4,5,5,8,8,8}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/by_length.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,2,3,4,5,5,8,8,8}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/test/test_by_length.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,2,3,4,5,5,8,8,8} 100000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,2,3,4,5,5,8,8,8}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{9,4,1,8,7,5,6,3,2,0}t> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i+=1)\n        if (arr[i]%2==0)\n            out.push_back(arr[i]);\n    return out;\n}\nint main(){\n\tauto result = even_numbers({1,2,", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{9,4,1,8,7,5,6,3,2,0}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{9,4,1,8,7,5,6,3,2,0} 100000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{9,4,1,8,7,5,6,3,2,0}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{9,4,1,8});\n\tassert(issame(result,{\"Nine\",\"Eight\",\"Four\"}));\n\tresult = by_length({9,4,1,8,2,3,5,7,6,0}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/by_length.cpp\n#include<stdio.", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0} 0;\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint digital_root(int n", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0} 1000000000000000000;\n\tassert(result == 1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\"});\n}/by_length.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"Three\",\"Two\",\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0}t> arr){\n    vector<int> out={};\n    for (int i=0;i<arr.size();i+=1)\n        if (arr[i]%2==0)\n            out.push_back(arr[i]);\n    return out;\n}\nint main(){\n\tauto result = even_numbers({1,2,", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{\"One\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/105", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> by_length(vector<int> arr){\n    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\nint main(){\n\tauto result = by_length(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}));\n\tresult = by_length({9,8,7,6,5,4,3,2,1,0});\n\tassert(issame(result,{\"Zero\",\"One\",\"Two\",\"Three", "fn": "by_length", "para": "(vector<int> arr)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return out;\n}\nint main(){\n\tauto result = f(10);\n\tassert(issame(result,{1,2,6,24,15,720,28}));\n}/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = f(2);\n\tassert(issame(result,{1,3}));\n\tresult = f(3);\n\tassert(issame(result,{1,3,9}));\n\tresult = f(4);\n\tassert(issame(result,{1,3,9,15}));\n\tresult = f(5);\n\tassert(issame(result,{", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = f(2);\n\tassert(issame(result,{1,2}));\n\tresult = f(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = f(4);\n\tassert(issame(result,{1,6,24,120}));\n\tresult = f(5);\n\tassert(issame(", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = f(2);\n\tassert(issame(result,{1,2}));\n\tresult = f(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = f(4);\n\tassert(issame(result,{1,7,24,120}));\n\tresult = f(5);\n\tassert(issame(", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = f(2);\n\tassert(issame(result,{1,2}));\n\tresult = f(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = f(4);\n\tassert(issame(result,{1,4,10,24}));\n\tresult = f(5);\n\tassert(issame(result", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = f(2);\n\tassert(issame(result,{1,2}));\n\tresult = f(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = f(4);\n\tassert(issame(result,{1,4,10,24}));\n\tresult = f(5);\n\tassert(issame(result", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5;\n\tassert(issame(result,{1,2,3,4,5}));\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5;\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n   ", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b)!=EOF){\n        printf(\"%d\\n\",a", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while (scanf(\"%d%d\",&a,&b)!=EOF)\n    {\n        printf(\"%d\\n", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6,24,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3\n\tassert(issame(result,{1,2,3,4,5,6}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=n;i++)", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/106", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\nint main(){\n\tauto result = f(<FILL_ME>);\n\tassert(issame(result,{1,2,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> f(int n){\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        out.push", "fn": "f", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{1000000000000000000,0}));\n\tresult = even_odd_palindrome(10000000000000000000);\n\tassert(issame(result,{50000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000);\n\tassert(issame(result,{333333333,666666666})  }\n    return result;\n}\nint main(){\n\tauto result = find_all_divisors(1000000000);\n\tassert(issame(result,{2,3,5,7,11,1", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100;\n\tassert(issame(result,{1,2,3}));\n}/leetcode/118.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<vector<int>> generate(int numRows){\n    vector<vector<int>>", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{5,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000);\n\tassert(issame(result,{1000000000,0}));\n\tresult = even_odd_palindrome(1000000000000000000);\n\tassert(issame(result,{1000000000000000000,0}));\n\tresult = even", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{8,13}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000);\n\tassert(issame(result,{1,2}));\n\tresult = even_odd_palindrome(1000000000000000000 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_prime(1000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_palindrome(1000000000000000000);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_palindrome(100000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_palindrome(10000000000000000000;\n\tassert(issame(result,{1,1}));\n\tresult = count_pairs(10000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000);\n\tassert(issame(result,{500000000,500000000}));\n\tresult = even_odd_palindrome(1000000000000000000);\n\tassert(issame(result,{500000000000000000,5", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "100);\n\tassert(issame(result,{5,4}));\n\tresult = even_odd_palindrome(1000  }\n    return result;\n}\nint main(){\n\tauto result = find_missing_number({1,2,3,4,5,6,7,9});\n\tassert(issame(result,8));\n\tresult = find_missing_number({1,2,3", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000);\n\tassert(issame(result,{1000000000000000000,0}));\n\tresult = even_odd_palindrome(10000000000000000000);\n\tassert(issame(result,{10000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/107", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\nint main(){\n\tauto result = even_odd_palindrome(<FILL_ME>);\n\tassert(issame(result,{4,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "even_odd_palindrome", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,-3,4,-5,6}  }\n    return result;\n}\nint main(){\n\tauto result = find_max_subarray({1,2,-3,4,-5,6});\n\tassert(result==11);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,-3,4,5,6,7,-8,-9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,-10,100}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,-3,4,5,-6,7,-8,9,-10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/108", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_nums(vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\nint main(){\n\tauto result = count_nums(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "count_nums", "para": "(vector<int> n)", "type": "int", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/109", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool move_one_ball(vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\nint main(){\n\tauto result = move_one_ball(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "move_one_ball", "para": "(vector<int> arr)", "type": "bool", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8,10}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8,10};\n\tassert(result==1);\n\tresult = find_max({1,3,5,7,", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8});\n\tassert(result==\"YES\");\n\tresult = exchange({1,3,5},{2,4,6,8,10}\t\t}\n\t\t}\n\t\tif (flag) break;\n\t}\n\treturn result;\n}\n", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},{2,4,6,8,10});\n\tassert(result==\"YES\");\n\tresult = exchange({1,2,3,4,5},{2,4,6,8,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(vector<int> lst){\n    int max=0;\n    for (int i=0;", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(vector<int> lst){\n    int max=0;\n    for (", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},{2,4,6,8,10} 1000000000;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (sum % n!= 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3,5},{2,4,6}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(vector<int> lst){\n    int max=0;\n    for (int i=0;i<lst", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/110", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\nint main(){\n\tauto result = exchange(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_max(vector<int> lst){\n    int max=0;\n    for (", "fn": "exchange", "para": "(vector<int> lst1,vector<int> lst2)", "type": "string", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abbbcc\");\n\tassert(issame(result,{{'b',3},{'c',2}}));\n\tresult = histogram(\"abbbccdd\");\n\tassert(issame(result,{{'b',3},{'c',2}}));\n\tresult = histogram(\"abbbccddddd\");\n\tassert(issame(result,{{'d',4}}));\n\tresult = histogram(\"abbbccddddd\"", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'b',4}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'z',1}}));\n\tresult = histogram(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'z',1}}));\n\tresult = histogram(\"a", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'a',1}}));\n\tresult = histogram(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'a',1}}));\n\tresult = histogram(\"a", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'a',1}}));\n\tresult = histogram(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{{'a',1}}));\n\tresult = histogram(\"a", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c\");\n\tassert(issame(result,{{'a',1}}));\n\tresult = histogram(\"a b b\");\n\tassert(issame(result,{{'b',2}}));\n\tresult = histogram(\"a b b c\");\n\tassert(issame(result,{{'b',2}}));\n\tresult = histogram(\"a b b c c\");\n\tassert(issame(result,{{'b',2", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abacadg\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"abacadg\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"abacadg\");", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abacadg\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"abacadg\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"abacadg\");", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram(\"a b c d e f g\");\n\tassert(issame(result,{{'a',1},{'b',1},{'c',1},{'d',1},{'g',1}}));\n\tresult = histogram", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"r t g r t g\");\n\tassert(issame(result,{{'r',2},{'t',2},{'g',2}}));\n\tresult = histogram(\"r t g r t g r t g\");\n\tassert(issame(result,{{'r',3},{'t',3},{'g',3}}));\n\tresult = histogram(\"r t g r t g r t g r t g\");\n\tassert(iss", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"r t g r t g\");\n\tassert(result.size() == 3t(result,{{'r',1},{'t',1},{'g',1}}));\n}/histogram.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"r t g r t g\");\n\tassert(result.size() == 3t.push_back(i);\n        }\n    }\n    return out;\n}\nint main(){\n\tauto result = find_primes(100);\n\tassert(issame(result, {2, 3, 5, 7, 11, 13, 17, 19, 23, ", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'r',1},{'t',1},{'g',1}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g r t g", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"\");\n\tassert(issame(result,{}));\n\tresult = histogram(\"a\");\n\tassert(issame(result,{'a':1}));\n\tresult = histogram(\"aa\");\n\tassert(issame(result,{'a':2}));\n\tresult = histogram(\"aa b\");\n\tassert(issame(result,{'a':2}));\n\tresult = histogram(\"aa bb\");\n\tassert(issame(result,{'a", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": true}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"hello world\");\n\tassert(issame(result,{'l':3,'o':2,' ':1,'e':1,'d':1,'h':1,'r':1,'w':1}));\n\tresult = histogram(\"hello world\");\n\tassert(issame(result,{'l':3,'o':2,' ':1,'e':1,'d':1,'h':1,'r':1,'w':1}));\n\tresult = histogram", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{}));\n\tresult = histogram(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\");\n\tassert(issame(result,{}));\n\tresult = histogram(\"a b c d e f g h i j k", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"hello world\");\n\tassert(issame(result,{'l':2,'o':2}));\n\tassert(issame(histogram(\"hello world\"),{'l':2,'o':2}));\n\tassert(issame(histogram(\"hello world\"),{'l':2,'o':2}));\n\tassert(issame(histogram(\"hello world\"),{'l':2,'o':2}));\n\tassert(issame(histogram(\"hello world\"),{'l':", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"hello world\");\n\tassert(issame(result,{'l':3,'o':2,' ':1,'e':1,'d':1,'h':1,'r':1,'w':1}));\n\tresult = histogram(\"hello world\");\n\tassert(issame(result,{'l':3,'o':2,' ':1,'e':1,'d':1,'h':1,'r':1,'w':1}));\n\tresult = histogram", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abacabad\");\n\tassert(issame(result,{{'a',2},{'b',2},{'c',1},{'d',1}}));\n\tresult = histogram(\"abacabad\"  }\n    return 0;\n}/1001-1050/1009.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abacab\");\n\tassert(issame(result,{{'a',2},{'b',2},{'c',1}}));\n\tresult = histogram(\"abacab\");\n\tassert(issame(result,{{'a',2},{'b',2},{'c',1}}));\n\tresult = histogram(\"abacab\");\n\tassert(issame(result,{{'a',2},{'b',2},{'c',", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"a b b a b\");\n\tassert(issame(result,{{'a',2},{'b',3}}));\n\tresult = histogram(\"a b b a b a\");\n\tassert(issame(result,{{'a',3},{'b',3}}));\n\tresult = histogram(\"a b b a b a b\");\n\tassert(issame(result,{{'a',3},{'b',3}}));\n\tresult", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": false}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": true}
{"task_id": "CPP/111", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nmap<char,int> histogram(string test){\n    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\nint main(){\n\tauto result = histogram(<FILL_ME>);\n\tassert(issame(result,{{'a',2},{'b',2}}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\n\n", "filling": "\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame(result,{{'a',2},{'b',2}}));\n\tresult = histogram(\"abba\");\n\tassert(issame", "fn": "histogram", "para": "(string test)", "type": "map<char,int>", "pass": true}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcde\",\"ace\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"abc\");\n\tassert(issame(result,{\"de\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"ed\");\n\tassert(issame(result,{\"abc\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"edab\"t(issame(", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcde\",\"ace\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"abc\");\n\tassert(issame(result,{\"de\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"ed\");\n\tassert(issame(result,{\"abc\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"abcde\"t(result,{\"", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcde\",\"ac\");\n\tassert(issame(result,{\"ebcd\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"ac\");\n\tassert(issame(result,{\"ebcd\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"ac\");\n\tassert(issame(result,{\"ebcd\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"ac\");\n\tassert(issame(", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcde\",\"ace\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"af\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"a\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"\");\n\tassert(issame(result", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"cdedc\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcde\",\"ace\");\n\tassert(issame(result,{\"bcde\",\"False\"}));\n\tresult = reverse_delete(\"abcde\",\"af\");\n\tassert(issame(result,{\"bcde\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"\");\n\tassert(issame(result,{\"edcba\",\"True\"}));\n\tresult = reverse_delete(\"abcde\",\"bcde\"t(result,", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abba\",\"ba\"t(result,{\"1234567890\",\"True\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> is_increasing(string s){\n    string n=\"\";\n    for (int i=0", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abba\",\"ba\");\n\tassert(issame(result,{\"abba\",\"False\"}));\n\tresult = reverse_delete(\"abba\",\"ab\");\n\tassert(issame(result,{\"ba\",\"True\"}));\n\tresult = reverse_delete(\"abba\",\"b\"t(result,{\"1234567890\",\"1234567890\"}));\n\tresult = reverse_", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abba\",\"ba\"  }\n    return result;\n}\nint main(){\n\tauto result = find_all_anagrams(\"cbaebabacd\",\"abc\");\n\tassert(issame(result,{0,6}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abba\",\"ba\";\n\tassert(issame(result,{\"1234567890\",\"True\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abba\",\"ba\");\n\tassert(issame(result,{\"abba\",\"False\"}));\n\tresult = reverse_delete(\"abba\",\"ab\");\n\tassert(issame(result,{\"ba\",\"True\"}));\n\tresult = reverse_delete(\"abba\",\"b\"t(result,{\"1234567890\",\"1234567890\"}));\n\tresult = add_", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"abc\");\n\tassert(issame(result,{\"\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"ac\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"abc\");\n\tassert(issame(result,{\"\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"abc\");\n\tassert(issame(result,{\"\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"abc\");\n\tassert(issame(result,{\"\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"ac\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"abc\");\n\tassert(issame(result,{\"\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"acdef\",\"ac\");\n\tassert(issame(result,{\"cdef\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"cf\");\n\tassert(issame(result,{\"def\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"abc\";\n\tassert(issame(result,{\"123456789\",\"123456789\"}));\n\t", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"acdef\",\"ac\");\n\tassert(issame(result,{\"cdef\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"cf\");\n\tassert(issame(result,{\"def\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"abc\";\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"acdef\",\"ac\");\n\tassert(issame(result,{\"cdef\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"cf\");\n\tassert(issame(result,{\"def\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"ef\");\n\tassert(issame(result,{\"acf\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"abcd\";\n\tassert(iss", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"acdef\",\"ac\");\n\tassert(issame(result,{\"cdef\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"cf\");\n\tassert(issame(result,{\"def\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"abc\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"acdef\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"acdef\",\"ac\");\n\tassert(issame(result,{\"cdef\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"cf\");\n\tassert(issame(result,{\"def\",\"False\"}));\n\tresult = reverse_delete(\"acdef\",\"abc\" 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcdedcba\",\"abc\");\n\tassert(issame(result,{\"edcba\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"ed\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"edcb\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcdedcba\",\"abc\");\n\tassert(issame(result,{\"edcba\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"abc\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n\tresult = reverse_delete(\"1234567890\",\"12345678", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcdedcba\",\"abc\");\n\tassert(issame(result,{\"edcba\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"ed\" 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tassert(is_prime(1)==0);\n\tassert(is_prime(2)==1);\n\tassert(is_prime(3)==1);\n\tassert(is_", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcdedcba\",\"abc\");\n\tassert(issame(result,{\"edcba\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"ed\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n\tresult = reverse_delete(\"1234567890\",\"12345678", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"abcdedcba\",\"True\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abcdedcba\",\"abc\");\n\tassert(issame(result,{\"edcba\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"ed\");\n\tassert(issame(result,{\"abc\",\"False\"}));\n\tresult = reverse_delete(\"abcdedcba\",\"abc\"\n\tassert(issame(result,{\"1234567890\",\"1234567890", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"dik\",\"k\"\n\tassert(issame(result,{\"123456789\",\"123456789\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring reverse_delete(string s,string c", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"False\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"False\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\"\n\tassert(issame(", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"i\");\n\tassert(issame(result,{\"dk\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\"\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n\tresult", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"dik\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"False\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\");\n\tassert(issame(result,{\"ik\",\"True\"}));\n\tresult = reverse_delete(\"dik\",\"d\"t(issame(result,", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"a\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"d\"\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n\tresult = reverse", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"a\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"ac\"  }\n    return 0;\n}/1001-1500/1001-1050/1025/10", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"bd\"\n\tassert(issame(result,{\"123456789\",\"123456789\"}));\n\tresult = reverse_delete", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"ac\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"bd\" 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\t", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/112", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\nint main(){\n\tauto result = reverse_delete(<FILL_ME>);\n\tassert(issame(result,{\"bcd\",\"False\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"abc\",\"a\");\n\tassert(issame(result,{\"bc\",\"False\"}));\n\tresult = reverse_delete(\"abc\",\"bc\");\n\tassert(issame(result,{\"a\",\"True\"}));\n\tresult = reverse_delete(\"abc\",\"d\"t(issame(result,{\"1234567890\",\"1234567890\"}));\n\tresult = is_pal", "fn": "reverse_delete", "para": "(string s,string c)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"12345\",\"23456\",\"34567\"}t(result,{\n\"thesumof123456789101112131415161718192021222324252627282930313233343536373839", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"12345\",\"23456\",\"34567\"};\n\tassertassert(issame(result,{\n\"thesumoftheelements2nof2nthe2nput.\",\n\"thesumoftheelements3nof3nthe3nput.\",\n\"thesumoftheelements2nof2nthe2nput.\"\n}));;\n}#include<stdio.h>\n#include<math.", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abc\",\"123\",\"xyz\"}t(result,{\n\"123456789\",\n\"123456789\",\n\"123456789\"\n}));;\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abc\",\"123\",\"xyz\"}t(result,{\n\"thesumofthe2nput.\",\n\"thesumofthe2nput.\",\n\"thesumofthe2nput.\"\n}));;\n}/test/test_sum.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassertassert(issame(result,{\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\",\n\"thenumberofoddelements3nthestr3ng3ofthe3nput.\",\n\"thenumberofoddelements2nthestr2ng2ofthe2nput.\"\n}));;\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"123456789\",\"123456789\"}t(result,{\n\"thesumoftheelements123456789.\",\n\"thesumoftheelements123456789.\",\n\"thesumoftheelements123456789.\"\n}));;\n}/test/test_", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\"}t(result,{\"123456789\",\"987654321\"});\n}/odd_count.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\"}t(result,{\"123456789\",\"987654321\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\"}t(result,{\"123456789\",\"987654321\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\"}t(result,{\"123456789\",\"987654321\"});\n}/odd_count.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements1nthestr1ng1ofthe1nput.\",\"thenumberofoddelements8nthestr8ng8ofthe8nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\"}t(result,{\"123456789\",\"987654321\"});\n}/odd_count.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"987654321\",\"1234567890\"}t.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count({\"123456789\",\"987654321\",\"1234567890\"});\n\tassert(", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"1234567890\",\"12345678901234567890\"}t(result,{\"1234567890123456789012345678901234567890123456789", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"1234567890\",\"123456789012345678901234567890123456789012345678901234567890123456789012345678", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/113", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<string> odd_count(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\nint main(){\n\tauto result = odd_count(<FILL_ME>);\n\tassert(issame(result,{\"thenumberofoddelements4nthestr4ng4ofthe4nput.\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123456789\",\"1234567890\",\"123456789012345678901234567890123456789012345678901234567890123456789012345678", "fn": "odd_count", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==1);\n\tresult = minSubArraySum({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(result==-10);\n\tresult = minSubArraySum({1,2,3,4,5,6,7,8,9,10", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -1}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int> nums){\n    int max=0,current=0;\n    for (int i=0;i<nums.", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findDuplicate(vector<int>& nums) {\n    int slow=nums[0];\n    int fast", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==1);\n\tresult = minSubArraySum({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(result==-10);\n\tresult = minSubArraySum({1,2,3,4,5,6,7,8,9,10", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int> nums){\n    int max=0,current=", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2}\n\tassert(result==1);\n\tresult = findPeakElement(vector<int", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2});\n\tassert(result==-2);\n\tresult = minSubArraySum(vector<long long", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2});\n\tassert(result==-2);\n\tresult = minSubArraySum(vector<long long", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2,-3,-4,-5});\n\tassert(result==-1);\n", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-9999999999999999}  }\n    return result;\n}\nint main(){\n\tauto result = findMaxConsecutiveOnes(vector<int>{1,1,0,1,1,1});\n\tassert(result==3);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, -1}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0;\n    for (int i=0;", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-9999999999999999}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-9999999999999999}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-9999999999999999);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, -1}  }\n    return result;\n}\nint main(){\n\tauto result = findMaxConsecutiveOnes(vector<int>{1,1,0,1,1,1});\n\tassert(result==3);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10}", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0;\n    for (int i=0", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{2,3,-2,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0;\n    for (int i=0;i<nums.size", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==7);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-10,1,2,-1,-2,3}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findPeakElement(vector<int>& nums) {\n    int l=0,r=nums.size()-1;\n    while", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -1};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int> nums){\n    int max=0,current=0;\n    for (int i=0;i", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-10,1,2,-1,-2,3}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0;\n    for (", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-10,1,2,-1,-2,3};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMin(vector<int> nums){\n    int min=nums[0];\n    for (int i=1", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10}", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint maxProfit(vector<int> prices){\n    int max=0;\n    for (int i=0", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findPeakElement(vector<int>& nums) {\n    int left=0,right=nums", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10}", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2,-3,-4,-5});\n\tassert(result==-1);\n", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findDuplicate(vector<int>& nums) {\n    int slow=nums[0];\n    int fast=nums[0];\n    do{\n        slow=nums[slow];\n       ", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum({-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-6);\n\tresult = minSubArraySum({-2,1,-3,4,-1,2,1,-5,4};\n\tassert(result==1);\n\tresult =", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max=0,current=0;", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2,-3,-4,-5});\n\tassert(result==-1);\n", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findPeakElement(vector<int>& nums) {\n    int l=0,r=nums.size", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findPeakElement(vector<int>& nums) {\n    int left=0,right=nums.size", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint maxProfit(vector<int>& prices) {\n    int max=0;\n    for (int i=", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint findPeakElement(vector<int>& nums) {\n    int left=0,right=nums.size", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3}  }\n    return result;\n}\nint main(){\n\tauto result = findPeakElement(", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3}t(result==1);\n}#include<stdio.h>\n#include<math", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3}t(result==1);\n}#include<stdio.h>\n#include<math", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3}t(result==1);\n\tresult = climbStairs(3);\n\tassert(", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2, -3, 4, -1, -2, 1, 5, -3}t(result==1);\n}#include<stdio.h>\n#include<math", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{-1,-2,-3,-4,-5});\n\tassert(result==-1);\n", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5});\n\tassert(result==1);\n\tresult = minSubArraySum(vector<long long>{1,2,3,4,5,6,7,8,9,10});", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/114", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nlong long minSubArraySum(vector<long long> nums){\n    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\nint main(){\n\tauto result = minSubArraySum(<FILL_ME>);\n\tassert(result==-14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<long long>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==-1);\n\tresult = minSubArraySum(vector<long long>{-2,1,-3,4,-1,2,1,-5,4}t(result==1);\n}/src/136.cpp\n#include<stdio.h>\n#include<math.", "fn": "minSubArraySum", "para": "(vector<long long> nums)", "type": "long long", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}},10\n\tassert(result==1);\n}/leetcode/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t}, 3);\n\tassert(result==1);\n\tresult = max_fill({\n\t\t{1,1,1,1,1", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t{1,1,", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}},4;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}},3;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}}, 10;\n\tassert(result==1);\n}/leetcode/1011.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}},5t(result==1);\n}/leetcode/1021.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4  }\n    return out;\n}\nint main(){\n\tauto result = max_fill(vector<vector<int>>{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4);\n", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4t(result==1);\n}/leetcode/1011.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint shipWithin", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> v[", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{ { 1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5 } }, 5 0;\n}/1001-1100/1001-1100/10", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}},5t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}},5t(result==1);\n}/test/test_1000000000000000000.cpp\n#include<stdio.h>\n#", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1, 2, 3, 4, 5},\n\t\t{1, 2, 3, 4, 5},\n\t\t{1, 2, 3, 4, 5},\n\t\t{1, 2, 3, 4, 5},\n\t\t{1, 2, 3, 4, 5}\n\t}, 5t(result==1);", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t\t{1,1,1,1,1},\n\t}, 3;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}},5t(result==1);\n}/leetcode/1004.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}},3t(result==1);\n}/leetcode/1011.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint shipWithinDays(vector<int>& weights, int D) {\n    int", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}},4  }\n    return out;\n}\nint main(){\n\tauto result = max_fill(vector<vector<int>>{{1,2,3},{4,5,6},{7,8,9}},4);\n\tassert(result==2);\n}#include<stdio.h>\n#include<math.h>\n#include", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4}},4t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{1,2,3},{1,2,3}},3t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}},4;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/115", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint max_fill(vector<vector<int>> grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\nint main(){\n\tauto result = max_fill(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{{1,2,3},{1,2,3},{1,2,3}},3  }\n    return out;\n}\nint main(){\n\tauto result = max_fill(vector<vector<int>>{{1,2,3},{1,2,3},{1,2,3}},3);\n\tassert(result==2);\n}/max_fill.cpp\n#include<stdio.h>\n#include<", "fn": "max_fill", "para": "(vector<vector<int>> grid,int capacity)", "type": "int", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,8,16,32}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,8,16,32} 1000000007;\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int> a(n);\n\tfor (int i=0;i<n;i++) cin>>a[i];\n\tvector<int> b(m);\n\tfor (int i=0;i<m;i++) cin", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,8,16,32};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,8,16,32};\n\tassert(issame(result,{1,2,3,4,5}));\n}/sort_array_by_parity_ii.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,4,8,16,32}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,4,8,16,32};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-99/1-9/1-9.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-4,-2,-6,-5,-3}  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n,m,k,i,j,l,r,x,y,z,a,b,c,d,e,", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-4,-2,-6,-5,-3}t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}/sort_array_by_parity_II.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-4,-2,-6,-5,-3} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> arr(n);\n\tfor (int i=0;i<n;i++)\n\tcin>>arr[i];\n\tcout<<find_missing(arr);\n}#include<iostream>\n#include<vector>", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-4,-2,-6,-5,-3}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2,7,11,15},9);\n\tassert(issame(result,{0,1}));\n}#include<stdio.h>\n#include<math.h>\n#include<", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{-4,-2,-6,-5,-3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-4,-2,-6,-5,-3}\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,4,3,5}t(result,10);\n}/leetcode/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_palindrome(int x){\n    if (x<0) return false;\n    int n=x,m=", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,4,3,5};\n\tassert(issame(result,{1,2,3,4,5}));\n}/sort_array_by_parity_ii.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array_by", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,4,3,5}t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int count=0;\n    while (n>0)\n    {\n        n=n/10;\n        count++;\n   ", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,4,3,5} 1000000007;\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n][m];\n\tfor (int i=0;i<n;i++)\n\tfor (int j=0;j<m;j++)\n\tcin>>a[i][j];\n\tint ans=0;\n\tfor", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{1,2,4,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,4,3,5};\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({10,9,8,7,6,5,4,3,2,1", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({-1,-2,-3,-4,-5,-6,-7,-8,-9,-1", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({10,9,8,7,6,5,4,3,2,1});\n\tassert(issame(result,{1,2,3,4,5,", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({10,9,8,7,6,5,4,3,2,1", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{});\n\tassert(issame(result,{}));\n\tresult = sort_array({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = sort_array({10,9,8,7,6,5,4,3,2,1", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{32,3,5,6,12,44};\n\tassert(issame(result,{1,2,3,4,5,6}));\n}/cpp/sort_array_by_parity.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{32,3,5,6,12,44};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{32,3,5,6,12,44} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint arr[n];\n\tfor (int i=0;i<n;i++)\n\tcin>>arr[i];\n\tcout<<find_max_subarray(arr,n);\n}/max_sub", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{32,3,5,6,12,44};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{32,3,5,6,12,44}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{32,3,5,6,12,44}  }\n    return 0;\n}/1000/1000.cpp\n#include<iostream>\nusing namespace std;\nint main(){\n    int a,b;\n    while (cin>>a>>b)\n    {\n        cout<<a+b<<endl;\n    }\n    return 0;\n}/100", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3,4,2,0,1}  }\n    return 0;\n}/Code/CodeRecords/2430/60799/247057.py\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3,4,2,0,1}\n\tassert(issame(result,{1,2,3,4,5}));\n}/sort_array_by_parity_II.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array_by_", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3,4,2,0,1};\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3,4,2,0,1}t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int c=0;\n    while (n>0)\n    {\n        c++;n=n/10;\n    }", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{0,1,2,4,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{3,4,2,0,1};\n\tassert(issame(result,{1,2,3,4,5}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> runningSum(vector<int>& nums", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,4,4,3,3,5,5,5,7,77}\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,4,4,3,3,5,5,5,7,77};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,4,4,3,3,5,5,5,7,77};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,4,4,3,3,5,5,5,7,77};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/116", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\nint main(){\n\tauto result = sort_array(<FILL_ME>);\n\tassert(issame(result,{2,2,4,4,3,3,5,5,5,7,77}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{2,2,4,4,3,3,5,5,5,7,77};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "sort_array", "para": "(vector<int> arr)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\", 2);\n\tassert(issame(result,{\"Uncle\", \"Fred\"}));\n\tassert(issame(select_words(\"\", 3),{\"Uncle\", \"Fred\"}));\n\tassert(issame(select_words(\"\", 1),{\"Uncle\"}));\n\tassert(issame(select_words(\"\", 4),{\"Uncle\", \"Fred\"}));\n\tassert(iss", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\", 2t(result,10);\n}/codewars/7kyu/sum_of_digits_digital_root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int n) {\n    int out=0", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\", 2);\n\tassert(issame(result,{\"Uncle\", \"Fred\"}));\n\tresult = select_words(\"\", 3);\n\tassert(issame(result,{\"Uncle\", \"Fred\"}));\n\tresult = select_words(\"\", 4);\n\tassert(issame(result,{\"Uncle\", \"Fred\"}));\n\tresult = select_words(\"\", 5);\n", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\", 2);\n\tassert(issame(result,{\"Uncle\", \"Sam\"}));\n\tresult = select_words(\"\", 3);\n\tassert(issame(result,{\"Uncle\", \"Sam\"}));\n\tresult = select_words(\"\", 1t(result,{\"123456789012345678901234567", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Uncle\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"\", 2);\n\tassert(issame(result,{\"Uncle\", \"Fred\"}));\n\tassert(issame(select_words(\"\", 3),{\"Uncle\", \"Fred\"}));\n\tassert(issame(select_words(\"\", 1),{\"Uncle\"}));\n\tassert(issame(select_words(\"\", 4),{\"Uncle\", \"Fred\"}));\n\tassert(iss", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"ae\",\"iou\"}));\n\tresult = select_words(\"How vexingly quick daft zebras jump!\", 3);\n\tassert(issame(result,{\"How\",\"jump\"}));\n\tresult = select_words(\"codewars\", 1);\n\tassert(issame(result,{\"c\",\"d\",\"e\",\"o\",\"w\",\"a\",\"r\",\"s", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"Hello World, I am a programmer\", 2);\n\tassert(issame(result,{\"Hello\",\"World\"}));\n\tresult = select_words(\"Hello World, I am a programmer\", 3);\n\tassert(issame(result,{\"Hello\",\"World\"}));\n\tresult = select_words(\"Hello World,", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2t(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n}/cpp/src/select_letters.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\",2  }\n    return out;\n}\nint main(){\n\tauto result = find_even_index(vector<int>{1,2,3,4,3,2,1});\n\tassert(result==3);\n}/CodeWars/find_even_index.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"b\",\"c\",\"d\",\"f\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2t(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"World\", 2);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"World\", 3);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"Hey diddle diddle, the cat and the fiddle!\", 3);\n\t", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"World\", 2);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"Hello World\", 2);\n\tassert(issame(result,{\"Hello\",\"World\"}));\n\tresult = select_words(\"Hello World\", 3);\n\tassert(issame(result,{\"", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"World\", 2);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"World\", 3);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"Hello World\", 3);\n\tassert(issame(result,{\"Hello\",\"World", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"World\", 2);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"World\", 3);\n\tassert(issame(result,{\"World\"}));\n\tresult = select_words(\"Hey diddle diddle, the cat and the fiddle!\", 3);\n\t", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"world\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test\", 4);\n\tassert(issame(result,{\"This\", \"is\", \"a\", \"test\"}));\n\tresult = select_words(\"This is a test\", 3);\n\tassert(issame(result,{\"This\", \"is\", \"a\", \"test\"}));\n\tresult = select_words(\"This is a test\", 2);\n\tassert(issame(result,{\"This\", \"is\",", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"The quick brown fox jumps over the lazy dog\", 3 1000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test of the emergency broadcast network.\", 1);\n\tassert(issame(result,{\"This\"}));\n\tassert(issame(result,{\"is\"}));\n\tassert(issame(result,{\"a\"}));\n\tassert(issame(result,{\"test\"}));\n\tassert(issame(result,{\"of\"}));\n\tassert(issame(result,{\"the\"}));\n\tassert(issame(", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test of the emergency broadcast network.\", 1);\n\tassert(issame(result,{\"This\"}));\n\tassert(issame(result,{\"is\"}));\n\tassert(issame(result,{\"a\"}));\n\tassert(issame(result,{\"test\"}));\n\tassert(issame(result,{\"of\"}));\n\tassert(issame(result,{\"the\"}));\n\tassert(issame(", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"The quick brown fox jumps over the lazy dog\", 3t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/cpp/easy/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"little\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test of the emergency broadcast network.\", 1);\n\tassert(issame(result,{\"This\"}));\n\tassert(issame(result,{\"is\"}));\n\tassert(issame(result,{\"a\"}));\n\tassert(issame(result,{\"test\"}));\n\tassert(issame(result,{\"of\"}));\n\tassert(issame(result,{\"the\"}));\n\tassert(issame(", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Mary had a little lamb\", 3;\n\tassert(issame(result,{\"1\",\"2\",\"3\"}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_and_delimit(string s,char delim){\n    vector", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Mary had a little lamb\", 3t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/codewars/7kyu/split_strings.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Mary had a little lamb\", 3t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"3", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Mary had a little lamb\", 3t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/codewars/7kyu/split_strings.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{\"Mary\",\"lamb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Mary had a little lamb\", 3t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"3", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test of the emergency broadcast network.\", 1);\n\tassert(issame(result,{\"This\"}));\n\tassert(issame(result,{\"is\"}));\n\tassert(issame(result,{\"a\"}));\n\tassert(issame(result,{\"test\"}));\n\tassert(issame(result,{\"of\"}));\n\tassert(issame(result,{\"the\"}));\n\tassert(issame(", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"\", 3);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 1);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 4);\n\tassert(issame(result,{\"\"}));\n", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"\", 3);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 1);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 4);\n\tassert(issame(result,{\"\"}));\n", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"aeiou\", 2);\n\tassert(issame(result,{\"aeiou\"}));\n\tresult = select_words(\"\", 3);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 1);\n\tassert(issame(result,{\"\"}));\n\tresult = select_words(\"\", 4);\n\tassert(issame(result,{\"\"}));\n", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/117", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> select_words(string s,int n){\n    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\nint main(){\n\tauto result = select_words(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"This is a test of the emergency broadcast network.\", 1);\n\tassert(issame(result,{\"This\"}));\n\tassert(issame(result,{\"is\"}));\n\tassert(issame(result,{\"a\"}));\n\tassert(issame(result,{\"test\"}));\n\tassert(issame(result,{\"of\"}));\n\tassert(issame(result,{\"the\"}));\n\tassert(issame(", "fn": "select_words", "para": "(string s,int n)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy and a girl\");\n\tassert(", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"coderbyte\"t(result==1);\n}/easy/simple_adding.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint simple_adding(int num){\n    int sum=0;\n    for (int i=1;i<=num;i+=1)\n        sum+=i", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"o\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoes\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoe\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoes\");\n\tassert(result==\"", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"to\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"cat\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"dog\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"hello world\");\n\tassert(result==\"e\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"to\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"cat\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"noon\"t_closest_vowel(\"to\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"cat\");\n", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"a\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"A\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"aeiou\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"a\");\n\tassert(result==\"\");\n\tresult = get_", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"to\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"cat\");\n\tassert(result==\"a\");\n\tresult = get_closest_vowel(\"dog\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"hello world\"t(result==1);\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I am an apple\");\n\tassert(result==\"a\");\n\tresult = get_closest_vowel(\"I am an orange\");\n\tassert(result==\"a\");\n\tresult = get_closest_vowel(\"I am an orange\");\n\tassert", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoes\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoe\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"Tomatoes\");\n\tassert(result==\"", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"y\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why?!\");\n\tassert(result==\"\");\n\tresult = get_closest", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"u\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why not\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why why why\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"why why why why\");\n\tassert(result==\"\");\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"aeiou\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\"t(result==1);\n", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\");\n\tassert(result==\"a\");\n\tresult = get_closest_vowel(\"I am a boy\"t(result==", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\"t(result==1);\n\tresult = is_prime(100);\n\tassert(result==0);\n\t", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\"t(result==1);\n\tresult = is_prime(10);\n\tassert(result==0);\n\tresult", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/118", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring get_closest_vowel(string word){\n    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\nint main(){\n\tauto result = get_closest_vowel(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\");\n\tassert(result==\"e\");\n\tresult = get_closest_vowel(\"Tomato\");\n\tassert(result==\"o\");\n\tresult = get_closest_vowel(\"I\");\n\tassert(result==\"\");\n\tresult = get_closest_vowel(\"I am a boy\");\n\tassert(result==\"a\");\n\tresult = get_closest_vowel(\"I am a boy\"t(result==", "fn": "get_closest_vowel", "para": "(string word)", "type": "string", "pass": false}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\", \"((()))\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()())\", \"(()(()))\"} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_prime(1);\n\tassert(result==0);\n\tresult = is_prime(2);\n\tassert(result==1);\n", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": false}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"(a(b(c)d)\", \"a(b(c)d)\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"(a(b(c)d)\", \"a(b(c)d)\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"(a(b(c)d)\", \"a(b(c)d)\"});\n\tassert(result==\"Yes\");", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()))\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\",", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": false}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\",", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": false}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((())\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\",", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": false}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"()()()()()()()()()()()()()()()()()()()()()()()", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"())\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"((()))\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\",", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"())\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/119", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nstring match_parens(vector<string> lst){\n    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\nint main(){\n\tauto result = match_parens(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"((()))\", \"(()())\"});\n\tassert(result==\"Yes\");\n\tresult = match_parens({\"((()))\", \"(()))\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"((()\"});\n\tassert(result==\"No\");\n\tresult = match_parens({\"((()))\", \"()()()()()()()()()()()()()()()()()()()()()()()", "fn": "match_parens", "para": "(vector<string> lst)", "type": "string", "pass": true}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3\n\tassert(issame(result,{-1,0,1,2,3,4,5,6,7,8,9}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3\n\tassert(issame(result,{-1,0,3,10,11,12,15}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> out = s.twoSum({2,7,11,15},9);\n\tassert(issame(out,{0,1}));\n}#include<stdio.h>\n", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-13,-8,0,0,3,5,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}/1001-1099/1001-1099/1001.cpp\n#include<stdio.h>\n#include<math.h>\n", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,9,10,11},3t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}#include<stdio.h>\n#include<math.", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,9,10,11,12,13,14,15,16,17,18,19,20},3\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,9,10,11},3\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> out = s.twoSum({2,7,11,15},9);\n\tassert(issame(out,{0,1}));\n}#include<stdio.", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,12,5,7,8},3;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2,20,123}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,12,5,7,8},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum({1,2,3,4,5,6,7,8,9,10},3", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/src/10020.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{0,1,2,20}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int>", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2t> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum({1,2,3,4,5},2);\n\tassert(issame(result,{4,5}));\n}/maximum.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2;\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArray(vector<int> arr){\n    sort(arr.begin(),arr", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}/leetcode/118.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<vector<int", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,-3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},3t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int>", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2\n\tassert(issame(result,{1,2,3,4}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A){\n    vector<int> out;\n    for(", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A) {\n    int i=0,j=A.size", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{1,2,3,4,5,6,7,8,9,10});\n}/leetcode/1-100/1-10/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A){\n    vector", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{1,2,3,4,5,6,7,8,9,10});\n}/1-100/1-10/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t(result,{-10,10}));\n}/test/test_maximum.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t(result,{-10,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3;\n\tassert(issame(result,{-10,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum({1,2,3,1,4,5,6,7,8,9},3);\n\tassert(issame(result,{1,2,3}));\n}/maximum.cpp", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-10,10}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3\n\tassert(issame(result,{-10,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A) {\n    vector<int> out;\n    for(", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A){\n    vector", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(vector<int> arr){\n    int count=0;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2\n\tassert(issame(result,{1,2,3}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> runningSum(vector<int>& nums) {\n    vector<int", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A){\n    int i=0,j=A.size()-", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,2,5,2,3,7},3t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArray", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArray", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,6,7,8,9},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArray", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,2,5,2,3,7},3t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArray(vector", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2);\n\tassert(issame(result,{1,3}));\n\tresult = maximum({1,2,3,1},3);\n\tassert(issame(result,{1,1,2}));\n\tresult = maximum({1,2,3,1},4);\n\tassert(issame(result,{1,1,2,3})t(result,1));\n\tresult", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2t(result,{}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2);\n\tassert(issame(result,{1,1}));\n\tresult = maximum({1,2,3,1},3);\n\tassert(issame(result,{1,1,1}));\n\tresult = maximum({1,2,3,1},4);\n\tassert(issame(result,{1,1,1,1})\n\tassert(issame(result,{", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1},2);\n\tassert(issame(result,{1,1}));\n\tresult = maximum({1,2,3,1},3);\n\tassert(issame(result,{1,1,1}));\n\tresult = maximum({1,2,3,1},4);\n\tassert(issame(result,{1,1,1,1});\n\tassert(issame(result", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,2,3,6},4t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByPar", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,2,3,6},4t> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum({1,2,3,1,4,5,2,3,6},4);\n\tassert(issame(result,{5}));\n}#include<stdio.h>\n#include<math", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,2,3,6},4t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n}#include<stdio.h>\n#include<math.h>\n#include<", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,2,3,6},4t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByPar", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,1,4,5,2,3,6},4\n\tassert(issame(result,{1,2,3,4,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int>", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "vector<int>{-4,4},2t(result,{-1,0,1,2,3,4,5,6,7,8,9});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A){", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2\n\tassert(issame(result,{-1,0,1}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> threeSum(vector<int> arr){\n    sort(arr.begin(),arr.end());\n   ", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5},2\n\tassert(issame(result,{1,2,3,4,5}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> runningSum(vector<int> nums", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "vector<int>{-4,4},2\n\tassert(issame(result,vector<int>{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int> A) {\n    int i=0,j", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/120", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(<FILL_ME>);\n\tassert(issame(result,{-4,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "vector<int>{-4,4},2t> out(arr.end()-k,arr.end());\n    return out;\n}\nint main(){\n\tauto result = maximum(vector<int>{-4,4},2);\n\tassert(issame(result,{-4,4}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n", "fn": "maximum", "para": "(vector<int> arr,int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.solutions(v);\n\tassert(result==12);\n", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000000;\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==12);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==12);\n\tresult = solutions({1,2,3,4,5,6,7,8,9,10,11,12}t(result==1);\n\tresult = solutions(1000000000);\n\tassert(result==1);\n}", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n   ", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n   ", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/cpp/2015/20150315_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums = {1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.solutions(nums);\n\tassert(result==5);\n", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/cpp/1000000007.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int i=0;i<n;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tcout<<is_prime(x)<<endl;\n\t}\n}#include", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\t\tif (i==0)\n\t\t\t{\n\t\t\t\tif (j==0)\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\telse\n\t\t\t\t\tdp[i][j]=dp[i][j-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (j==0)\n\t\t\t\t\tdp[i][j]=dp[", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==23);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}/CodeWars/C++/7kyu/Find the odd int.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_it(vector<int> seq", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/cpp/easy/easy_1000_1099/easy_1000_1099_1009.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/121", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\nint main(){\n\tauto result = solutions(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint solutions(int n){\n    int sum=0;\n    for (int i=1;i<=n;i", "fn": "solutions", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (int i=0;i<k;i", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_missing(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size();i++)", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},10 100000000000000000000000000000000000000000000000000000000000000000000000", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5t(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=1", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},10 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 3t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (int i=0;i<k;i++)", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}, 3\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (int i=0;i<k;", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr){\n    int count=0;\n    for (int i=0;i<arr.size();i++)", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n       ", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>0){\n        sum+=n%10;\n        n/=1", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint is_prime(int n){\n    if(n==1)\n        return 0;\n    for(int i=2;i<=sqrt(n", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},5\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5 100000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},5t(result==125);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==125);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},5t main(){\n\tauto result = get_sum_of_digits(1234);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (int i=0;i<k;i++)\n       ", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5},5 1000000000000000000);\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},5t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (int", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},10t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint count_elements(vector<int> arr,int k){\n    int count=0;\n    for (", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/122", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint add_elements(vector<int> arr,int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\nint main(){\n\tauto result = add_elements(<FILL_ME>);\n\tassert(result==24);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10},5\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while(n>", "fn": "add_elements", "para": "(vector<int> arr,int k)", "type": "int", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,3,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,3,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,3,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,3,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,3,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,5,17,83,251,754,377,1252,626,313,940,470,235,706,353,1060,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,5,17,83,251,754,377,1133,3400,1700,850,425,1306,653,1960,9", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,5,17,83,251,754,377,1252,626,313,940,470,235,706,353,1060,", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,5}));\n\tresult = get_odd_collatz(100);\n\tassert(issame(result,{1,5,17,83,251,754,377,1133,3400,1700,850,425,1306,653,1960,9", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10);\n\tassert(issame(result,{1,3,5,15,21,25,75,125,151,175,225,251,275,325,351,375,425,451,475,525,551,575,625,651,67", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = get_odd_collatz(2);\n\tassert(issame(result,{1,2}));\n\tresult = get_odd_collatz(3);\n\tassert(issame(result,{1,3,10}));\n\tresult = get_odd_collatz(4);\n\tassert(issame(result,{1,4,2,1}));\n\t", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = get_odd_collatz(2);\n\tassert(issame(result,{1,2}));\n\tresult = get_odd_collatz(3);\n\tassert(issame(result,{1,3,10}));\n\tresult = get_odd_collatz(4);\n\tassert(issame(result,{1,4,2,1}));\n\t", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = get_odd_collatz(2);\n\tassert(issame(result,{1,2}));\n\tresult = get_odd_collatz(3);\n\tassert(issame(result,{1,3}));\n\tresult = get_odd_collatz(4);\n\tassert(issame(result,{1,4}));\n\tresult = get_odd_coll", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = get_odd_collatz(2);\n\tassert(issame(result,{1,2}));\n\tresult = get_odd_collatz(3);\n\tassert(issame(result,{1,3}));\n\tresult = get_odd_collatz(4);\n\tassert(issame(result,{1,4}));\n\tresult = get_odd_coll", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = get_odd_collatz(2);\n\tassert(issame(result,{2,1}));\n\tresult = get_odd_collatz(3);\n\tassert(issame(result,{3,10,5,16,8,4,2,1}));\n\tresult = get_odd_collatz(4);\n\tassert(issame(result", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13  }\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(13);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}/C++/C++_100_Days_of_Code/Day_01_01_Collatz_Conjecture/main.cpp\n#include<stdio.", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_prime_factors(int", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/123", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> get_odd_collatz(int n){\n    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\nint main(){\n\tauto result = get_odd_collatz(<FILL_ME>);\n\tassert(issame(result,{1,5,7,11,13,17}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "13t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "get_odd_collatz", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}/test/test_1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint addDigits(int num) {\n    if (num==0) return 0;\n    if (num", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0){\n        n/=10;\n        count++;\n    }\n    return count", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_outlier(int arr[], int len){\n    int odd=0,even=0;\n    for (int i=0;i<len;i", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\");\n\tassert(result==true);\n\tresult = valid_date(\"2002-01-32\");\n\tassert(result==false);\n\tresult = valid_date(\"2004-02-29\");\n\tassert(result==false);\n\tresult = valid_date(\"2000-02-29\");\n\tassert(result==true", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": true}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"12-01-2012\"  }\n    return 0;\n}\n/CodeForces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k;\n    cin>>n>>k;\n    int a[n];\n    for (int i=0;i<n;i++) cin>>a[i", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int num){\n    int count=0;\n    while (num>0){\n        num/=10;\n        count++;\n    }\n    return count", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"  }\n    return 0;\n}/Codeforces/118A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string s;\n    cin>>s;\n    for (int i=0;i<s.length();i++){\n        if (s[i]=='a' or s[i]=='e' or s[i]=='", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int num){\n    int count=0;\n    while (num>0){\n        num/=10;\n        count++;\n    }\n    return count", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/124", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\nint main(){\n\tauto result = valid_date(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2003-02-25\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(int *values, int length) {\n    int sum=0,left_sum=0;\n    for (int i=0;", "fn": "valid_date", "para": "(string date)", "type": "bool", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world!\"t(result,{\"Hello\",\"world!\"}));\n}/split_words.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world!\"nclude<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = find_missing_letter({\"a\",\"b\",\"c\",\"d\",\"f\"});\n\tassert(result=='e');\n}/find_missing_letter.cpp\n#include<stdio.h>\n#i", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world!\"t(result,{\"Hello\",\"world!\"}));\n}/split_words.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world!\" 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world!\"  }\n    return 0;\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint sum_of_digits(int n){\n    if (n==0)return 0;\n    int out=n%10;\n    return out+", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello, world!\");\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n\tresult = split_words(\"Hello, world! 123\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult = split_words(\"Hello, world! 123,\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult =", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"0\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello, world!\");\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n\tresult = split_words(\"Hello, world! 123\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult = split_words(\"Hello, world! 123,\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult =", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world\"\n\tassert(issame(result,{\"Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n}/split_words.cpp\n", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world\"t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456789", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world\"t(result,{\"1234567890\",\"1234567890\"}));\n\tresult = split_and_merge(\"1234567890\",\"123456789", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello,Hello,world\",\"!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,Hello,world!\");\n\tassert(issame(result,{\"Hello,Hello,world!\"}));\n\tresult = split_words(\"Hello,Hello,world\"t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456789", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello, world!\");\n\tassert(issame(result,{\"Hello\",\"world!\"}));\n\tresult = split_words(\"Hello, world! 123\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult = split_words(\"Hello, world! 123,\");\n\tassert(issame(result,{\"Hello\",\"world!\",\"123\"}));\n\tresult =", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"3\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"2\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello world, my name is \");\n\tassert(issame(result,{\"Hello\",\"world\",\"my\",\"name\",\"is\",\"John\",\"Smith\"}));\n\tresult = split_words(\"Hello world, my name is \");\n\tassert(issame(result,{\"Hello\",\"world\",\"my\",\"name\",\"is\",\"John", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello, world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello, world!\");\n\tassert(issame(result,{\"Hello\",\"world\"}));", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"1\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello,world\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello\",\"world\"}));\n\tresult = split_words(\"Hello,world,\");\n\tassert(issame(result,{\"Hello", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/125", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\nint main(){\n\tauto result = split_words(<FILL_ME>);\n\tassert(issame(result,{\"Hello\",\"world,!\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result,{\"Hello\",\"world\",\"!\"}));\n\tresult = split_words(\"Hello world,!\");\n\tassert(issame(result", "fn": "split_words", "para": "(string txt)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,10});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,10});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,10});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,10});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": true}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": true}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": false}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": true}
{"task_id": "CPP/126", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_sorted(vector<int> lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\nint main(){\n\tauto result = is_sorted(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==true);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==false);\n\tresult = is_sorted({1,2,3,4,5,6,7,8,9,10,1", "fn": "is_sorted", "para": "(vector<int> lst)", "type": "bool", "pass": true}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\t\t}\n\t\t}\n\t\tif (i==n) return 0;\n\t\tif (i==n-1) return 1;\n\t\tif (i==n-2) return 2;\n\t\tif (i==n-3) return 3;\n\t\tif (i==n-4) return 4;\n\t\tif (i==n-5) return 5;", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\t\t}\n\t\t}\n\t\tif (i==n) return 0;\n\t\tif (i==0) return 1;\n\t\tif (i==1) return 2;\n\t\tif (i==2) return 3;\n\t\tif (i==3) return 4;\n\t\tif (i==4) return 5;\n\t\tif (i==5) return ", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\t\t}\n\t\t}\n\t\tif (i==n) return 0;\n\t\tif (i==n-1) return 1;\n\t\tif (i==n-2) return 2;\n\t\tif (i==n-3) return 3;\n\t\tif (i==n-4) return 4;\n\t\tif (i==n-5) return 5;", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n,i,j,k,l,m,t;\n\tscanf(\"%d\",&t);\n\twhile (t--){\n\t\tscanf(\"%d\",&n);\n\t\tfor (i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tsort(a,", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"NO\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": true}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\t\t}\n\t\t}\n\t\tif (i==0) return 0;\n\t\treturn i;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.lengthOfLastWord(\"Hello World\")==5);\n\tassert(s.lengthOfLastWord(\"Hello\")==5);\n\tassert(s.lengthOfLastWord(\"Hello World  \")==5);\n\t", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,5},{2,6}\t\t}\n\t\t}\n\t\tif (i==n) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n\treturn 0;\n}#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<math.h>\n", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}t(result==1);\n}/src/test/cpp/leetcode/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint largestSumAfterKNegations(vector<int>& A, int K", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint maxSubArray(vector<int>& nums) {\n    int i,sum,max;\n    sum=max=nums[0];\n    for (", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/127", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring intersection( vector<int> interval1,vector<int> interval2){\n    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\nint main(){\n\tauto result = intersection(<FILL_ME>);\n\tassert(result==\"YES\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,3},{2,4}\t\t}\n\t\t}\n\t\tif (i==0) return 0;\n\t\treturn i;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.lengthOfLastWord(\"Hello World\")==5);\n\tassert(s.lengthOfLastWord(\"Hello\")==5);\n\tassert(s.lengthOfLastWord(\"Hello World  \")==5);\n\t", "fn": "intersection", "para": "( vector<int> interval1,vector<int> interval2)", "type": "string", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 0;\n\tassert(result==0);\n\treturnt==0", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    int i", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    int i;\n    for (i=2;i<=sqrt(n);", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    int i;\n    for (i=2;i<=sqrt(n);", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    int i;\n    for", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while(n>0){\n        count+=n&1;\n        n>>=1;\n    }\n    return", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,max", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    int i,max_sum=0,sum=0;\n    for (i=0;i<arr.size", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max=", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({0,0,0,0,0", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-10);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max=arr[", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max=arr[", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,max", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max=arr", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max=arr", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_bits(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count++;\n        n/=2", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    int i;\n    for (i=2;i<=sqrt(n);", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    int i;\n    for (i=2;i<=sqrt(n);", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==20);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5});\n\tassert(result==120);\n\tresult = prod_signs({-1,-2,-3,-4,-5});\n\tassert(result==120);\n\tresult = prod_signs({-1,2,-3,4,-5});\n\tassert(result==-120);\n\tresult = prod_signs({1,2,-3,4,-5", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{0,0,0,0,0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_product(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,max", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{0,0,0,0,0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_ones(int n){\n    int count=0;\n    while (n>0)\n    {\n        if (n%2==1) count", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{0,0,0,0,0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_subarray(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/128", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint prod_signs(vector<int> arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\nint main(){\n\tauto result = prod_signs(<FILL_ME>);\n\tassert(result==-32768);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<int>{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,", "fn": "prod_signs", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,10);\n}/leetcode/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint mergeStones(vector<int>&", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1},{1,1,1,1,1", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-99/001-099/001-010/009.cpp\n#include<stdio.h>\n#include<math.h", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-10/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = isToeplitzMatrix({{1,2,3,4},{5,1,2,3},{9,5,1,2}});\n\tassert(result==1);\n}/leetcode/866.cpp\n#", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});\n}/leetcode/1-10/9.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,5,1,5,1,5,1,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1t> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(vector<vector<int>>{{1,2,3},{", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5t(result,1);\n}/leetcode/1342.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint numberOfSteps (int num) {\n    int i=0;\n    while", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5;\n\tassert(issame(result,{1,2,3,4}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string>", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5;\n\tassert(issame(result,{1,2,3,4,5}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,7,1,7,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 5;\n\tassert(issame(result,{1,2,3,4}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string>", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,1);\n}/leetcode/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint largestSumAfterKNegations(vector<int> A, int", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,1);\n}/leetcode/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint largestSumAfterKNegations(vector<int> A, int", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10  }\n    return out;\n}\nint main(){\n\tauto result = findDisappearedNumbers({4,3,2,7,8,2,3,1});\n\tassert(issame(result,{5,6}));\n}/leetcode/448.cpp\n#include<stdio.h>\n#include<", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2,1,2,1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,10,1,10,1,10,1}}, 7t(result, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});\n}/leetcode/1-100/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>\n", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,10,1,10,1,10,1}}, 7;\n\tassert(issame(result,{1,2,3,4,5,6,7}));\n}/leetcode/1001-1100/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,10,1,10,1,10,1}}, 7  }\n    return out;\n}\nint main(){\n\tauto result = findDisappearedNumbers({4,3,2,7,8,2,3,1});\n\tassert(issame(result,{5,6}));\n}/leetcode/448.cpp\n#include<stdio.h>\n#include<math.", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,10,1,10,1,10,1}}, 7;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-100/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,10,1,10,1,10,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,10,1,10,1,10,1}}, 7;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-100/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(vector<vector<int>>{{1,2,3", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(vector<vector<int>>{{1,2,3", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,6,1,6,1,6,1,6,1,6,1,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(vector<vector<int>>{{1,2,3", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10\t\tif (i==0) {\n\t\t\tif (j==0) {\n\t\t\t\tif (s[i]==t[j]) {\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-99/001-099/001-010/009.cpp\n#include<stdio.h>\n#include<math.h", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t> out={};\n    for (i=0;i<n;i++)\n        for (j=0;j<n;j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1-100/001-010/009/009.cpp\n#include<stdio.h>\n#include<math.h>\n#", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-100/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>\n#include", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,3,1,3,1,3,1,3,1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-99/001-099/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3}));\n}/leetcode/118.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<vector<int>>", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 1);\n\tassert(issame(result,{1}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, 2);\n\tassert(issame(result,{1,2}));\n\tresult = minPath({{1,2,3},{4,5,6},{7,8,9}}, ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10;\n\tassert(issame(result,{1,2,3}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> common", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 10t(result, 1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> commonChars(vector<string>& A){\n   ", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 4t(result,1);\n}/leetcode/1005.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint largestSumAfterKNegations(vector<int> A, int K", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 4t(result,1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint countPrimes(int n){\n    int i,j,count=0;\n    vector<bool> prime(n", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 4;\n\tassert(issame(result,{1,2,3,4,5}));\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 4t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/129", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\nint main(){\n\tauto result = minPath(<FILL_ME>);\n\tassert(issame(result,{1,2,1,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{{1,2,3},{4,5,6},{7,8,9}}, 4;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-99/001-099/001-010/009.cpp\n#include<stdio.h>\n#include<math.h>", "fn": "minPath", "para": "(vector<vector<int>> grid, int k)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1001-1050/1001/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "t> out;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tout.push_back({a,b});\n\t}\n\tsort(out.begin(),out.end(),[](pair<int,int> a,pair<int,int> b){\n\t\treturn a.second<b.second;\n\t});\n\t", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1001-1050/1001/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "  }\n    return out;\n}\nint main(){\n\tauto result = tri(10);\n\tassert(issame(result,{1,3,2,8,3,15,4,24}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int>", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return out;\n}\nint main(){\n\tauto result = tri(10);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> seq(int n){\n    vector<int> out;\n    for (int i=1;i<=", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1};\n    if (", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tassert(result,10);\n}#include<stdio.h>\n#include<math.h>\n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> one_to_ten(){\n    vector<", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};/leetcode/1200-1299/1200.cpp\nclass Solution {\npublic:\n\tvector<int> minimumAbsDifference(vector<int>& arr) {\n\t\tsort(arr.begin(), arr.end());\n\t\tint min = INT_MAX;\n\t\tfor (int i = 0; i < arr.", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,10);\n}/10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tasser/11.cpp\n#include<stdio.h>\n#include<math.h>\n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,9}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,7}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,6,10}));\n\tresult = tri(5);\n\tassert(issame(result,{", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,9}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,6}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,6,10}));\n\tresult = tri(5);\n\tassert(issame(result,{", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n   ", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int a,b;\n    while (scanf(\"%d%d\",&a,&b)!=EOF)\n    {\n        printf(\"%d\\", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/1001-1050/1009/1009.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return out;\n}\nint main(){\n\tauto result = tri(10);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return out;\n}\nint main(){\n\tauto result = tri(10);\n\tassert(issame(result,{1,3,2,8,3,15,4,24,5}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,10);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort(vector<int> in){\n    vector", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort(vector<int> in){\n    vector<int> out;\n    for (int i=0;", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n   ", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3  }\n    return out;\n}\nint main(){\n\tauto result = tri(3);\n\tassert(issame(result,{1,3,2,8,3}));\n}/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3  }\n    return out;\n}\nint main(){\n\tauto result = tri(3);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}/cpp/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10  }\n    return out;\n}\nint main(){\n\tauto result = tri(10);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tauto result = s.getRow(3);\n\tassert(issame(result,{1,3,3,1}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}/leetcode/1-100/1-10/1-10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t> out;\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        cin>>a>>b;\n        out.push_back({a,b});\n    }\n    sort(out.begin(),out.end(),[](pair<int,int> a,pair<int,int> b){\n        return a.second<b.second;\n    });\n    int ans=0;\n    for (int", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n   ", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "4;\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sort(vector<int> in){\n    vector<int> out;\n    for", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10\t\t}\n\t\t}\n\t\tif (i==0) return 0;\n\t\treturn i;\n\t}\n};\nint main(){\n\tSolution s;\n\tassert(s.lengthOfLastWord(\"Hello World\") == 5);\n\tassert(s.lengthOfLastWord(\"Hello World \") == 5);\n\tassert(s.lengthOfLastWord(\"Hello World  \") == 5);\n\tassert", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8,3,15,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "5t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,9}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,7}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=n%10;\n        n/=10;\n    }\n    return out;\n}\nint main", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "t(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int>& A) {\n    int n=A.size();\n    vector<int> out(n);\n    int i=0,j=n", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1);\n\tassert(issame(result,{1}));\n\tresult = tri(2);\n\tassert(issame(result,{1,3}));\n\tresult = tri(3);\n\tassert(issame(result,{1,3,5}));\n\tresult = tri(4);\n\tassert(issame(result,{1,3,5,9}));\n\tresult = tri(5);\n\tassert(issame(result,{1", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3  }\n    return out;\n}\nint main(){\n\tauto result = tri(3);\n\tassert(issame(result,{1,3,2,8}));\n}/tri.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> sortArrayByParity(vector<int>& A) {\n    vector<int> out;\n    for (int i=0;i<A.", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9}));\n}/leetcode/1-9/1-9.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> one_to_nine(){\n   ", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/130", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> tri(int n){\n    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\nint main(){\n\tauto result = tri(<FILL_ME>);\n\tassert(issame(result,{1,3,2,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "3t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34", "fn": "tri", "para": "(int n)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPalindrome(int x){\n    if (x<0) return 0;\n    string s=to_string(x);\n    for (int i=0", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    for (int i=", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789  }\n    return 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n;\n    while(scanf(\"%d\",&n)!=EOF){\n        printf(\"%d\\n", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = isPalindrome(123456789);\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\",", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n       ", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPrime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==2625);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    for (int i=2;", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 0;\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\t", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    if (n==0) return 0;\n    while (n%2==0) n/=2;\n    return n==1;\n", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_prime(10);\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n\t", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    if (n==2) return 1;\n    for (int i", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize){\n    int res=0;\n    for (int i=0;i", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_prime(12345);\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==315);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123456789;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    if (n==0) return 0;\n    if (n==1) return 1;\n    if (n%2==0", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n        if (n%i==", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}\n/leetcode/101.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = isPowerOfTwo(1);\n\tassert(result==1);\n\tresult = isPowerOfTwo(16);\n\tassert(result==1);\n\tresult = isPowerOfTwo(3);\n\tassert(result==0);\n}#include<stdio.h>\n#include<math", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/131", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digits(int n){\n    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\nint main(){\n\tauto result = digits(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12345\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPowerOfTwo(int n){\n    if (n==0) return 0;\n    if (n==1) return 1;\n    if (n%2==0)", "fn": "digits", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int number, int digit){\n    int count=0;\n    while (number>0)\n    {\n        if (number%10==digit) count+=1;", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int number, int digit){\n    int count=0;\n    while (number>0)\n    {\n        if (number%", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"t(result==1);\n}/test/test_is_palindrome.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\n#include<assert.h>\nbool is_palindrome(string str){\n    int i=0,j=str.length()-1", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[[]]]\" 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_palindrome(\"abba\");\n\tassert(result==true);\n\tresult = is_palindrome(\"abb\");\n\tassert(result==false);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_palindrome(string str){\n    int i=0,j=str.length()-1;\n    while (i<j)\n    {\n        if (str[i]!=str[", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"t(result==1);\n}/test/test_is_palindrome.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_palindrome(string str){\n    int i=0,j=str.length()-1;\n    while (i<j)", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int result=0;\n    for (int i=0;i<numsSize", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": true}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int number, int digit){\n    int count=0;\n    while (number>0)\n    {\n        if (number%10==digit) count+=1;\n        number", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i=0;i<n;i++)\n    {\n        sum+=arr[i", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": false}
{"task_id": "CPP/132", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_nested(string str){\n    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\nint main(){\n\tauto result = is_nested(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"[][[]]\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing(int arr[],int n){\n    int sum=0;\n    for (int i=0;i<n;i++)\n    {\n        sum+=arr[i];", "fn": "is_nested", "para": "(string str)", "type": "bool", "pass": true}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n==1) return 0;\n    for (int i=2;i<=sqrt(n);i", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0}t_name, \"r\") as f:\n        for line in f:\n            line = line.strip()\n            if line:\n                yield line\n\ndef main():\n    for line in read_file():\n        print(line)\n\nif __name__ == \"__main__\":\n    main()\n/python/file_read.py\ndef read_file(file_name):", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0}t(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0}t(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0}t(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==75);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0} 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==29);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0} 100000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==10230);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0}\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_positives_sum_negatives(vector<int> lst){\n    int sum=0;\n    int count=0;\n    for (", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_even_index(vector<int> arr){\n    int sum=0;\n    for (int i=0;i<arr.size", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==84);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0} 10000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    for (int i=2;i<=sqrt(n", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1086);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1086);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==1086);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,1.5} 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,1.5}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,1.4142135623730951,1.7320508075688772});\n\tassert(result==5);\n\tresult = sum_squares({4.0,3.0,2.0,1.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,1.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "vector<float>{1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0}t(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/133", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<float> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==200000000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_multiples(int n){\n    int sum=0;\n    for (int i=1", "fn": "sum_squares", "para": "(vector<float> lst)", "type": "int", "pass": false}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"t_of_numbers(1,2,3,4,5,6,7,8,9,10);\n\tassert(result==55);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_numbers(int a,int b,int", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": false}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"t_of_numbers(1,2,3,4,5,6,7,8,9,10);\n\tassert(result==55);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_numbers(int a, int b, int", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": false}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"\n\tassert(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": true}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_vowels(string txt){\n    int count=0;\n    for (int i=0;i<txt.length();i++){\n        char chr=txt[i];\n        if", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": true}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\"t_is_a_letter(\"a\");\n\tassert(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": false}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a4\");\n\tassert(result==false);\n\tresult = check_if_last_char_is_a_letter(\"123a45", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": true}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a4\");\n\tassert(result==false);\n\tresult = check_if_last_char_is_a_letter(\"123a45", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": true}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"123a4\");\n\tassert(result==false);\n\tresult = check_if_last_char_is_a_letter(\"123a4b", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": true}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1b\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1b2\");\n\tassert(result==true", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": false}
{"task_id": "CPP/134", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\nint main(){\n\tauto result = check_if_last_char_is_a_letter(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"a\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1b\");\n\tassert(result==true);\n\tresult = check_if_last_char_is_a_letter(\"a1b2\");\n\tassert(result==true", "fn": "check_if_last_char_is_a_letter", "para": "(string txt)", "type": "bool", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/135", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint can_arrange(vector<int> arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\nint main(){\n\tauto result = can_arrange(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10,11});\n\tassert(result==-1);\n\tresult = can_arrange({1,2,3,4,5,6,7,8,9,10", "fn": "can_arrange", "para": "(vector<int> arr)", "type": "int", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({1,2", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,1}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-5,-1}));\n\tresult = largest_smallest_integers({-1,0});\n\tassert(issame(result,{-1,0}));\n\tresult = largest_smallest", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,1}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-5,-1}));\n\tresult = largest_smallest_integers({-1,0});\n\tassert(issame(result,{-1,0}));\n\tresult = largest_smallest", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,0}));\n\tassert(issame(result,{0,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-3,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-1,1}));\n\tresult = largest_smallest_integers({-5,-4,-3,-2,-1});\n\tassert(issame(result,{-5,1}));\n\t", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,0}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,0,1});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,0,1,2});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,0", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,0});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({1,2,3,4,5});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,1}));\n\tresult = largest_smallest_integers({0,0", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,1}));\n\tresult = largest_smallest_integers({1,2", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-7,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{10,-1}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0,-10}));\n\tresult = largest_smallest_integers({1,2,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,11}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0,1}));\n\tresult = largest_smallest_integers({-1,2,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{9,0}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0,-10}));\n\tresult = largest_smallest_integers({-1,0,1", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,1,2,3,4,5,6,7,8,9});\n\tassert(issame(result,{9,0}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0,-10}));\n\tresult = largest_smallest_integers({-1,0,1", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{0,11}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{0,-1}));\n\tresult = largest_smallest_integers({-1,2,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-10}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,0}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-5,1}));\n\tresult = largest_smallest_integers({-5,1,2,3,4,5});\n\tassert(issame(result,{-5,1}));", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,10}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-10,-1}));\n\tresult = largest_smallest_integers({-1,", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/136", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> largest_smallest_integers(vector<int> lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\nint main(){\n\tauto result = largest_smallest_integers(<FILL_ME>);\n\tassert(issame(result,{-2,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{0,1}));\n\tresult = largest_smallest_integers({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-5,1}));\n\tresult = largest_smallest_integers({-1,1});\n\tassert(issame(result,{-1,1}));\n\tresult = largest_smallest", "fn": "largest_smallest_integers", "para": "(vector<int> lst)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1\",\"2\"\n\tassert(boost::any_cast<string>(result)==\"2\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  num", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1\",\"2\"t(a.begin(),a.end(),b.begin(),b.end());\n\tcout<<a<<endl;\n}/test/test_algorithm.cpp\n#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint main(){\n\tstring a=\"123456789\";\n\tstring b=\"12345678", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1\",\"2\"e<int> > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > >", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1\",\"2\"\n\tassert(boost::any_cast<string>(result)==\"2\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  num", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1\",\"2\"\n\tassert(boost::any_cast<string>(result)==\"2\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  num", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2,3\", \"1,2\"t(1,2,3,4,5,6,7,8,9,10);\n\tcout<<a.size()<<endl;\n\tcout<<a.front()<<endl;\n\tcout<<a.back()<<endl;\n\tcout<<a.at(3)<<endl;\n\tcout<<a.max()<<endl;\n\tcout<<a.min()", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1,2\", \"2,3\"  }\n    }\n    return 0;\n}\n/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2,3\", \"2,3\");\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(2, 3);\n\tassert(boost::any_cast<int>(result)==3);\n\tresult = compare_one(2.3, 3.4);\n\tassert(boost::any_cast<double>(result)==3.4);\n\tresult = compare_one(\"2", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2,3\",\"1,2\"  return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2,3\", \"2,3\");\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(\"2,3\", \"2,4\");\n\tassert(boost::any_cast<string>(result)==\"2,3\");\n\tresult = compare_one(\"2,4\", \"2,3\"\n\tassert(boost::any_cast<string>(result)==\"2,", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"5\",\"6\"\n\tassert(boost::any_cast<string>(result)==\"6\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  num", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"5\",\"6\"t(a.begin(),a.end(),b.begin(),b.end());\n    for (int i=0;i<a.size();i++)\n        if (a[i]!=b[i]) return false;\n    return true;\n}\nint main(){\n    vector<int> a={1,2,3,4,5};\n    vector<int> b={1,2,3,4,5", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"5\", \"6\"\n\tassert(boost::any_cast<string>(result)==\"6\");\n}/test/test_compare_one.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"5\",\"6\"\n\tassert(boost::any_cast<int>(result)==1);\n}/test/test_any_cast.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"6\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"5\", \"6\"\n\tassert(boost::any_cast<int>(result)==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  num", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.0,2.0);\n\tassert(boost::any_cast<double>(result)==1.0);\n\tresult = compare_one(2.0,1.0);\n\t", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.0,2.0);\n\tassert(boost::any_cast<double>(result)==1.0);\n\tresult = compare_one(2.0,1.0);\n\t", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.0,2.0);\n\tassert(boost::any_cast<double>(result)==1.0);\n\tresult = compare_one(2.0,1.0);\n\t", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.0,2.0);\n\tassert(boost::any_cast<double>(result)==1.0);\n\tresult = compare_one(2.0,1.0);\n\t", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.1,2.2);\n\tassert(boost::any_cast<double>(result)==1.1);\n\tresult = compare_one(2.2,1.1);\n\t", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\",\"123\";\n\tassert(boost::any_cast<int>(result)==1);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\",\"123\"\n\tassert(boost::any_cast<string>(result)==\"None\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\",\"123\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1.0\", \"1.0\"\n\tassert(boost::any_cast<string>(result)==\"None\");\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<string>(result)==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\",\"123\");\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(123,123);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(123.123,123.123);\n\tassert(boost::any_cast<string>(result)==\"None\");", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\",123);\n\tassert(boost::any_cast<string>(result)==\"123\");\n\tresult = compare_one(123,\"123\");\n\tassert(boost::any_cast<string>(result)==\"123\");\n\tresult = compare_one(123,123);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult =", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(2,1);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1,1);\n\tassert(boost::any_cast<string>(result)==\"None\");\n\tresult = compare_one(1.1,1.2);\n\tassert(boost::any", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123\", 6t(result)==1);\n}/test/test_any_cast.cpp\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = boost::any_cast<int>(\"123", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1.23\", 6\n\tassert(boost::any_cast<int>(result)==6);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<int>(result)==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.0,2.0);\n\tassert(boost::any_cast<double>(result)==2.0);\n\tresult = compare_one(1.0,2);\n\tassert(boost::any_cast<double>(result)==2.0);\n\tresult = compare_one(1,2.0);", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2.5);\n\tassert(boost::any_cast<int>(result)==1\n\tassert(boost::any_cast<double>(result)==2.5);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2.5);\n\tassert(boost::any_cast<int>(result)==1t(1,2,3,4,5,6,7,8,9,10);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==1);\n\tresult = compare_one(1.5,2.5);\n\tassert(boost::any_cast<double>(result)==1.5);\n\tresult = compare_one(2.5,1.5);\n\tassert(boost::any_cast<double>(result)==2.5);\n\tresult = compare_one(\"1.5\",", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2.5);\n\tassert(boost::any_cast<int>(result)==1\n\tassert(boost::any_cast<double>(result)==2.5);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": true}
{"task_id": "CPP/137", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\n#include<stdlib.h>\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\nint main(){\n\tauto result = compare_one(<FILL_ME>);\n\tassert(boost::any_cast<double>(result)==2.5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1,2);\n\tassert(boost::any_cast<int>(result)==2);\n\tresult = compare_one(1.5,2.5);\n\tassert(boost::any_cast<double>(result)==1.5);\n\tresult = compare_one(2.5,1.5);\n\tassert(boost::any_cast<double>(result)==2.5);\n\tresult = compare_one(\"1.5\",", "fn": "compare_one", "para": "(boost::any a,boost::any b)", "type": "boost::any", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_digits", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": true}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count = 0;\n    while(n!=0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": true}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_digits", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": true}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "8t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint get_max_digit(int n){\n    int max_digit = 0;\n    while(n>0){\n        int digit = n%10;\n        if (digit>max_digit) max_digit = digit", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": true}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10);\n\tassert(result==true);\n\tresult = is_equal_to_sum_even(11);\n\tassert(result==false);\n\tresult = is_equal_to_sum_even(12);\n\tassert(result==true);\n\tresult = is_equal_to_sum_even(13);\n\tassert(result==false);\n\tresult = is_equal_to_sum_even(", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while(n>0){\n        n/=10;\n        count++;\n    }\n    return count;\n}\nint main(){\n\tauto result = count_", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/138", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_sum_even(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10t(result==true);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_equal_to_sum_even(int n){\n    if (n%2==0 and n>=8) return true;\n    return false;\n}\nint main(){\n\tauto result = is_equal_to_", "fn": "is_equal_to_sum_even", "para": "(int n)", "type": "bool", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bf", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": true}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 1000000007;\n\t}\n\treturn 0;\n}#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tint a[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        if (a>", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    int a[n],b[m];\n    for (int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==288);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": " 0;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint a[n+1];\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10;;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==125411328000);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return 0;\n}/Codeforces/1200/1200B.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        int a[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin>>a[", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": ";\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/139", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long special_factorial(int n){\n    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\nint main(){\n\tauto result = special_factorial(<FILL_ME>);\n\tassert(result==34560);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tasser#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main", "fn": "special_factorial", "para": "(int n)", "type": "long long", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Example\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i=0;i<n;i++)\n    sum+=arr[i];\n    int sum2", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Example\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i=0;i<n;i++)\n    sum+=arr[i];\n    int sum2", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Example\"\n\tassert(result==1);\n}/C++/1000/1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint result=", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Example\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0;\n    while (n>0)\n    {\n        sum+=n%10;\n        n/=10;\n    }\n    return sum", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Example\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Example\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='a' || text[", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Yellow Yellow Dirty Fellow\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing(int arr[], int n){\n    int sum=0;\n    for (int i=0;i<n;i++)\n    sum+=arr", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Yellow Yellow Dirty Fellow\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing(int arr[], int len){\n    int sum=0;\n    for (int i=0;i<len;i++) sum+=arr[i];\n   ", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Yellow Yellow Dirty Fellow\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Yellow Yellow Dirty Fellow\"t_to_string(1234567890);\n\tassert(result==\"1234567890\");\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_string(int number){", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Yellow_Yellow__Dirty__Fellow\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Yellow Yellow Dirty Fellow\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Mudasir Hanif\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Mudasir Hanif\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Mudasir Hanif\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Mudasir Hanif\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Mudasir_Hanif_\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Mudasir Hanif\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\"\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='a'", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Ex a mple\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='a'", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='a'||", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"Exa-mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string text){\n    int count=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]=='a'", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\");\n\tassert(result==\"-Exa_mple\");\n\tresult = fix_spaces(\"Exa  mple\");\n\tassert(result==\"-Exa__mple\");\n\tresult = fix_spaces(\"Exa   mple\");\n\tassert(result==\"-Exa___mple\");\n\tresult = fix_spaces(\"Exa 1 2 2 mple\"\n\tassert(result", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\");\n\tassert(result==\"-Exa_mple\");\n\tresult = fix_spaces(\"Exa 1 2 2 mple\"t(result==\"-1\");\n}/cpp/1000000000000000000000000000000000000000000000", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\");\n\tassert(result==\"-Exa_mple\");\n\tresult = fix_spaces(\"Exa  mple\");\n\tassert(result==\"-Exa__mple\");\n\tresult = fix_spaces(\"Exa   mple\");\n\tassert(result==\"-Exa___mple\");\n\tresult = fix_spaces(\"Exa    mple\");\n\tassert(result==\"-Exa____mple\");", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\");\n\tassert(result==\"Exa_mple\");\n\tresult = fix_spaces(\"Exa 1 2 2 mple\"t(result==1);\n\tresult = is_prime(1000000007);\n\tassert(result==0);\n}/is_prime.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/140", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring fix_spaces(string text){\n    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\nint main(){\n\tauto result = fix_spaces(<FILL_ME>);\n\tassert(result==\"-Exa_1_2_2_mple\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Exa mple\");\n\tassert(result==\"-Exa_mple\");\n\tresult = fix_spaces(\"Exa 1 2 2 mple\"t(result==\"-1\");\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_missing(int arr[],", "fn": "fix_spaces", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"123456.txt\");\n\tassert(result==\"No\");\n\tresult = file_name_check(\"123.txt.txt\");\n\tassert(result==\"No\");\n\tresult = file_", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": true}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\" 0;\n}/C++/1000~1999/1000~1099/1000/1000.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint a,", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"123456789012345678901234567890123456789012345678901234567890123456789012345", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": true}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.exe\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.dll\");\n\tassert(result==\"Yes\");\n\tresult = file_name", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": true}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"No\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.txt\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.exe\");\n\tassert(result==\"Yes\");\n\tresult = file_name_check(\"12345.dll\");\n\tassert(result==\"Yes\");\n\tresult = file_name", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": true}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\" 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\" 0;\n}#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint a[n+1];\n\tfor (int i=1;i<=n", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\"t(result==1);\n}#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    for (int i=2;i<=sqrt(n);i++)\n    {\n        if (", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\" 1;\n    }\n    return 0;\n}\nint main(){\n\tauto result = is_prime(10);\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n    if", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/141", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring file_name_check(string file_name){\n    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\nint main(){\n\tauto result = file_name_check(<FILL_ME>);\n\tassert(result==\"Yes\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"123.txt\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(int *a,int n){\n    int max_sum=0,sum=0;\n    for (int i=0;i<n", "fn": "file_name_check", "para": "(string file_name)", "type": "string", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}/test/test_sum_squares.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    if (n<2) return 0;\n    for (int i=", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==14);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}/1001.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==0);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==10);\n}/test/test_sum_squares.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-126);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_positives_sum_negatives(vector<int> lst){\n    int sum=0;", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-1448);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}  return 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<int> lst(n);", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==3030);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6}\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n       ", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6}t_sum(lst, 3);\n\tassert(result==12);\n}/test/test_sum.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum(vector<int> lst, int n){\n   ", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==6);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_even_fibonacci(int n){\n    int sum=0;\n    int a=1,b", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==-14196);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10} 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n\tfor (int", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9} 10000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/142", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\nint main(){\n\tauto result = sum_squares(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst", "fn": "sum_squares", "para": "(vector<int> lst)", "type": "int", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"goforit\"t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    for (int i=2;i*i<=n", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"goforit\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out++;\n        n/=10;\n    }\n    return out;\n}\nint", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"go for it\"t(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint result=0;\n\tfor (int i", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"goforit\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out++;\n        n/=10;\n    }\n    return out;\n}\nint", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"goforit\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"goforit\"t.push_back(i);\n    }\n    return out;\n}\nint main(){\n\tauto result = find_all_primes(100);\n\tassert(result.size()==25);\n}/find_all_primes.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"thereisnoplace\" 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tcout << max_sum(a, n);\n}/max_sum.cpp\n#include<iostream", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"thereisnoplace\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_vowels(string word){\n    int out=0;\n    for (int i=0;i<word.length();i++)\n        if (word[i", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"thereisnoplace\"t(result==1);\n}/100/100.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_ones(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=n%2;", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"thereisnoplace\"t(result==1);\n}/1000/1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint result=a", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"thereisnoplace\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"thereisnoplace\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out++;\n        n/=10;\n    }\n    return out;\n}\n", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"gofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"gofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"gofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"gofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"gofor123\");\n\tassert(result==\"gofor123\");\n\tresult = words_in_sentence(\"gofor1234567890\");\n\tassert(result==\"gofor1234567890\");\n\tresult = words_in_sentence(\"gofor12345", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"gofor\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"gofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence(\"goforgoforgoforgofor\");\n\tassert(result==\"gofor\");\n\tresult = words_in_sentence", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is is is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is is is is\");\n\tassert", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is is", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"is\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"is\");\n\tassert(result==\"is\");\n\tresult = words_in_sentence(\"is not\");\n\tassert(result==\"is not\");\n\tresult = words_in_sentence(\"is not a\");\n\tassert(result==\"is not a\");\n\tresult = words_in_sentence(\"is not a prime\");\n\tassert(result==\"is not a prime\");\n\tresult = words_in_sentence(\"is not a prime number\");\n", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = words_in_sentence(\"a\");\n\tassert(result==\"a\");\n\tresult = words_in_sentence(\"a b\");\n\tassert(result==\"a b\");\n\tresult = words_in_sentence(\"a b c\");\n\tassert(result==\"a b c\");\n\tresult = words_in_sentence(\"a b c d\");\n\tassert(result==\"a b c d", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = words_in_sentence(\"a\");\n\tassert(result==\"a\");\n\tresult = words_in_sentence(\"a b\");\n\tassert(result==\"a b\");\n\tresult = words_in_sentence(\"a b c\");\n\tassert(result==\"a b c\");\n\tresult = words_in_sentence(\"a b c d\");\n\tassert(result==\"a b c d", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = words_in_sentence(\"a\");\n\tassert(result==\"a\");\n\tresult = words_in_sentence(\"a b\");\n\tassert(result==\"a b\");\n\tresult = words_in_sentence(\"a b c\");\n\tassert(result==\"a b c\");\n\tresult = words_in_sentence(\"a b c d\");\n\tassert(result==\"a b c d", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = words_in_sentence(\"a\");\n\tassert(result==\"a\");\n\tresult = words_in_sentence(\"a b\");\n\tassert(result==\"a b\");\n\tresult = words_in_sentence(\"a b c\");\n\tassert(result==\"a b c\");\n\tresult = words_in_sentence(\"a b c d\");\n\tassert(result==\"a b c d", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\");\n\tassert(result==\"\");\n\tresult = words_in_sentence(\"a\");\n\tassert(result==\"a\");\n\tresult = words_in_sentence(\"a b\");\n\tassert(result==\"a b\");\n\tresult = words_in_sentence(\"a b c\");\n\tassert(result==\"a b c\");\n\tresult = words_in_sentence(\"a b c d\");\n\tassert(result==\"a b c d", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": true}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiamHussein\";\n\tassert(result==1);\n}/C++/10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiamHussein\"t(result==1);\n}/C++/10000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiamHussein\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n/=10;\n        count++;\n    }\n    return", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiamHussein\"t(result==1);\n}/C++/10000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/143", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring words_in_sentence(string sentence){\n    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\nint main(){\n\tauto result = words_in_sentence(<FILL_ME>);\n\tassert(result==\"HiamHussein\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"HiamHussein\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_digits(int n){\n    int count=0;\n    while (n>0)\n    {\n        n/=10;\n        count++;\n    }\n    return count;\n", "fn": "words_in_sentence", "para": "(string sentence)", "type": "string", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find(string s){\n    int i,j,k,l,m,n,o,p,q,r,t,u,v,w", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\");\n\tassert(result==true);\n\tresult = simplify(\"1/2\",\"1/3\");\n\tassert(result==false);\n\tresult = simplify(\"1/2\",\"1/4\"t(result==1);\n\tresult = findKthLargest(vector<int>{3,2,1,5,6,4},2);\n\tassert(result==5);\n\t", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": true}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\");\n\tassert(result==true);\n\tresult = simplify(\"1/2\",\"1/3\");\n\tassert(result==false);\n\tresult = simplify(\"1/2\",\"1/4\";\n\tassert(result==1);\n\tresult = findKthLargest(vector<int>{3,2,1,5,6,4},2);\n\tassert(result==5", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": true}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\");\n\tassert(result==true);\n\tresult = simplify(\"1/2\",\"1/3\");\n\tassert(result==false);\n\tresult = simplify(\"1/2\",\"1/4\");\n\tassert(result==false);\n\tresult = simplify(\"0/1\",\"0/2\");\n\tassert(result==false);\n\tresult = simplify(\"4/2\",\"2/3\"", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": true}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\");\n\tassert(result==true);\n\tresult = simplify(\"1/2\",\"1/3\");\n\tassert(result==false);\n\tresult = simplify(\"1/2\",\"1/4\");\n\tassert(result==false);\n\tresult = simplify(\"0/1\",\"0/2\";\n\tassert(result==1);\n\tresult = findKthLargest(vector<int", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": true}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\"\n\tassert(result==1);\n}/1001-1050/1008.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint n,i,j,k,a[10", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\";\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(int* nums, int numsSize) {\n    int i,j,k;\n    for (i=", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\";\n\tassert(result==1);\n}/leetcode/104.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<assert.h>\n#include<queue>\n#include<stack>\n", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\"  }\n    return 0;\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<unordered_map>\n#", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/144", "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nbool simplify(string x,string n){\n    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\nint main(){\n\tauto result = simplify(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1/2\",\"1/2\"t(result==1);\n}/leetcode/1005.cpp\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint largestSumAfterKNegations(vector<int>& A, int K) {\n    sort(A.begin(),A.end", "fn": "simplify", "para": "(string x,string n)", "type": "bool", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,10,2,11,3,4,5,6,7,8,9};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,10,2,11,3,4,5,6,7,8,9}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"});\n}/leetcode/1207.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,10,2,11,3,4,5,6,7,8,9}  }\n    return result;\n}\nint main(){\n\tauto result = find_all_numbers({1,10,2,11,3,4,5,6,7,8,9});\n\tassert(issame(result,{1,10,2,11,3,4,5,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,10,2,11,3,4,5,6,7,8,9};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{1,10,2,11,3,4,5,6,7,8,9}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,10,2,11,3,4,5,6,7,8,9}  }\n    return result;\n}\nint main(){\n\tauto result = find_all_numbers(1000000000);\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11,12,13", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-3,-32,-98,-11,1,2,43,54}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = order_by_points({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-1,-2,-3,-4,-5}));\n\tresult = order_by_points({1,-1});\n\tassert(issame(result,{1,-1}));\n\t", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = order_by_points({1,2,3,4,5,10});\n\tassert(issame(result,{1,2,3,4,5,10}));\n\tresult = order_by_points({1,2,3,4,5,10,10", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n\tresult = order_by_points({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10});\n\tassert(issame(result,{-1,-2,-3,-", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = order_by_points({1,1,1,1,1});\n\tassert(issame(result,{1,1,1,1,1}));\n\tresult = order_by_points({1,2,3,4,5});\n\tassert(issame(result,{1,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = order_by_points({1,1,1,1,1});\n\tassert(issame(result,{1,1,1,1,1}));\n\tresult = order_by_points({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457};\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457});\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}t i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (nums[j-1]>nums[j])\n    {\n        m", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457});\n\tassert(issame(result,{0,2,3,6,53,423,423,423,1234,145,37,46,56", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6, 4, 0, -21, -23, 23, 6};\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}));\n}/leetcode/letter_case", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6, 4, 0, -21, -23, 23, 6} 1000000000;\n\tint n = 1000000000;\n\tint k = 1000000000;\n\tint result = solution(n, k);\n\tcout << result << endl;\n\treturn 0;\n}", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6, 4, 0, -21, -23, 23, 6} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tauto result = is_palindrome(121);\n\tassert(result==1);\n}/leetcode/palindrome_number.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-76,-21,0,4,23,6,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{6, 4, 0, -21, -23, 23, 6};\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}));\n}#include<stdio.h", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5});\n\tassert(issame(result,{1,2,3,4,5}));\n\tresult = order_by_points({-1,-2,-3,-4,-5});\n\tassert(issame(result,{-5,-4,-3,-2,-1}));\n\tresult = order_by_points({1,-1,3,-3,5});\n\tassert(issame(result,{", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-1,-11,1,-12,11} 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tcout<<max_subarray(a,n);\n}/max_subarray.cpp\n", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{-1,-11,1,-12,11}\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}));\n}/leetcode/letter_case_permutation.cpp\n#include<stdio.h", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,-11,11,-12,111}t(result,{\"111\",\"111111111111111111111111111111111111111111111111111111111111111111111111", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/145", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\nint main(){\n\tauto result = order_by_points(<FILL_ME>);\n\tassert(issame(result,{-1,-11,1,-12,11}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,-11,11,-12,111};\n\tassert(issame(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}));\n}/leetcode/letter_case_permutation.cpp\n#include<", "fn": "order_by_points", "para": "(vector<int> nums)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(vector<int> nums){\n    int num=0;\n    for", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": true}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(vector<int> nums){\n    int num=0;\n    for (int", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(vector<int> nums){\n    int num=0;\n    for (int", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count(vector<int> nums){\n    int num=0;\n   ", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint isPrime(int num){\n    if (num==1) return 0;\n   ", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}  }\n    return result;\n}\nint main(){\n\tauto result = findMaxConsecutiveOnes({1,1,0,1,1,1});\n\tassert(result==3);\n}/leetcode/findMaxConsecutiveOnes.cpp\n#include<stdio.h>\n#include<math.h>\n", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10}t(result==1);\n}/test/test1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n   ", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 91});\n\tassert(result==3t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": true}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10);\n\tresult = specialFilter({1,2,3,4,5,6,7,8,9,10,11,12,13,14", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10);\n\tresult = specialFilter({1,2,3,4,5,6,7,8,9,10,11,12,13,14", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==3t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10  }\n    return result;\n}\nint main(){\n\tauto result = findOdd({20,1,-1,2,-2,3,3,5,", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10;\n\tassert(result==1);\n}/leetcode/1281.cpp\n#include<stdio.h>\n#include<math.h>", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==0);\n\tresult = specialFilter({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10);\n\tresult", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10  }\n    return result;\n}\nint main(){\n\tauto result = findOdd({20,1,-1,2,-2,3,3,5,", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20});\n\tassert(result==10t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==2;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==1 1000000000;\n\tassert(result==1000000000);\n}/1000000000.cpp\n#include<stdio.h>\n", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}  }\n    return result;\n}\nint main(){\n\tauto result = findMaxConsecutiveOnes({1,1,0,1,1,1});\n\tassert(result==3);\n", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==3 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 90});\n\tassert(result==1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 91});\n\tassert(result==1 1000000000000000000;\n\tassert(result==1000000000000000000);\n}/cpp/1", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/146", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint specialFilter(vector<int> nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\nint main(){\n\tauto result = specialFilter(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{12, 23, 34, 45, 56, 67, 78, 89, 91});\n\tassert(result==1t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h", "fn": "specialFilter", "para": "(vector<int> nums)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    return result;\n}\nint main(){\n\tauto result = get_matrix_triples(1000000000);\n\tassert(result==53361);\n}/main.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "  }\n    }\n    return result;\n}\nint main(){\n\tauto result = get_max_profit(vector<int>{1,2,3,4,5});\n\tassert(result==4);\n}/leetcode/121.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t_matrix_triples(1000000000);\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "t_matrix_triples(n);\n\tassert(result==53361);\n}/test/test_matrix_triples.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<assert.h>\n#include\"matrix_triples.h\"\nint main(){\n", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==53361);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> a={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.find_kth_smallest(a,10);\n\tassert(result==10);\n}/leetcode/215.cpp\n#include", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}/leetcode/1011.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint shipWithinDays(vector<int>& weights, int D) {\n    int max_weight=0;\n    for (int i=0;i", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000 1000000000);\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_max_sum(int n){\n    vector<int", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000    }\n    return result;\n}\nint main(){\n\tauto result = get_max_sum_of_subarray(vector<int>{1,2,3,4,5,6,7,8,9,10});\n\tassert(result==55);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10;\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_max_subarray_sum(vector<int> a){\n    int max_sum=0;\n    int sum=0;\n    for (int i=0;i<a.", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==4);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000;\n\tassert(result==1);\n}/10000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1;\n\tassert(result==1);\n}/leetcode/1202.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<set>\n#include<map>", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1  }\n    return result;\n}\nint main(){\n\tauto result = get_matrix_triples(1);\n\tassert(result==1);\n}/cpp/get_matrix_triples.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1  }\n    return result;\n}\nint main(){\n\tauto result = get_matrix_triples(1);\n\tassert(result==1);\n}/cpp/get_matrix_triples.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t_matrix_triples(1);\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1    }\n    return result;\n}\nint main(){\n\tauto result = get_matrix_triples(1);\n\tassert(result==1);\n}/leetcode/1512.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10 0;\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000t_matrix_triples(1000000000);\n\tassert(result==36);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000  }\n    }\n    return result;\n}\nint main(){\n\tauto result = get_max_subarray_sum(vector<int>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==6);\n}/max_subarray_sum.cpp\n#include<stdio.h>\n#include<vector>\nusing", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tcout<<get_max_subarray_sum(a,n);\n}#include<iostream>\nusing namespace", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/147", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\nint main(){\n\tauto result = get_matrix_triples(<FILL_ME>);\n\tassert(result==36);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10  }\n    return result;\n}\nint main(){\n\tauto result = get_matrix_triples(10);\n\tassert(result==36);\n}/20200915/20200915.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<", "fn": "get_matrix_triples", "para": "(int n)", "type": "int", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"});\n}/src/bf.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Uranus\"t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"3", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"});\n}/src/bf.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Uranus\";\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"}));\n}/cpp/100000000000000000000000000000000000000000000000000", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Uranus\");\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n\tresult = bf(\"Uranus\",\"Neptune\");\n\tassert(issame(result,{\"Uranus\",\"Neptune\"}));\n\tresult = bf(\"", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Uranus\");\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n\tresult = bf(\"Uranus\",\"Neptune\");\n\tassert(issame(result,{\"Uranus\",\"Neptune\"}));\n\tresult = bf(\"", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Uranus\");\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n\tresult = bf(\"Uranus\",\"Neptune\");\n\tassert(issame(result,{\"Uranus\",\"Neptune\"}));\n\tresult = bf(\"", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Neptune\");\n\tassert(issame(result,{\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n\tresult = bf(\"Uranus\",\"Neptune\" 10000000000000000000000", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Saturn\",\"Uranus\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Neptune\");\n\tassert(issame(result,{\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"}));\n\tresult = bf(\"Mars\",\"Uranus\";\n\tassert(issame(result,{\"1\",\"2\",\"3\"}));\n\tresult = bf(\"1", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Mars\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Mars\",\"Venus\");\n\tassert(issame(result,{}));\n\tresult = bf(\"Earth\",\"Earth\"t(result,{\"1\",\"2\",\"3\",\"4", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Mars\"}));\n\tresult = bf(\"Earth\",\"Uranus\");\n\tassert(issame(result,{\"Venus\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n\tresult = bf(\"Uranus\",\"Neptune\");\n\tassert(issame(result,{\"Jupiter\",\"Saturn\",\"Uranus\"}));\n\tresult = bf", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Earth\");\n\tassert(issame(result,{\"\"}));\n\tresult = bf(\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Mars\"}));\n\tresult = bf(\"Mars\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Mars\"}));\n\tresult = bf(\"Mars\",\"Mars\");\n\tassert(issame(result,{\"\"}));\n\tresult", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Mars\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Mars\",\"Venus\");\n\tassert(issame(result,{}));\n\tresult = bf(\"Venus\",\"Mars\");\n\tassert(issame(result,{}));\n", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Earth\");\n\tassert(issame(result,{});\n\tassert(issame(result,{\"2016-07-04\",\"2016-07-08\"}));\n\tresult = bf(\"2016-07-04\",\"201", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Venus\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Venus\");\n\tassert(iss", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Mars\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Earth\");\n\tassert(issame(result,{}));\n\tresult = bf(\"Mars\",\"Mars\";\n\tassert(issame(result,{\"1\",\"", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Mars\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Venus\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Venus\");\n\tassert(iss", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Earth\",\"Venus\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Earth\");\n\tassert(issame(result,{\"Venus\",\"Earth\"}));\n\tresult = bf(\"Venus\",\"Venus\");\n\tassert(iss", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\" 0;\n}/Codeforces/1000/1000/1000/1000.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0;i<n;i++) cin>>a[i];\n\t", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"}));\n}/cpp/10000000000000000000000000000000000000000000000000000", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/148", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nvector<string> bf(string planet1,string planet2){\n    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\nint main(){\n\tauto result = bf(<FILL_ME>);\n\tassert(issame(result,{\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "\"Earth\",\"Saturn\"\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"", "fn": "bf", "para": "(string planet1,string planet2)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abcd\",\"dcba\",\"llll\",\"gggg\",\"abcd\"}t(result,{\"1234567890\",\"0987654321\"}));\n}/codewars/7kyu/1234567890.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abcd\",\"dcba\",\"llll\",\"gggg\",\"pppp\",\"aaaa\",\"bbbb\",\"cccc\",\"dddd\",\"eeee\",\"ffff\",\"gggg\",\"hhhh\",\"iiii\",\"jjjj\",\"kkkk\",\"llll\",\"mmmm\",\"nnnn\",\"oooo\",\"pppp\",\"qqqq\",\"rrrr\",\"ssss\",\"tttt\",\"uuuu\",\"vvvv\",\"wwww\",\"xxxx\",\"yyyy\",\"zzzz\"}t(result,{\"1234567890", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abcd\",\"dcba\"};\n\tassert(issame(result,{\"1234567890\",\"0987654321\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abcd\",\"dcba\",\"llll\",\"abc\"}t.push_back(i);\n    }\n    return out;\n}\nint main(){\n\tauto result = find_all_even_numbers({1,2,3,4,5,6,7,8,9,10});\n\tassert(issame(result,{2,4,6,8,10}));\n}#include<stdio.h>\n#", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"abcd\",\"dcba\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"abcd\",\"dcba\",\"llll\",\"abc\",\"cba\"}t(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n}/test/test_alphabet_position.cpp\n#include<stdio.h>\n#include<vector>", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}t(result,{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n}/test/test_alphabet_position.cpp\n#include<stdio.h>\n#include<vector>\n#include<", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"cc\",\"dd\",\"aaaa\",\"bbbb\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"123456", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"aa\",\"bb\",\"ccc\",\"dd\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\",\"fff\"}\n\tassert(issame", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"aa\",\"bb\",\"ccc\",\"ddd\",\"eee\",\"ff\",\"gg\",\"hhh\",\"iiii\",\"jjjjj\"};\n\tassert(issame(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"aa\",\"bb\",\"ccc\",\"dd\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\",\"fff\"}t(result,{\"1", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"aa\",\"bb\",\"ccc\",\"ddd\",\"eee\",\"ff\",\"gg\",\"hhh\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"ddd\",\"eee\",\"ff\",\"gg\",\"hhh\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"ddd\",\"eee\",\"ff\",\"gg\",\"hhh\",\"i\",\"jj\",\"kk\",\"ll\",\"mm\",\"nn\",\"oo\",\"pp\",\"qq\",\"rr\",\"ss\",\"tt\",\"uu\",\"vv", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"aa\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"aa\",\"bb\",\"ccc\",\"dd\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"});\n\tassert(issame(result,{\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\"}));\n\tresult = sorted_list_sum({\"aa\",\"bb\",\"ccc\",\"dd\",\"eee\",\"fff\"}t(result,{\"a", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"school\",\"is\",\"great\",\"a\",\"AI\"});\n\tassert(issame(result,{\"a\",\"AI\",\"is\",\"school\"}));\n\tresult = sorted_list_sum({\"school\",\"is\",\"great\",\"a\",\"AI\",\"asdf\"}t(result,{\"a\",\"AI\",\"is\",\"school\"}));\n\tresult = sorted_list_sum({\"school\",\"is\",\"great\",\"a\",\"AI\",\"asdf\"});\n\tassert(issame(result,", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"school\",\"is\",\"great\",\"a\",\"AI\"});\n\tassert(issame(result,{\"a\",\"AI\",\"is\",\"school\"}));\n\tresult = sorted_list_sum({\"school\",\"is\",\"great\",\"a\",\"AI\",\"asdf\"}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"1", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"school\",\"is\",\"great\",\"a\",\"AI\"});\n\tassert(issame(result,{\"a\",\"AI\",\"is\",\"school\"}));\n\tresult = sorted_list_sum({\"school\",\"is\",\"great\",\"a\",\"AI\",\"asdf\"}t(result,{\"a\",\"AI\",\"is\",\"school\"}));\n\tresult = sorted_list_sum({\"school\",\"is\",\"great\",\"a\",\"AI\",\"asdf\"});\n\tassert(issame(result,", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"asdf\",\"AI\",\"school\"}\n\tassert(issame(result,{\"1234567890\",\"1234567890\"}));\n}/codewars/7kyu/1234567890.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": true}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"asdf\",\"school\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"asdf\",\"AI\",\"school\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"12345678", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123\",\"456\",\"789\"}t(result,{\"123\",\"456\",\"789\"});\n\tassert(issame(result,{}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"123\",\"456\",\"789\"}t(result,{\"123\",\"456\",\"789\"});\n\tassert(issame(result,{}));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"AI\",\"ai\",\"au\"}t(result,{\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"1234567890\",\"12345678", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"AI\",\"ai\",\"au\"}t(result,{\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"AI\",\"ai\",\"au\"}t(result,{\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"3", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"AI\",\"ai\",\"au\"}t_sum(lst);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}/sorted_list_sum.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/149", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\nint main(){\n\tauto result = sorted_list_sum(<FILL_ME>);\n\tassert(issame(result,{\"AI\",\"ai\",\"au\"}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{\"AI\",\"ai\",\"au\"}t(result,{\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345", "fn": "sorted_list_sum", "para": "(vector<string> lst)", "type": "vector<string>", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1,0;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n   ", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,0,1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n   ", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,0,1 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,0,1 0;\n}\n/2019/09/09/1.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,34,45\n\tassert(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,10,34 1000000000;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sum - a[i] < a[i]) {", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,34,1 1000000000, 34, 1000000000);\n\tassert(result == 34);\n}/x_or_y.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1,2\n\tassert(result==10);\n}/1000000000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,34,42;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,129,128\t\t}\n\t\t}\n\t\tif (i==0) {\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<\"YES\"<<endl;\n\t\tfor (int j=0;j<i;j++) cout<<a[j]<<\" \";\n\t\tcout<<endl;\n\t}\n}/codeforces/1005/C.", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "129,128,129;\n\tassert(result==129);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "129,128,129\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,129,130t main(){\n\tauto result = sum_of_digits(10);\n\tassert(result==1);\n}/sum_of_digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_digits(int n){\n    int sum=0", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==129);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "129,128,129\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,33,22\t\t}\n\t\t}\n\t\tif (i==0) break;\n\t\tif (i==1) {\n\t\t\tif (a[0]==1) {\n\t\t\t\tcout << \"1\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (i==2) {\n\t\t\tif (a[0]==1&&a[1]==1) {\n\t\t\t\tcout << \"1", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,33,100;\n\tassert(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,11,33\n\tassert(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,11,33\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==33);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,33,33;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2);\n\tassert(result==1);\n\tresult = x_or_y(11,1,2);\n\tassert(result==2);\n\tresult = x_or_y(12,1,2);\n\tassert(result==1);\n\tresult = x_or_y(13,1,2);\n\tassert(result==2);\n\tresult = x_or_y(", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,1,2t(result==1);\n}/test/test_1000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2);\n\tassert(result==1);\n\tresult = x_or_y(11,1,2);\n\tassert(result==2);\n\tresult = x_or_y(12,1,2);\n\tassert(result==1);\n\tresult = x_or_y(13,1,2);\n\tassert(result==2);\n\tresult = x_or_y(", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1,2 1000000000, 1, 2);\n\tassert(result == -1);\n}/x_or_y.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==-1);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2);\n\tassert(result==1);\n\tresult = x_or_y(11,1,2);\n\tassert(result==2);\n\tresult = x_or_y(12,1,2);\n\tassert(result==1);\n\tresult = x_or_y(13,1,2);\n\tassert(result==2);\n\tresult = x_or_y(", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234,123,456\n\tassert(result==1234);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n   ", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234,123,456;\n\tassert(result==1234);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234,123,456 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\",a+", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234,123,456\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}/Codeforces/1000~1999/1154/1154B.cpp\n#include<", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==1234);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234,123,456;\n\tassert(result==1234);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2,3t main(){\n\tauto result = max_of_four(1,2,3,4);\n\tassert(result==4);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint max_of_four(int a,int b,int c,int d){\n    int max=", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,3,4;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,3,5\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==3);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,2,3);\n\tassert(result==2);\n\tresult = x_or_y(11,2,3\n\tassert(result==1);\n}/test/test_10.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,583,583;\n\tassert(result==1000000000);\n}/1000000000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,583,583t(result==10);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tauto result = 10;\n\tasser;\n}#include<stdio.h>\n#include<math", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,583,583\n\tassert(result==1000000000);\n}/1000000000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==583);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000000000,1000000000,1000000000 0;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a[n];\n", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5,6\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,3,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_digit(int n){\n    int cnt=0;\n    while (n){\n        n/=10;\n        cnt++;\n    }\n    return cnt;\n}\nint main(){\n\tauto result =", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5,6\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint is_prime(int n){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5,6\t\t}\n\t\t}\n\t\tif (flag) break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}/1001-10000/10000/10000/10000.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==5);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,5,6\n\tassert(result==1);\n}/test/test_100000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long max(long long", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "100,1,2\t\t}\n\t\t}\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": false}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/150", "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\nint main(){\n\tauto result = x_or_y(<FILL_ME>);\n\tassert(result==2);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "10,1,2\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*", "fn": "x_or_y", "para": "(int n,int x,int y)", "type": "int", "pass": true}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0} 10000000000000000000000000000000000000000000000000000000000000000000000", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}t(result==1);\n}/codewars/cpp/tests/test_is_square.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing_letter(vector<char> lst){\n    for (int i=0;i<lst", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==34);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint sum_of_", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2)", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.5,2.5,3.5,4.5,5.5} 1000000000000000000;\n\tassert(result==1000000000000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing_number(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0} 100000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==25);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_the_number(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_the_number(vector<int> lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint count_the_number(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing_number(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint find_missing_number(vector<int> lst){\n    int sum=0;\n    for (int i=0", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==0);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0}t(result==1);\n}/test/test_is_prime.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n<2) return false;\n    if (n==", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0});\n\tlong long odd_sum=0;\n\tfor (int i=1;i<=5;i++)\n\tif (i%2==1) odd_sum+=i*i;\n\tprintf(\"%lld\\n\",odd_sumnclude<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint main(){", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0});\n\tlong long odd_sum=0;\n\tfor (int i=1;i<=5;i++)\n\tif (i%2==1) odd_sum+=i*i;\n\tassert(result==odd_sum);\n\tresult = double_the_difference({1.0,2.0,3.0,4.0,", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0});\n\tlong long odd_sum=0;\n\tfor (int i=1;i<=5;i++)\n\tif (i%2==1) odd_sum+=i*i;\n\tprintf(\"%lld\\n\",odd_sumt(result==expected);\n}/test/test_00000000", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0,2.0,3.0,4.0,5.0});\n\tlong long odd_sum=0;\n\tfor (int i=1;i<=5;i++)\n\tif (i%2==1) odd_sum+=i*i;\n\tassert(result==odd_sum);\n\tresult = double_the_difference({1.0,2.0,3.0,4.0,", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/151", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nlong long double_the_difference(vector<float> lst){\n    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\nint main(){\n\tauto result = double_the_difference(<FILL_ME>);\n\tassert(result==odd_sum);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{1.0, 2.0, 3.0, 4.0, 5.0});\n\tlong long odd_sum=0;\n\tfor (int i=1;i<=5;i++)\n\tif (i%2==1) odd_sum+=i*i;\n\tassert(result==odd_sum);\n\tresult = double_the_difference({1.0, 3.0, 5.", "fn": "double_the_difference", "para": "(vector<float> lst)", "type": "long long", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3}\n\tassert(issame(result,{1,2,3}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> runningSum(vector<int>& nums) {\n   ", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3}t> out;\n\tfor (int i=0;i<n;i++){\n\t\tint temp;\n\t\tcin>>temp;\n\t\tout.push_back(temp);\n\t}\n\treturn out;\n}\nint main(){\n\tvector<int> out = read();\n\tfor (int i=0;i<out.size();i++)\n\t\tcout", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3});\n\tassert(issame(result,{0,0,0}));\n\tresult = compare({1,2,3},{1,2,4});\n\tassert(issame(result,{0,0,1});\n\t}\n\treturn 0;\n}/1001.cpp\n#include<stdio.h>\nint main(){\n\tint n", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3}\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> out = s.twoSum({2,7,11,15},9);\n\tassert(issame(out,{0,1}));\n}/leetcode/1.cpp\n#include<stdio.h>\n#include<", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,4,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3}t> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare({1,2,3},{1,2,3});\n\tassert(issame(result,{2,4,6}));\n}", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6};\n\t}\n\treturn 0;\n}/1001.cpp\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int i=0;i<n;i", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3});\n\tassert(issame(result,{0,0,0}));\n\tresult = compare({1,2,3},{1,2,4});\n\tassert(issame(result,{0,0,1}));\n\tresult = compare({1,2,3},{1,2,3,4});\n\tassert(issame(result,{0,0,0,0}));\n\t", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3}\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};/leetcode/1002.cpp\nclass Solution {\npublic:\n\tvector<string> commonChars(vector<string>& A) {\n\t\tvector<string> out;\n\t\tvector<int> count(26, 0);\n\t\tfor (int i = 0; i < A", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6};\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\t", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{4,4,1,0,0,6}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3},{1,2,3});\n\tassert(issame(result,{0,0,0}));\n\tresult = compare({1,2,3},{1,2,4});\n\tassert(issame(result,{0,0,1}));\n\tresult = compare({1,2,3},{1,2,5});\n\tassert(issame(result,{0,0,2}));\n\tresult = compare({", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4},{1,2,3,4}t> out;\n    for (int i=0;i<nums.size();i++){\n        if (nums[i]==target) out.push_back(i);\n    }\n    return out;\n}\nint main(){\n\tauto result = searchRange({5,7,7,8,8,10},8);\n\tassert(issame(result", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4},{1,2,3,4}\n\tassert(issame(result,{1,2,3,4}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> runningSum(vector<", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4},{1,2,3,4}\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> out = s.countBits(5);\n\tassert(issame(out,{0,1,1,2,1,2}));\n}#include<stdio.h>\n#include<math.h>\n", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4},{1,2,3,4}\n\t}\n\treturn 0;\n}/1000/1000.cpp\n#include<stdio.h>\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d %d\",&a,&b)!=EOF){\n\t\tprintf(\"%d\\n\",a+b);/1001/1", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{2,0,0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4},{1,2,3,4}\t\t}\n\t\t}\n\t\treturn out;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> out = s.twoSum({2,7,11,15},9);\n\tassert(issame(out,{0,1}));\n}/leetcode/1.cpp\n#include<stdio.h>", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/152", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\nint main(){\n\tauto result = compare(<FILL_ME>);\n\tassert(issame(result,{0,0,0,0,0,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "{1,2,3,4,5,6},{1,2,3,4,5,6});\n\tassert(issame(result,{0,0,0,0,0,0}));\n\tresult = compare({1,2,3,4,5,6},{1,2,3,4,5,7});\n\tassert(issame(result,{0,0,0,0,0,1}));\n\tresult", "fn": "compare", "para": "(vector<int> game,vector<int> guess)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Boku123\",{\"YEs\",\"WeCaNe\",\"WeCan\",\"WeCanE\",\"WeCanEve\",\"WeCanEver\",\"WeCanEverEve\",\"WeCanEverEver\",\"WeCanEverEverEve\",\"WeCanEverEverEver\",\"WeCanEverEverEverEve\",\"WeCanEverEverEverEver\",\"WeCanEverEverEverEverEve\",\"We", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Boku123\",{\"YEs\",\"WeCaNe\",\"WeCaNe\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint Count_Vowels(string str){\n    int count=0;\n    for (", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Boku123\",{\"YEs\",\"WeCaNe\",\"YeS\",\"yEs\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"YeS\",\"Ye", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Boku123\",{\"YEs\",\"WeCaNe\",\"Boku123\"};\n\tassert(result==1);\n}/CodeWars/7kyu/Sum_of_Digits_Digital_Root.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Boku123.YEs.WeCaNe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Boku123\",{\"YEs\",\"WeCaNe\",\"123\"};\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"finNNalLLly\",{\"WoW\",\"Wow\",\"wow\",\"Wo\",\"W\",\"w\",\"o\",\"O\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW\",\"oW", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"finNNalLLly\",{\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"finNNalLLly\",{\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW\",\"WoW", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"final\",{\"WoW\",\"LLly\",\"NN\",\"fin\"});\n\tassert(result==\"final.WoW\");\n\tresult = Strongest_Extension(\"finNNalLLly\",{\"WoW\",\"LLly\",\"NN\",\"fin\"}\n\tassert(result==1);\n\tresult = Count_Pairs(10,10);\n\tassert(result==1);\n\tresult = Count_Pairs(10,11);\n", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"finNNalLLly.WoW\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"final\",{\"wow\",\"lly\",\"NN\",\"final\"});\n\tassert(result==\"final.NN\");\n\tresult = Strongest_Extension(\"final\",{\"wow\",\"lly\",\"NN\",\"final\",\"final\"});\n\tassert(result==\"final.final\");\n\tresult = Strongest_Extension(\"finNNalLLly\",{\"wow\",\"lly\",\"NN\",\"final\"};\n\tassert(result==1);\n\tresult = Count", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__HAHA\",{\"123\",\"abc\",\"ABC\"}  }\n    return result;\n}\nint main(){\n\tauto result = Sum_of_Cubes(1, 10);\n\tassert(result==3025);\n}/CodeWars/Sum_of_Cubes.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__HAHA\",{\"123\",\"abc\",\"ABC\"}  }\n    return result;\n}\nint main(){\n\tauto result = Sum_of_all_digits(123);\n\tassert(result==6);\n}/Sum_of_all_digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__HAHA\",{\"123\",\"abc\",\"ABC\",\"abc123\",\"123abc\"}  }\n    return result;\n}\nint main(){\n\tauto result = Sum_of_Digits(123);\n\tassert(result==6);\n}/Sum_of_Digits.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__HAHA\",{\"123\",\"abc\",\"ABC\",\"abc123\",\"123abc\"};\n\tassert(result==1);\n}/CodeSignal/Arcade/Intro/Level 1/10.arrayMaximalAdjacentDifference.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__HAHA.123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__HAHA\",{\"123\",\"abc\",\"ABC\"}t(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root(int", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"K\",{\"TAR\",\"ARC\",\"ABC\",\"ARC\"});\n\tassert(result==\"K.ARC\");\n\tresult = Strongest_Extension(\"K\",{\"TAR\",\"ARC\",\"ABC\",\"ARC\",\"ARC\"} 1000000000;\n\tassert(result==1000000000);\n\tresult = Max_Possible_Sum(1000000000,", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": true}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"K\", {\"TAR\", \"ARC\", \"ABC\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\", \"ABCDA\"});", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": true}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"K\", {\"TAR\", \"ARC\", \"ABC\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\", \"ABCDA\"});", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": true}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"K\", {\"TAR\", \"ARC\", \"ABC\"};\n\tassert(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint Sum_of_", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"K.TAR\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"K\", {\"TAR\", \"ARC\", \"ABC\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\"});\n\tassert(result==\"K.TAR\");\n\tresult = Strongest_Extension(\"K\", {\"TAR\", \"ARC\", \"ABC\", \"ABCDE\", \"ABCD\", \"ABCDA\"});", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": true}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Sp\",{\"671235\",\"671234\",\"671236\"} 1000000000;\n\tassert(result==1000000000);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Sp\",{\"671235\",\"671236\",\"671237\"} 10000000000000000000000000000000000000000000000000000000000000000000000", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Sp\",{\"671235\",\"671236\",\"671237\",\"671238\",\"671239\",\"671240\",\"671241\",\"671242\",\"671243\",\"671244\",\"671245\",\"671246\",\"671247\",\"67124", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Sp\",{\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"67123", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Sp.671235\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Sp\",{\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"671235\",\"67123", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__YESIMHERE\",{\"NuLl\",\"__\",\"__YESIMHERE\"}  }\n    return result;\n}\nint main(){\n\tauto result = Find_the_Missing_Element({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,2", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__YESIMHERE\",{\"NuLl\",\"__YESIMHERE\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"Nu", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__YESIMHERE\",{\"NuLl\",\"__\",\"__YESIMHERE\"}t(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint digital_root", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__YESIMHERE\",{\"NuLl\",\"__YESIMHERE\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"NuLl\",\"Nu", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"__YESIMHERE.NuLl__\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"__YESIMHERE\",{\"NuLl\",\"__\",\"__YESIMHERE\"};\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nint Number_Of_Times(string str,string word){\n    int count=0;\n    for", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"YameRore\",{\"okIWILL123\",\"okIWILL1234567890\",\"okIWILL12345678901234567890\"}t(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<math.h>\n", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"YameRore\",{\"okIWILL123\",\"okIWILL1234\",\"okIWILL12345\",\"okIWILL123456\",\"okIWILL1234567\",\"okIWILL12345678\",\"okIWILL123456789\",\"okIWILL1234567890\",\"okIWILL123456", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"YameRore\",{\"okIWILL123\",\"okIWILL1234567890\",\"okIWILL123456789012345678901234567890123456789012345678901234567890123456789", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"YameRore\",{\"okIWILL123\",\"okIWILL1234\",\"okIWILL12345\",\"okIWILL123456\",\"okIWILL1234567\",\"okIWILL12345678\",\"okIWILL123456789\",\"okIWILL1234567890\",\"okIWILL123456", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"YameRore.okIWILL123\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"YameRore\",{\"okIWILL123\",\"okIWILL1234\",\"okIWILL12345\",\"okIWILL123456\",\"okIWILL1234567\",\"okIWILL12345678\",\"okIWILL123456789\",\"okIWILL1234567890\",\"okIWILL123456", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbB\", \"Ccc\"});\n\tassert(result==\"A.Aa\");\n\tresult = Strongest_Extension(\"B\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbB\", \"Ccc\"});\n\tassert(result==\"B.Bb\");\n\tresult = Strongest_Extension(\"C\", {\"Aa\", \"Bb\", \"Cc\", \"A", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbB\", \"Ccc\"});\n\tassert(result==\"A.Aa\");\n\tresult = Strongest_Extension(\"B\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbB\", \"Ccc\"});\n\tassert(result==\"B.Bb\");\n\tresult = Strongest_Extension(\"C\", {\"Aa\", \"Bb\", \"Cc\", \"A", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"_.Aa\",{\"Aa\",\"Bb\",\"Cc\",\"Dd\",\"Ee\"});\n\tassert(result==\"_.Ee\");\n\tresult = Strongest_Extension(\"_.Aa\",{\"Aa\",\"Bb\",\"Cc\",\"Dd\",\"Ee\",\"Ff\",\"Gg\",\"Hh\",\"Ii\",\"Jj\",\"Kk\",\"Ll\",\"Mm\",\"Nn\",\"Oo\",\"Pp\",\"Qq\",\"Rr\",\"Ss\",\"Tt\",\"Uu\",\"Vv\",\"Ww\",\"Xx\",\"Yy\",\"Zz\"});\n\tassert(result==\"_.Zz\");\n", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"_.Aa\",{\"Aa\",\"Bb\",\"Cc\",\"Dd\",\"Ee\"});\n\tassert(result==\"_.Ee\");\n\tresult = Strongest_Extension(\"_.Aa\",{\"Aa\",\"Bb\",\"Cc\",\"Dd\",\"Ee\",\"Ff\",\"Gg\",\"Hh\",\"Ii\",\"Jj\",\"Kk\",\"Ll\",\"Mm\",\"Nn\",\"Oo\",\"Pp\",\"Qq\",\"Rr\",\"Ss\",\"Tt\",\"Uu\",\"Vv\",\"Ww\",\"Xx\",\"Yy\",\"Zz\"});\n\tassert(result==\"_.Zz\");\n", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"_.Bb\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbBb\", \"Ccc\"});\n\tassert(result==\"A.Aa\");\n\tresult = Strongest_Extension(\"B\", {\"Aa\", \"Bb\", \"Cc\", \"Aaa\", \"BbBb\", \"Ccc\"});\n\tassert(result==\"B.Bb\");\n\tresult = Strongest_Extension(\"C\", {\"Aa\", \"Bb\", \"Cc\", \"A", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Watashi\",{\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Watashi\",{\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Watashi\",{\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Watashi\",{\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/153", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<stdlib.h>\nstring Strongest_Extension(string class_name,vector<string> extensions){\n    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\nint main(){\n\tauto result = Strongest_Extension(<FILL_ME>);\n\tassert(result==\"Watashi.eIGHt8OKe\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"Watashi\",{\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt8OKe\",\"eIGHt", "fn": "Strongest_Extension", "para": "(string class_name,vector<string> extensions)", "type": "string", "pass": false}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_first_of(string a,string b){\n   ", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": true}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\"t(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": true}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abc\",\"bca\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abc\",\"cab\");\n\tassert(result==false);\n\tresult = cycpattern_check(\"abc\",\"cba\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": true}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\"\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> v={1,2,3,4,5,6,7,8,9};\n\tauto result = s.find_all_subsets(v", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": true}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_first_k(int *a,int n,int k", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": true}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abc\",\"ab\");\n\tassert(result==false);\n\tresult = cycpattern_check(\"abc\",\"bc\"t(result==1);\n\tresult = find_missing_number(arr,3);\n\tassert(result==2);\n\tresult = find_missing_number(arr,4);\n\tassert(result==", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": false}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\";\n\tassert(result==1);\n}/leetcode/1013.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": false}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\",\"abc\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abc\",\"ab\");\n\tassert(result==false);\n\tresult = cycpattern_check(\"abc\",\"bc\";\n\tassert(result==1);\n\tresult = find_max_subarray_sum(a,3);\n\tassert(result==1);\n\tresult = find_max_subarray_sum(a", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": false}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\"t(result==1);\n\tresult = find_missing_number(vector<int>{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": false}
{"task_id": "CPP/154", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool cycpattern_check(string a,string b){\n    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\nint main(){\n\tauto result = cycpattern_check(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abcde\",\"cdeab\");\n\tassert(result==true);\n\tresult = cycpattern_check(\"abcde\",\"abced\";\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(", "fn": "cycpattern_check", "para": "(string a,string b)", "type": "bool", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{0,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(),arr.end());\n    return arr;\n", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(-123456789);\n\tassert(issame(result,{5,4}));\n\tresult = even_odd_count(0\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(),arr.end());\n    return arr;\n", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(),arr.end());\n    return arr;\n", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{0,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{0,2}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{0,0}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{0,2}));\n\tresult = even_odd_count(3);\n\tassert(issame(result,{0,3}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(),arr.end());\n    return arr;", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{1,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{0,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(-123456789);\n\tassert(issame(result,{5,4}));\n\tresult = even_odd_count(0\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,3}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{1,3}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,3}));\n\tresult = even_odd_count(3);\n\tassert(issame(result,{1,3}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame(", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-34);\n\tassert(issame(result,{1,2});\n\tassert(issame(result,{1,2}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{3,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame(", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1t(result,10);\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint sum_digits(int num){\n    int sum=0;\n    while (num>0){\n        sum+=num%10;\n        num/=10;\n    }\n   ", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(),arr.end());\n    return arr;", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{0,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{0,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4});\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-34);\n\tassert(issame(result,{1,2})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame(", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})t(result,{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,3}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4});\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,2}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(3);\n\tassert(issame(result,{1,2}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(0);\n\tassert(issame(result,{1,0}));\n\tresult = even_odd_count(1);\n\tassert(issame(result,{0,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{0,2}));\n\tresult = even_odd_count", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})\n\tassert(issame(result,{1,2,3}));\n\tresult = sort_array(vector<int>{1,3,2});\n\tassert(issame(", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-1);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(2);\n\tassert(issame(result,{1,1}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(1234567890t(iss", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/155", "code": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nvector<int> even_odd_count(int num){\n    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\nint main(){\n\tauto result = even_odd_count(<FILL_ME>);\n\tassert(issame(result,{2,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "-123456789);\n\tassert(issame(result,{4,5}));\n\tresult = even_odd_count(123456789);\n\tassert(issame(result,{5,4})\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2", "fn": "even_odd_count", "para": "(int num)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "34t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "349);\n\tassert(result==\"ccclxiix\");\n\tresult = int_to_mini_romank(1994);\n\tassert(result==\"mcmxciv\");\n\tresult = int_to_mini_romank(1999  }\n    return result;\n}\nint main(){\n\tauto result = find_missing_number({1,2,3,4,5,6,7", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "345\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0;\n   ", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "349t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/12.Integer_to_Roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"clii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "34t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1524  }\n    return result;\n}\nint main(){\n\tauto result = find_missing_number({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1524;\n\tassert(result==1);\n}/leetcode/1221.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint balancedStringSplit(string s) {\n    int count=0;\n    int result=0;\n    for", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1524t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1324t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint count_bits(int number){\n    int count=0;\n    while(number>0)\n    {\n        count+=number&1;\n        number>>=1;\n   ", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"dxxxii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1324 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint *arr=new int[n];\n\tfor(int i=0;i<n;i++)\n\t\tcin>>arr[i];\n\tcout<<find_max_subarray(arr,n);\n}/max_subarray.cpp\n#include<iostream", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0;", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": true}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12. Integer to Roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"m\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000  }\n    return result;\n}\nint main(){\n\tauto result = find_missing_number({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/test/test_int_to_roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994;\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(vector<int>& nums) {\n    int result=0;\n    for(int i=0;", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/test/test_int_to_roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xix\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/test/test_int_to_roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234;\n\tassert(result==1);\n}/leetcode/1002.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> commonChars(vector<string>& A) {\n    vector<string> result;\n    vector<", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "124\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0;\n   ", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "124t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/src/12.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1234t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/12.Integer to Roman/main.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994;\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994  }\n    return result;\n}\nint main(){\n\tauto result = find_max_subarray(vector<int>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==6);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1999\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> nums={1,2,3,4,5,6,7,8,9,10};\n\tauto result = s.findDisappearedNumbers(nums);\n\tfor(auto i:result) cout<<i<<\" \";\n\tcout<<endl;\n}#", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cm\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/src/12_int_to_roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994 1;\n\t}\n\treturn result;\n}\nint main(){\n\tauto result = count_bits(10);\n\tassert(result==2);\n}/count_bits.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(vector<int>& nums) {\n    int result=0;\n    for(int i=0;i", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994  }\n    return result;\n}\nint main(){\n\tauto result = find_missing_number({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cmxciv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "215t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "249t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "314\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(vector<int>& nums) {\n    int result=0;\n    for(int i=0;i<", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994  }\n    return result;\n}\nint main(){\n\tauto result = find_max_subarray(vector<int>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==6);\n}/max_subarray.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"ccli\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "314t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "12t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12. Integer to Roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xc\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "123t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "126t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "126t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "126t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "126t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12. Integer to Roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"cdxxvi\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "126t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/12.Integer to Roman/main.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M\",\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M\",\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4;\n\tassert(result==1);\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(vector<int>& nums) {\n    int result=0;\n    for(int i=0;i<nums", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/12.Integer_to_Roman/main.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"iv\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "4;\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_min_steps(int n){\n    vector<int> dp(n+1,0);\n    for (int i=2;i<=n;i++)", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000;\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1000  }\n    return result;\n}\nint main(){\n\tauto result = find_max_subarray(vector<int>{-2,1,-3,4,-1,2,1,-5,4});\n\tassert(result==6);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/src/12.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n   ", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M\",\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_sum=0;\n    int current_sum=0;\n    for (int i=0", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": true}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}/leetcode/12. Integer to Roman.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n   ", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"i\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep={\"M\",\"", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994;\n\tassert(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint find_max_subarray(vector<int> &A){\n    int max_ending_here=0;\n    int max_so_far=0", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1994t_to_roman(1994);\n\tassert(result==\"MCMXCIV\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1999t_to_roman(1999);\n\tassert(result==\"MCMXCIX\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/156", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_mini_romank(int number){\n    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\nint main(){\n\tauto result = int_to_mini_romank(<FILL_ME>);\n\tassert(result==\"xliii\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "1999t_to_roman(1999);\n\tassert(result==\"MCMXCIX\");\n}#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring int_to_roman(int number){\n    string current=\"\";\n    vector<string> rep", "fn": "int_to_mini_romank", "para": "(int number)", "type": "string", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5);\n\tassert(result==true);\n\tresult = right_angle_triangle(3,4,6);\n\tassert(result==false);\n\tresult = right_angle_triangle(3,4,7\n\tassert(result==1);\n\tresult = find_max_subarray_sum(a,6);\n\tassert(result==1);\n\tresult = find_max_subarray_", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5);\n\tassert(result==true);\n\tresult = right_angle_triangle(3,4,6 1000000007;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> b[i];\n\t}", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5);\n\tassert(result==true);\n\tresult = right_angle_triangle(3,4,6t(result==1);\n\tresult = count_digit(1234567890);\n\tassert(result==10);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5);\n\tassert(result==true);\n\tresult = right_angle_triangle(3,4,6t(result==1);\n\tresult = get_max_profit(prices);\n\tassert(result==0);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint get_max", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==false);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5);\n\tassert(result==true);\n\tresult = right_angle_triangle(3,4,6 1000000000000000000000000000000000000000000000000000000000000000000", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5 1;\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<stdio.h>\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b)!=EOF){\n\t\tprintf(\"%d\\n\",a+b);\n\t\treturn\t\t}\n\t\t}\n\t\tprintf(\"%d", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result==true);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool is_prime(int n){\n    if (n==1) return false;\n    for (int i=2;i<=sqrt(n);i++){\n        if (n%i==0) return false;\n    }", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": true}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5t(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint main(){\n\tauto result = 1;\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": false}
{"task_id": "CPP/157", "code": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool right_angle_triangle(float a,float b,float c){\n    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\nint main(){\n\tauto result = right_angle_triangle(<FILL_ME>);\n\tassert(result==true);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "3,4,5\n\tassert(result==1);\n}#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint gcd(int a,int b){\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\nint main(){\n\tauto result = gcd(12,1", "fn": "right_angle_triangle", "para": "(float a,float b,float c)", "type": "bool", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"nation\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"nation\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"enam\", \"mere\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\",", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"enam\", \"mere\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\", \"enam\", \"mere\",", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"enam\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"enam\", \"mere\", \"mere\", \"enam\"});\n\tassert((result==\"enam\"));\n\tresult = find_max({\"enam\", \"mere\", \"mere\", \"enam\", \"enam\"});\n\tassert((result==\"enam\"));\n\tresult = find_max({\"enam\", \"mere\", \"mere\", \"enam\", \"enam\", \"enam\"});\n\tassert((result==\"enam", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"enam\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"enam\", \"mere\", \"mere\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\", \"enam\",", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abcde\",\"abac\"});\n\tassert((result==\"abcde\"));\n\tresult = find_max({\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\" });\n\tassert((result==\"abcd\"));\n\tresult = find_max({\"a\",\"aa\",\"aaa\",\"aaaa\"} 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\t", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"} 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tcout << find_max(a, n);\n}", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc\",\"abc", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"play\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"hello\",\"world\",\"leetcode\" }  }\n    return result;\n}\nint main(){\n\tauto result = find_max(vector<int>{1,2,3,4,5,6,7,8,9,10});\n\tassert((result==55));\n}/1-100/1-50/41-50/46.cpp\n#include<stdio.h>\n", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\"});\n\tassert((result==\"aaaaaaa\"));\n\tresult = find_max({\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\"});\n\tassert((result==\"aaaaaaa\"));\n\tresult = find_max({\"aaaaaaa\",\"aaaaaa", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"aaaaaaa\",\"aaaaaa\",\"aaaaa\",\"aaaa\",\"aaa\",\"aa\",\"a\"};\n\tassert((result==1));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"aaaaaaa\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\"});\n\tassert((result==\"aaaaaaa\"));\n\tresult = find_max({\"aaaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\",\"aaaaaa\"});\n\tassert((result==\"aaaaaaa\"));\n\tresult = find_max({\"aaaaaaa\",\"aaaaaa", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"this\", \"is\", \"a\", \"test\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\", \"this\"}t(result==1);\n}#include<stdio.h>\n#include<vector>", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"this\", \"is\", \"a\", \"test\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"this\", \"is\", \"a\", \"test\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"this\", \"is\", \"a\", \"test\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"this\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"this\", \"is\", \"a\", \"test\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"test\", \"this\", \"is\"});\n\tassert((result==\"test\"));\n\tresult = find_max({\"this\", \"is\", \"a\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abcde\",\"abca\"}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abcde\",\"abca\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;i<nums.size();i", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abcde\",\"abca\"}  }\n    return 0;\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n       ", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abcde\",\"abca\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;i<nums.size();i", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"abc\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"abc\",\"abca\",\"bcda\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;i<nums.size();i", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"foot\", \"bott\", \"bot\", \"bott\", \"foot\"});\n\tassert((result==\"footbott\"));\n\tresult = find_max({\"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"foot\", \"bott\", \"bot\", \"bott\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"foot\", \"bott\", \"bot\", \"bott\", \"foot\"});\n\tassert((result==\"footbott\"));\n\tresult = find_max({\"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"foot\"});\n\tassert((result==\"footbott\"));\n\tresult = find_max({\"foot\", \"bott\", \"bot\", \"bott\", \"foot\", \"foot\", \"foot\"});\n\tassert((result==\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"foot\", \"bott\", \"bot\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bot", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"footbott\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"foot\", \"bott\", \"bot\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bott\", \"bot", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"string\", \"ssing\", \"ssing\", \"string\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"ssing\", \"string\", \"string\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"ssing\", \"string\", \"string\", \"string\"}t(result==1);\n}#include<stdio.h>", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"string\",\"string\",\"string\"};\n\tassert((result==1));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;i<nums.size();", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"string\", \"ssing\", \"sss\", \"ss\", \"s\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"sss\", \"ss\", \"s\", \"string\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"sss\", \"ss\", \"s\", \"string\", \"string\"} 100000000", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"string\",\"string\",\"string\"}t(result==1);\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;i<nums.size();i++)\n       ", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"string\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"string\", \"ssing\", \"ss\", \"sss\", \"s\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"ss\", \"sss\", \"s\", \"string\"});\n\tassert((result==\"string\"));\n\tresult = find_max({\"string\", \"ssing\", \"ss\", \"sss\", \"s\", \"string\", \"string\"}\n\tassert((result==1));\n\t", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": true}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\",\"bc\",\"c\"}\n\tassert((result==1));\n}/leetcode/136.cpp\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint singleNumber(vector<int>& nums) {\n    int res=0;\n    for", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\",\"bc\",\"c\"}  }\n    return 0;\n}/Codeforces/1000/1000/1000/1000.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    for (int i=0;i<n;i++)\n        cin>>", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"ab\",\"ac\",\"bc\",\"abc\"};\n\tassert((result==1));\n}#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nint find_max(vector<int> nums){\n    int max=0;\n    for (int i=0;", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"ab\",\"ba\",\"aa\",\"bb\",\"aaa\",\"aab\",\"abb\",\"bbb\",\"aaaa\",\"aaab\",\"aabb\",\"abba\",\"abbb\",\"baaa\",\"baab\",\"babb\",\"bbaa\",\"bbab\",\"bbba\",\"bbbb\"});\n\tassert((result==\"bbbb\"));\n\tresult = find_max({\"a\",\"b\",\"ab\",\"ba\",\"aa\",\"bb\",\"aaa\",\"aab\",\"abb\",\"bbb\",\"aaaa\",\"aaab\",\"aabb\",\"abba\",\"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"b\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"ab\",\"ba\",\"aa\",\"bb\",\"aaa\",\"bbb\",\"aaaa\",\"bbbb\",\"abba\",\"baab\",\"abab\",\"baba\",\"aabb\",\"bbaa\",\"bbab\",\"ababa\",\"babab\",\"ababab\",\"bababa\",\"ababab\",\"bababab\",\"abababa\",\"bababab\",\"abababab\",\"babababa\",\"abababab\",\"babababa\",\"abababab\",\"babababa\",\"abababab\",\"babababa\",\"abababab\",\"babab", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"ab\",\"abc\",\"abcd\",\"abcde\",\"abcde\"});\n\tassert((result==\"abcde\"));\n\tresult = find_max({\"a\",\"ab\",\"abc\",\"abcd\",\"abcde\",\"abcde\"e<stdlib.h>\nint main(){\n\tauto result = find_max({1,2,3,4,5,6,7,8,9,10});\n\tassert((result==10));\n\t", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"});\n\tassert((result==\"abc\"));\n\tresult = find_max({\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\", \"abc\"});\n\tassert((result==\"abc\"));\n\tresult = find_max({\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\", \"abc\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n\tassert((result==\"z\"));\n\tresult = find_max({\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"});\n\tassert((result==\"z\"));\n\tresult = find_max({\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/158", "code": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#include<math.h>\n#include<stdlib.h>\nstring find_max(vector<string> words){\n    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\nint main(){\n\tauto result = find_max(<FILL_ME>);\n\tassert((result==\"gonna\"));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"});\n\tassert((result==\"abc\"));\n\tresult = find_max({\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\", \"cd\", \"d\"});\n\tassert((result==\"abcd\"));\n\tresult = find_max({\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\", \"", "fn": "find_max", "para": "(vector<string> words)", "type": "string", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,10);\n\tassert(issame(result,{2,9}));\n\tresult = eat(1,2,10);\n\tassert(issame(result,{3,8}));\n\tresult = eat(1,3,10);\n\tassert(issame(result,{4,7}));\n\tresult = eat(1,4,10);\n\tassert(issame(result,{5,6}));\n\t", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10,10\n\tassert(issame(result,{1,2,3}));\n}/leetcode/1480.cpp\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> runningSum(vector<int>& nums) {\n    vector<int> result;", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{12,1}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,10;\n\tassert(issame(result,{1,2,3}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> plusOne(vector<int>& digits) {\n    int carry = 1;\n    for(int i=digits.size()-", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,1);\n\tassert(issame(result,{2,0}));\n\tresult = eat(1,2,1);\n\tassert(issame(result,{3,0}));\n\tresult = eat(1,2,2);\n\tassert(issame(result,{3,0}));\n\tresult = eat(1,2,3);\n\tassert(issame(result,{3,1}));\n\tresult = eat(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,3,5\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};/leetcode/130.cpp\nclass Solution {\npublic:\n\tvoid solve(vector<vector<char>>& board) {\n\t\tint m = board.size();\n\t\tif (m == 0) return;\n\t\tint n = board[0].size();\n\t\tif (n == 0) return;\n\t\tvector<", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,1);\n\tassert(issame(result,{2,0}));\n\tresult = eat(1,2,2);\n\tassert(issame(result,{3,0}));\n\tresult = eat(1,3,3);\n\tassert(issame(result,{4,0}));\n\tresult = eat(1,4,4);\n\tassert(issame(result,{5,0}));\n\tresult = eat(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,2,3);\n\tassert(issame(result,{3,1}));\n\tresult = eat(2,3,4);\n\tassert(issame(result,{5,1}));\n\tresult = eat(3,4,5);\n\tassert(issame(result,{7,1}));\n\tresult = eat(4,5,6);\n\tassert(issame(result,{9,1}));\n\tresult = eat(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{5,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,1);\n\tassert(issame(result,{2,0}));\n\tresult = eat(1,2,2);\n\tassert(issame(result,{3,0}));\n\tresult = eat(1,3,3);\n\tassert(issame(result,{4,0}));\n\tresult = eat(1,4,4);\n\tassert(issame(result,{5,0}));\n\tresult = eat(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{11,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{12,0}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,12);\n\tassert(issame(result,{10,2}));\n\tresult = eat(10,10,13);\n\tassert(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,1);\n\tassert(issame(result,{2,0}));\n\tresult = eat(1,2,1);\n\tassert(issame(result,{3,0}));\n\tresult = eat(1,1,2);\n\tassert(issame(result,{2,1}));\n\tresult = eat(1,2,2);\n\tassert(issame(result,{3,1}));\n\tresult = eat(", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "0,3,10);\n\tassert(issame(result,{3,7}));\n\tresult = eat(3,3,7);\n\tassert(issame(result,{6,0}));\n\tresult = eat(6,3,0);\n\tassert(issame(result,{9,0}));\n\tresult = eat(9,3,0);\n\tassert(issame(result,{12,0}));\n\tresult =", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "0,3,10);\n\tassert(issame(result,{3,7}));\n\tresult = eat(3,3,7);\n\tassert(issame(result,{6,0}));\n\tresult = eat(6,3,0);\n\tassert(issame(result,{9,0}));\n\tresult = eat(9,3,0);\n\tassert(issame(result,{12,0}));\n\tresult =", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10,10);\n\tassert(issame(result,{11,0}));\n\tresult = eat(1,10,11);\n\tassert(issame(result,{11,1}));\n\tresult = eat(1,10,12);\n\tassert(issame(result,{11,2}));\n\tresult = eat(1,10,13);\n\tassert(issame(result", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{7,0}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10,10);\n\tassert(issame(result,{11,0}));\n\tresult = eat(1,10,11);\n\tassert(issame(result,{11,1}));\n\tresult = eat(1,10,12);\n\tassert(issame(result,{11,2}));\n\tresult = eat(1,10,13);\n\tassert(issame(result", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2,7,11,15},9);\n\tassert(issame(result,{0,1}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sort(vector<int> numbers){\n    sort(numbers.begin(),numbers", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,9);\n\tassert(issame(result,{10,1}));\n\tresult = eat(10,10,11);\n\tassert(issame(result,{11,0}));\n\tresult = eat(10,10,12);\n\tassert(iss", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10);\n\tassert(issame(result,{10,0}));\n\tresult = eat(10,10,5);\n\tassert(issame(result,{15,0}));\n\tresult = eat(10,10,15);\n\tassert(issame(result,{25,5}));\n\tresult = eat(10,10,25);\n\tassert(iss", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{11,4}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "10,10,10\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\nint main(){\n\tSolution s;\n\tvector<int> result = s.twoSum({2,7,11,15},9);\n\tassert(issame(result,{0,1}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,10);\n\tassert(issame(result,{2,9}));\n\tresult = eat(1,2,10);\n\tassert(issame(result,{3,8}));\n\tresult = eat(1,3,10);\n\tassert(issame(result,{4,7}));\n\tresult = eat(1,4,10);\n\tassert(issame(result,{5,6}));\n\t", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10,10);\n\tassert(issame(result,{11,0}));\n\tresult = eat(1,10,11);\n\tassert(issame(result,{11,1}));\n\tresult = eat(1,10,12);\n\tassert(issame(result,{11,2}));\n\tresult = eat(1,10,13);\n\tassert(issame(result", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10,10);\n\tassert(issame(result,{11,0}));\n\tresult = eat(1,10,9);\n\tassert(issame(result,{10,1}));\n\tresult = eat(1,10,11);\n\tassert(issame(result,{12,0}));\n\tresult = eat(1,10,12);\n\tassert(issame(result,{", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,10);\n\tassert(issame(result,{2,9}));\n\tresult = eat(1,2,10);\n\tassert(issame(result,{3,8}));\n\tresult = eat(1,3,10);\n\tassert(issame(result,{4,7}));\n\tresult = eat(1,4,10);\n\tassert(issame(result,{5,6}));\n\t", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/159", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> eat(int number,int need,int remaining){\n    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\nint main(){\n\tauto result = eat(<FILL_ME>);\n\tassert(issame(result,{9,2}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,1,10);\n\tassert(issame(result,{2,9}));\n\tresult = eat(1,2,10);\n\tassert(issame(result,{3,8}));\n\tresult = eat(1,3,10);\n\tassert(issame(result,{4,7}));\n\tresult = eat(1,4,10);\n\tassert(issame(result,{5,6}));\n\t", "fn": "eat", "para": "(int number,int need,int remaining)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"2\", \"3\", \"4\"}, {2, 3, 4, 2, 3, 4}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"1\", \"2\", \"3\", \"4\"}, {2, 3, 4, 5, 6, 7, 8}t(result==1);\n}#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint find_", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"1\", \"2\", \"3\", \"4\", \"5\"}, {5, 2, 3, 1, 2, 3, 4, 5}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"2\", \"3\", \"4\"}, {2, 3, 4, 2, 3, 4} 1000000000000000000000000000000000000000000000000000000000000000", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==8);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"1\", \"2\", \"3\", \"4\"}, {2, 3, 4, 5, 6, 7, 8} 1000000000000000000000000000000000000000000000000000000000", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"2\", \"3\", \"4\"}, {2, 3, 4, 5, 6, 7}  }\n    return 0;\n}/Codeforces/1000/1000A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k;\n    cin>>n>>k;\n    int a[n];\n   ", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"3\", \"4\", \"5\"}, {2, 3, 4, 5, 6, 7}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"1\", \"2\", \"3\"}, {2, 3, 4, 5, 6, 7} 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"2\", \"3\", \"4\"}, {2, 3, 4, 2, 3, 4}  }\n    return 0;\n}/Codeforces/1335/C.cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ar array\n#define", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==9);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"1\", \"2\", \"3\"}, {2, 3, 4, 1, 2, 3} 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"3\", \"4\", \"5\"}, {5, 4, 3, 2, 1, 0} 0;\n}/1000/1000.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"+\",\"*\",\"**\",\"-\",\"//\"},{1,2,3,4,5} 0;\n}/2020/01/20200114/20200114_01.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"+\", \"*\", \"**\", \"/\", \"+\", \"-\"}, {1, 2, 3, 4, 5, 6} 100000000000000000000000000000000000000000000000000000000000000000000", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"**\", \"*\", \"+\", \"2\", \"3\", \"4\"}, {2, 3, 4, 5, 6, 7}t(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/160", "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\nint main(){\n\tauto result = do_algebra(<FILL_ME>);\n\tassert(result==37);\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "{\"+\",\"*\",\"**\",\"//\",\"-\"},{3,4,2,5,1}  }\n    return 0;\n}/Codeforces/1100/1100A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> a(n);\n    for (int i=0;", "fn": "do_algebra", "para": "(vector<string> operato, vector<int> operand)", "type": "int", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2@6#\"\n\tassert(result==1);\n}/Codeforces/118A.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(string s){\n    int n=0;\n    for (int i=0;i<s.length();i++)\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2@6#\"t(result==1);\n}/Codeforces/1311/C.cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ar array\n#define ff first\n#define ss second\n#define rep(i,a,b) for (int i=a;i<=b", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2@6#\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2@6#\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"2@6#\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"2@6#\"t(result==1);\n}/test/test_1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSdF\"  }\n    return 0;\n}/Codeforces/1000/1000/1000/1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSdF\" 1000000000;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tif (a[i] < min) {\n\t\t\tmin = a[i];\n\t\t}\n\t\tif (a[i] > max) {\n\t\t\tmax = a[i];\n\t\t}\n\t}\n\tcout << max -", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSdF\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSdF\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"aSdF\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSdF\"  }\n    return 0;\n}/Codeforces/1328/A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        int n;\n        cin>>n;\n        int a[n];\n        for (int i=0;i<n;i++) cin>>a[i];", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"c\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5==", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"c\"  }\n    }\n    return 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    int a[n];\n    for (int i=0;i<n;i++)\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"c\"\n\tassert(result==1);\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n,int m,int k){\n    int out=0;\n    for (int i=0", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"CCC\"\n\tassert(result==1);\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n,int m){\n    int a[n];\n    for (int i=0;i<", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#CCC\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"CCC\"\t\t}\n\t\t}\n\t\tif (n==1)\n\t\t{\n\t\t\tcout<<\"Case #\"<<i<<\": \"<<1<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"Case #\"<<i<<\": \"<<n<<endl;\n\t\t}\n\t}\n\treturn 0;\n}#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5==", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234\"  }\n    return 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"4321\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"1234\"  }\n    return 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBc\"t(result==1);\n}/CodeWars/C++/7kyu/Sum of Digits/main.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint digital_root(int n) {\n    int sum=0;\n    while (n>0)\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBc\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5==", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBc\"  }\n    }\n    return 0;\n}/Codeforces/1300/1300A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        int n,k;\n        cin>>n>>k;\n        int a[n];\n        for (int i=0;i<n", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#A@c\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBc\"  }\n    return 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSDFw^45\"  }\n    return 0;\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSDFw^45\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSDFw^45\"t(result==\"#aSDFw^45\");\n}/cpp/string_reverse.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    string out=\"\";\n    for (int i=s.length()-1;i>=", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSDFw^45\"  }\n    return 0;\n}/Codeforces/1200/1200A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    for (int i=0;i<n;i++) cin>>a[i];\n    int m;\n    cin>>m;", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#aSDFw^45\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aSDFw^45\"  }\n    return 0;\n}/Codeforces/1000/1000/1000/1000.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A^d\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"A^d\" 1000000000000000000;\n\tassert(result == 1000000000000000000);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBcDeF\"t(result==\"#$A^d\");\n}/CodeWars/C++/7kyu/String_to_Camel_Case.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring to_camel_case(string s) {\n    string out=\"\";\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBcDeF\" 1000000000000000000;\n\tassert(result==1000000000000000000);\n}/Codeforces/1000/1000A.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"#$A^d\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aBcDeF\"\n\tassert(result==1);\n}/CodeWars/7kyu/CountingDuplicates.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint duplicateCount(const string& str) {\n    int n=0;\n    for (int i=0;", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aB\"\n\tassert(result==1);\n}/Codeforces/1335/A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int a,int b,int c){\n   ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aB\"\n\tassert(result==1);\n}/Codeforces/118A.cpp\n#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(string s){\n    int n=0;\n    for (int i=0;i<s.length();i++)\n    {", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aB\"t(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5==0)", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aB\"  }\n    return 0;\n}/Codeforces/1300/1300A.cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        int n;\n        cin>>n;\n        int a[n];\n        for (int i=0;i<n;i++)\n        {\n           ", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/161", "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring solve(string s){\n    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\nint main(){\n\tauto result = solve(<FILL_ME>);\n\tassert(result==\"AB\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"aB\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint solve(int n){\n    int out=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (i%3==0 or i%5==", "fn": "solve", "para": "(string s)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tauto result = MD5_Init(NULL);#include<stdio.h>\n#include<string>\n#", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}\n/2019/10/21/1.cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<stack>\n#include<queue>\n#", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}/1001.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i=0", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\tassert(result==1);\n}/test/test_1.cpp\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tassert(result==1);", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"0ef78513b0cb8cef12743f5aeb35f888\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}\n/1000/1000.cpp\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<map>\n#include<set>\n#include<queue>\n#include", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tauto result = string_to_md5(\"hello\");\n\tassert(result==1);\n}", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"abc\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint result = 1;\n\tassert(result==1);\n}#include<stdio.h", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}/1001.cpp\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\" 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"3e25960a79dbc69b674cd4ec67a72c62\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tauto result = string_to_md5(\"hello\");\n\tassert(result==1);\n}", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"\n\t}\n\treturn 0;\n}\n/1001.cpp\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"t(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return 0;\n   ", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"e(int x, int y, int z) {\n        return x + y + z;\n    }\n};\n\nint main() {\n    Solution s;\n    cout << s.threeSumClosest(vector<int>{-1, 2, 1, -4}, 1) << endl;\n    return 0;\n}/leetcode/16.cpp\n#include <iostream>\n#include <vector>\n#", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"hello\"t_str;\n}\nint main(){\n\tauto result = string_to_sha1(\"hello\");\n\tassert(result==\"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\");\n}/cpp/sha1.cpp\n#include<stdio.h>\n#include<string>\n#include<openssl/sha.", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n\tif (n==1) return 0;\n\tif (n==2) return 1;\n", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"t_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(\"123456\");\n\tassert(result==\"202cb962ac59075b964b07152d234b70\");\n}#include<stdio.h>\n#include<string>", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\";\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n\tint result = 1\n\tassert(result==1);\n}#include<stdio.h>\n", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": false}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return 0;\n   ", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/162", "code": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nstring string_to_md5(string text){\n    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\nint main(){\n\tauto result = string_to_md5(<FILL_ME>);\n\tassert(result==\"None\");\n}", "utils": "#undef NDEBUG\n#include<assert.h>\n\n", "filling": "\"\"\n\tassert(result==1);\n}#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint is_prime(int n){\n\tif (n==1) return 0;\n\tif (n==2) return 1;\n", "fn": "string_to_md5", "para": "(string text)", "type": "string", "pass": true}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10t(result,{1,2,3,4,5,6,7,8,9,10});\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "2,8  }\n    return 0;\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    vector<int> a(n);\n    for (int i=0;i<n;i++)\n    {\n        scanf(\"%d", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10  }\n    return 0;\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d%d", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10\n\tassert(issame(result,{1,2,3,4,5,6,7,8,9,10}));\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": true}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{2,4,6,8}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "2,8t(result,10);\n}#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nint sum_digits(int n){\n    int out=0;\n    while (n>0)\n    {\n        out+=n%10;\n        n/=10;\n    }\n    return out;", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,1);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,11);", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10);\n\tassert(issame(result,{2,4,6,8}));\n\tassert(issame(generate_integers(1,1),{}));\n\tassert(issame(generate_integers(1,100),{}));\n\tassert(issame(generate_integers(100,1),{}));\n\tassert(issame(generate_integers(100,100),", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,1);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(1,1", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,1);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(1,1", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
{"task_id": "CPP/163", "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> generate_integers(int a,int b){\n    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\nint main(){\n\tauto result = generate_integers(<FILL_ME>);\n\tassert(issame(result,{}));\n}", "utils": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\n", "filling": "1,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,1);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(10,10);\n\tassert(issame(result,{2,4,6,8}));\n\tresult = generate_integers(1,1);\n\t", "fn": "generate_integers", "para": "(int a,int b)", "type": "vector<int>", "pass": false}
